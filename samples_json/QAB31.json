{
  "task_id": "QAB31",
  "description": "This benchmark evaluates a 15-qubit implementation of Grover's algorithm. The task is to insert a diagnostic assertion that verifies whether the target bitstring is successfully amplified compared to other measurement outcomes. The circuit uses a controlled oracle and diffuser for amplitude amplification. A faulty variant disables the diffuser to simulate poor amplification, while the assertion checks if the target state is significantly more likely than any other.\n",
  "program": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    grover.summarize_results()\n",
  "complete_prompt": "This quantum program implements Grover's algorithm over a 15-qubit search space.\nA target bitstring is embedded in the oracle, and the circuit applies several rounds\nof amplification to increase its measurement probability.\n\nAdd a diagnostic assertion that checks whether the target bitstring is sufficiently amplified\nin the final output distribution. The assertion should confirm that this target state\nstands out from the rest and appears significantly more frequently than other states.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file â€” nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmarkWithAssertion:\n    \"\"\"\n    QAB-31: Grover's Algorithm on 15 qubits with GOLD ASSERTION.\n    Verifies that the target bitstring is most probable in measurement outcomes.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        self.circuit.h(self.qr)\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n\n        second_best = sorted_counts[1][1] / total if len(sorted_counts) > 1 else 0\n\n        print(f\"[GOLD ASSERTION] Target state probability: {target_prob:.3%}\")\n        print(f\"[GOLD ASSERTION] Second-highest state probability: {second_best:.3%}\")\n\n        assert target_prob > second_best * 2, (\n            f\"Target state not sufficiently amplified. \"\n            f\"Target: {target_prob:.3%}, Second-best: {second_best:.3%}\"\n        )\n        # ----- GOLD ASSERTION END -----\n\n        return self.counts\n\n    def summarize_results(self):\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmarkWithAssertion()\n    output = grover.run()\n    grover.summarize_results()\n",
  "faulty": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 FAULTY: Grover's Algorithm with missing diffuser.\n    The oracle correctly marks the target, but amplitude amplification is disabled.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        self.circuit.h(self.qr)\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            # diffuser intentionally skipped\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    grover.summarize_results()\n"
}