{
  "task_id": "QAB03",
  "description": "This circuit initializes three qubits with fixed probabilities of measuring |1⟩, then applies two SWAP operations to move the quantum state of qubit 2 to qubit 0. The task is to generate an assertion that verifies whether the final measurement probability of qubit 0 matches that of the original qubit 2.\n",
  "program": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n",
  "complete_prompt": "Generate an assertion for the following Qiskit program to verify that qubit q0 ends up in the same quantum state that was initially prepared in qubit q2. The assertion should be inserted in an appropriate location and be expressed in Python code.\n    \nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # Probabilities for q0, q1, q2\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run_and_assert(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n        # Measure probability of q0 = 1\n        counts_1 = sum(v for k, v in self.counts.items() if k[-1] == \"1\")\n        prob_q0 = counts_1 / shots\n\n        assert abs(prob_q0 - 0.7) < tolerance, (\n            f\"q0 measured probability {prob_q0:.3f} \"\n            f\"does not match expected {self.expected_prob_q0:.3f}\"\n        )\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run_and_assert()\n",
  "faulty": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass FaultySwapCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # Probabilities for q0, q1, q2\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # Expectation: q0 should match q2 (The probability of being at ‘1’ is 0.7), but swap order is wrong\n        self.expected_prob_q0 = probs[2]\n\n    def _apply_swaps(self):\n        self.qc.swap(0, 1)\n        self.qc.swap(2, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = FaultySwapCircuit()\n    circuit.run()\n"
}