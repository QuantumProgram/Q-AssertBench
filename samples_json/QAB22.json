{
  "task_id": "QAB22",
  "description": "This quantum program demonstrates that applying the Quantum Fourier Transform (QFT) followed by its inverse (QFT†) recovers the original input state. In this example, the input state |101⟩ is prepared. After QFT and QFT†, the measurement results should be concentrated on |101⟩ (probability > 0.5). The task is to generate an assertion that verifies this identity property.\n",
  "program": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")\n",
  "complete_prompt": "This quantum program applies the Quantum Fourier Transform (QFT) followed by its inverse (QFT†).\nFor any input state, the combined transformation should recover the original state.\nInsert an assertion into the program to verify that the output distribution matches the prepared input state.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport math\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        if prepare_input:\n            prepare_input(circuit)\n\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)  # prepare |101>\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # ----- GOLD ASSERTION START -----\n    expected_state = \"101\"\n    dominant = max(counts, key=counts.get)\n    dominant_prob = counts[dominant] / qft_runner.shots\n\n    assert dominant == expected_state and dominant_prob > 0.4, (\n        f\"Expected {expected_state} to dominate (>40%), got {counts}\"\n    )\n    # ----- GOLD ASSERTION END -----\n\n    print(\"QFT followed by QFT† assertion passed.\")\n    print(\"Measurement Counts:\", counts)\n",
  "faulty": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QFTWithInverse:\n    def __init__(self, n=3, shots=1024):\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        if prepare_input:\n            prepare_input(circuit)\n\n        self.apply_qft(circuit)\n        #self.apply_qft_dagger(circuit)\n\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    runner = QFTWithInverse(n=3, shots=1024)\n\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)  # |101>\n\n    counts = runner.build_and_run(prepare_input=prepare_input)\n\n    print(\"Faulty QFT+QFT† Result on |101> (3 qubits):\", counts)\n"
}