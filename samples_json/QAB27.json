{
  "task_id": "QAB27",
  "description": "This quantum program demonstrates a simplified period-finding step of Shor's algorithm for N=15, a=2. The quantum measurement provides an approximation to k/r, which must be classically post-processed using continued fraction expansion. The expected result is a period r=4. The task is to generate an assertion that verifies the continued fraction step correctly recovers r=4 from the quantum output.\n",
  "program": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n",
  "complete_prompt": "This quantum program implements a simplified period-finding circuit for Shor's algorithm.\nThe measurement output must be classically post-processed using continued fraction expansion\nto recover the period r of the modular function. Insert an assertion into the program\nthat verifies the continued fraction calculation correctly recovers the period r.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nfrom fractions import Fraction\n\n\nclass ShorPeriodFindingWithAssertion:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n        qc.h(range(self.n))\n        qc.barrier()\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        dominant = max(counts, key=counts.get)\n        x = int(dominant, 2)\n        frac = Fraction(x, 2 ** self.n).limit_denominator(15)  # keep denominator small\n        r = frac.denominator\n\n        # Allow r = 4 or multiples (e.g., 8) since continued fraction can overshoot\n        assert r % 4 == 0, f\"Expected period multiple of 4, got r={r} from x={x}\"\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingWithAssertion()\n    output = shor.run()\n    print(\"Shor period-finding assertion passed.\")\n    print(\"Measurement Counts:\", output)\n",
  "faulty": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nfrom fractions import Fraction\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_faulty_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # ❌ Faulty: Prepare uniform superposition\n        qc.h(range(self.n-1))\n        qc.barrier()\n\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_faulty_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Faulty Shor period finding (expected to fail):\", output)\n"
}