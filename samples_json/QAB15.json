{
  "task_id": "QAB15",
  "description": "This quantum program implements the Bernstein–Vazirani algorithm with three input qubits and one ancilla qubit. A critical step in the algorithm is the preparation of a uniform superposition across all input qubits. The task is to generate an assertion that verifies this uniform distribution, ensuring that the Hadamard layer has been correctly applied.\n",
  "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
  "complete_prompt": "This quantum program implements the Bernstein–Vazirani algorithm.\nAt the beginning of the algorithm, the input qubits should be placed into a uniform superposition.\nInsert an assertion into the program to verify that the prepared state indeed corresponds to a uniform distribution.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        Assertion: check that uniform superposition is correctly prepared.\n        \"\"\"\n        self.a = a\n        self.n = len(a)\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_uniform_superposition(self):\n        circuit = QuantumCircuit(self.n, self.n)  # only input qubits (ignore ancilla for this check)\n\n        # Prepare |0^n>\n        # Apply Hadamards to all input qubits\n        for i in range(self.n):\n            circuit.h(i)\n\n        # Add measurement\n        for i in range(self.n):\n            circuit.measure(i, i)\n\n        return circuit\n\n    def run(self):\n        circuit = self.build_uniform_superposition()\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Expect uniform distribution across all 2^n states\n        expected_prob = 1 / (2**self.n)\n        tolerance = 0.1  # allow ~10% deviation\n\n        for state in [format(i, f\"0{self.n}b\") for i in range(2**self.n)]:\n            prob = counts.get(state, 0) / self.shots\n            assert abs(prob - expected_prob) < tolerance, (\n                f\"State {state} has probability {prob:.3f}, expected ~{expected_prob:.3f}\"\n            )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Uniform Superposition Test, Measurement Counts:\", output)\n",
  "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            if i != 1:  # ❌ faulty: skip H on qubit 1\n                self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
}