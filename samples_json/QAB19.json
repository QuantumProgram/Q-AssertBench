{
  "task_id": "QAB19",
  "description": "This quantum program implements Simon’s algorithm with hidden period a = \"11\". In the final step, the measurement results of the input qubits must satisfy the constraint z·a=0 (mod 2), where z is the observed bitstring and a is the hidden string. For a = \"11\", only '00' and '11' should appear, while '01' and '10' are invalid. The task is to generate an assertion that verifies this property in the observed results.\n",
  "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n",
  "complete_prompt": "This quantum program implements Simon’s algorithm with a hidden period.\nThe final measurement results of the input qubits are expected to satisfy a linear constraint with respect to the hidden string.\nInsert an assertion into the program to check that the observed input results meet this constraint.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmConstraintCheck:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n        self.circuit = QuantumCircuit(2 * self.n, self.n)\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        for i in range(self.n):\n            self.circuit.h(i)\n        self.apply_oracle()\n        for i in range(self.n):\n            self.circuit.h(i)\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # For a = \"11\", valid z must satisfy z0+z1 ≡ 0 (mod 2)\n        for z, cnt in counts.items():\n            dot = (int(z[0]) * int(self.a[0]) + int(z[1]) * int(self.a[1])) % 2\n            assert dot == 0, f\"Invalid result {z} violates constraint z·a=0\"\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    checker = SimonsAlgorithmConstraintCheck()\n    output = checker.run()\n    print(\"Constraint Test, Measurement Counts:\", output)\n",
  "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n        self.circuit = QuantumCircuit(2 * self.n, self.n)\n\n    def apply_oracle(self):\n        # ❌ Faulty oracle: missing one CX connection\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        # skip cx(1,3)\n\n    def build_circuit(self):\n        for i in range(self.n):\n            self.circuit.h(i)\n        self.apply_oracle()\n        for i in range(self.n):\n            self.circuit.h(i)\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
}