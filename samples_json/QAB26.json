{
  "task_id": "QAB26",
  "description": "This quantum program demonstrates the period-finding subroutine of Shor's algorithm. For N=15 and a=2, the periodic function x ↦ 2^x mod 15 has period r=4. The expected measurement outcomes are consistent with multiples of 2 in the computational basis (000, 010, 100, 110). The task is to generate an assertion that verifies this periodicity.\n",
  "program": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n",
  "complete_prompt": "This quantum program implements the period-finding subroutine of Shor's algorithm.\nFor the example N=15, a=2, the expected measurement outcomes reveal a periodicity of r=4.\nInsert an assertion into the program to verify that the observed results are consistent\nwith this period, i.e., that the measurement outcomes include the states corresponding\nto multiples of 2 within the 3-bit register.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport math\n\n\nclass ShorPeriodFindingAssertion:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n        qc.x(0)\n\n        # Controlled multiplications mod 15 (simplified)\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Expect outcomes consistent with period r=4: x = 0, 2, 4, 6\n        valid_outcomes = {\"000\", \"010\", \"100\", \"110\"}  # low 3 classical bits\n        observed = set(k[-3:] for k in counts.keys())\n        assert observed & valid_outcomes, (\n            f\"Expected periodic outcomes {valid_outcomes}, got {observed}\"\n        )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingAssertion()\n    output = shor.run()\n    print(\"Shor period-finding assertion passed.\")\n    print(\"Measurement Counts:\", output)\n",
  "faulty": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_faulty_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n        qc.x(0)\n\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        qc.h(4)\n        # ❌ Faulty: skip some cswap operations\n        qc.cswap(4, 3, 2)\n        # missing qc.cswap(4, 2, 1)\n        # missing qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_faulty_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Faulty Shor period finding result:\", output)\n"
}