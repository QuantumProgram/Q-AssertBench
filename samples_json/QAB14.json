{
  "task_id": "QAB14",
  "description": "This quantum program implements the Deutsch–Jozsa algorithm with two input qubits and one ancilla qubit. The oracle type is determined by a parameter: oracle_type=0 corresponds to a constant function, while oracle_type=1 corresponds to a balanced function. The expected measurement outcomes differ accordingly: - For constant: the input qubits should be observed as '00'. - For balanced: the input qubits should not be observed as '00'. The task is to generate an assertion that verifies consistency between the oracle type and the observed measurement results.\n",
  "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n",
  "complete_prompt": "This quantum program implements the Deutsch–Jozsa algorithm with a configurable oracle.\nThe oracle type is selected by a parameter, which determines whether the function is constant or balanced.\nInsert an assertion into the program that verifies consistency between the oracle parameter and the measurement results.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            pass\n        elif self.oracle_type == 1:\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        self.circuit.x(2)\n        for i in range(3):\n            self.circuit.h(i)\n        self.apply_oracle()\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        if self.oracle_type == 0:\n            # Constant oracle → Expect nearly all results '00'\n            assert \"00\" in counts and counts[\"00\"] > 0.9 * self.shots, (\n                f\"Expected constant outcome '00', got {counts}\"\n            )\n        elif self.oracle_type == 1:\n            # Balanced oracle → Input qubits should not be all zero\n            zero_counts = counts.get(\"00\", 0)\n            assert zero_counts < 0.1 * self.shots, (\n                f\"Expected balanced outcome (non-zero states), got {counts}\"\n            )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n",
  "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Faulty version: Oracle always implemented as balanced, even if oracle_type=0\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # ❌ Faulty: always balanced\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        self.circuit.x(2)\n        for i in range(3):\n            self.circuit.h(i)\n        self.apply_oracle()\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Faulty Oracle type {oracle_type}, Measurement Counts:\", output)\n"
}