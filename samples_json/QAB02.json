{
  "task_id": "QAB02",
  "description": "The program prepares a 2-qubit Bell state using a Hadamard gate and a CNOT gate. The final quantum state should be an entangled state (|00⟩ + |11⟩)/√2, where both measurement outcomes appear with roughly equal probability. The goal is to assert whether the entanglement behavior is preserved through the measurements.\n",
  "program": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n\n",
  "complete_prompt": "Given the following quantum program, generate a single assertion that verifies whether the two qubits are entangled in a Bell state.\n    \nOutput the complete modified program with the assertion included. No explanations, no comments, no step-by-step thinking.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    #print(counts)\n    \n    # === GOLD ASSERTION ===\n    shots = 1024\n    ratio_00 = counts.get('00', 0) / shots\n    ratio_11 = counts.get('11', 0) / shots\n    assert all(k in ['00', '11'] for k in counts), \"Unexpected outcomes detected\"\n    assert 0.4 <= ratio_00 <= 0.6 and 0.4 <= ratio_11 <= 0.6, \"Imbalanced distribution — likely not Bell state\"\n    # ======================\n\n",
  "faulty": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass NonEntangledCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.h(1)  # Fault: both qubits in superposition, but not entangled\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = NonEntangledCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n"
}