{
  "task_id": "QAB25",
  "description": "This quantum program implements Grover's algorithm on 3 qubits. The oracle marks states |101⟩ and |110⟩, and the diffusion operator amplifies their probabilities. The task is to generate an assertion that verifies the amplification works correctly, by checking that the marked states dominate the final measurement results.\n",
  "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n",
  "complete_prompt": "This quantum program implements Grover's search algorithm on 3 qubits.\nThe diffusion operator (inversion about the mean) is a crucial step to amplify the marked states.\nInsert an assertion into the program to verify that after the diffusion operator,\nthe marked states dominate the measurement outcomes with significantly higher probability than uniform.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionAssertion:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        target_states = [\"101\", \"110\"]\n        total_target = sum(counts.get(s, 0) for s in target_states)\n        max_non_target = max(\n            [cnt for state, cnt in counts.items() if state not in target_states],\n            default=0,\n        )\n\n        assert total_target > max_non_target, (\n            f\"Expected targets {target_states} to dominate, \"\n            f\"but got counts={counts}\"\n        )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionAssertion()\n    output = grover.run()\n    print(\"Diffusion operator assertion passed.\")\n    print(\"Measurement Counts:\", output)\n",
  "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverDiffusion:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        qc.h(range(self.n))\n        qc.barrier()\n\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        qc.h(range(self.n))\n        # ❌ Missing qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        # qc.x(range(self.n)) missing\n        qc.h(range(self.n))\n\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverDiffusion()\n    output = grover.run()\n    print(\"Faulty Grover with broken diffusion:\", output)\n"
}