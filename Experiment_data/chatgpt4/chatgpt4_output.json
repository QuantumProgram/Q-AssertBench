[
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert any(all(key[4-i] in '01' for key in counts if counts[key]) and len(set(key[4-i] for key in counts)) == 1 for i in range(5)) and any(len(set(key[4-i] for key in counts)) > 1 for i in range(5))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (all(bit[3] == '1' for bit in counts) or all(bit[2] == '0' for bit in counts)) and any(any(bit[i] == '0' for bit in counts) and any(bit[i] == '1' for bit in counts) for i in [0,3,4])\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (all(all(bit[3] == '1' for bit in counts) or all(bit[3] == '0' for bit in counts) or all(bit[2] == '1' for bit in counts) or all(bit[2] == '0' for bit in counts)) and any(any(bit[i] == '0' for bit in counts) and any(bit[i] == '1' for bit in counts) for i in [0,3,4]))\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (any(all(bits[4-i] in ('0','1') and all(counts.get(''.join(b if j==i else '0' for j,b in enumerate(bits)),0)==0 for i2 in range(5) if i2!=i) for bits in counts for i in range(5) if all(b in ('0','1') for b in bits)) for i in range(5)) \n            and any(any(bits[4-i] == '0' for bits in counts) and any(bits[4-i] == '1' for bits in counts) for i in range(5)))\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (any(all(bit == b for bitstring in counts for b in [bitstring[2]]) for b in \"01\") or any(all(bit == b for bitstring in counts for b in [bitstring[1]]) for b in \"01\")) and (any(any(bitstring[q] != bitstring2[q] for bitstring in counts for bitstring2 in counts if bitstring != bitstring2) for q in [0,3,4]))\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (\n        # Check for at least one classical qubit\n        any(\n            all(key[i] == val for key in counts)\n            for i in range(5)\n            for val in ['0', '1']\n        )\n        and\n        # Check for at least one superposed qubit\n        any(\n            any(key[i] == '0' for key in counts) and any(key[i] == '1' for key in counts)\n            for i in range(5)\n        )\n    )\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (\n        any(\n            all(bit == v for bit in [key[::-1][1], key[::-1][2]])\n            for key in counts\n            for v in ('0', '1')\n        ) and (\n            any(\n                (key[::-1][0] == '0') for key in counts\n            ) and any(\n                (key[::-1][0] == '1') for key in counts\n            )\n        )\n    )\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    bits = list(counts.keys())\n    n = 5\n    classical_found = False\n    superposed_found = False\n    for i in range(n):\n        outcomes = set(b[n - 1 - i] for b in bits if counts[b] > 0)\n        if len(outcomes) == 1:\n            classical_found = True\n        if len(outcomes) == 2:\n            superposed_found = True\n    assert classical_found and superposed_found\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    bits = list(counts.keys())[0][::-1]\n    n_shots = sum(counts.values())\n    classical_qubits = []\n    superposed_qubits = []\n    for i in range(5):\n        vals = set()\n        for key in counts.keys():\n            vals.add(key[::-1][i])\n        if len(vals) == 1:\n            classical_qubits.append(i)\n        elif len(vals) > 1:\n            superposed_qubits.append(i)\n    assert len(classical_qubits) >= 1 and len(superposed_qubits) >= 1\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (\n        (\n            all(all(bit == '1' for bit in key[-2]) for key in counts) or\n            all(all(bit == '0' for bit in key[-3]) for key in counts) or\n            all(all(bit == '1' for bit in key[-4]) for key in counts) or\n            all(all(bit == '0' for bit in key[-4]) for key in counts)\n        )\n        and\n        (\n            any(any(bit == '0' for bit in key[-1]) for key in counts) and\n            any(any(bit == '1' for bit in key[-1]) for key in counts)\n            or\n            any(any(bit == '0' for bit in key[-3]) for key in counts) and\n            any(any(bit == '1' for bit in key[-3]) for key in counts)\n            or\n            any(any(bit == '0' for bit in key[-2]) for key in counts) and\n            any(any(bit == '1' for bit in key[-2]) for key in counts)\n            or\n            any(any(bit == '0' for bit in key[-4]) for key in counts) and\n            any(any(bit == '1' for bit in key[-4]) for key in counts)\n        )\n    )\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (all(all(k[-2] == '1' for k in counts) or all(k[-3] == '0' for k in counts)) \n            and any(any(k[i] == '0' for k in counts) and any(k[i] == '1' for k in counts) for i in range(5)))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (\n        (\n            all(bit[3] == '1' for bit in counts) or  # qubit 1 always 1\n            all(bit[2] == '0' for bit in counts)     # qubit 2 always 0\n        )\n        and\n        (\n            any(bit[4] == '0' for bit in counts) and any(bit[4] == '1' for bit in counts)  # qubit 0 superposed\n            or\n            any(bit[1] == '0' for bit in counts) and any(bit[1] == '1' for bit in counts)  # qubit 3 superposed\n            or\n            any(bit[0] == '0' for bit in counts) and any(bit[0] == '1' for bit in counts)  # qubit 4 superposed\n        )\n    )\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (\n        (\n            all(all(bit[1] == '1' for bit in counts) or all(bit[2] == '0' for bit in counts))\n        )\n        and\n        (\n            any(any(bit[0] == '0' for bit in counts) and any(bit[0] == '1' for bit in counts))\n        )\n    ), \"At least one qubit must be always classical and at least one must be superposed\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (\n        # At least one classical qubit (qubit 1 or 2)\n        all(key[3] == '1' for key in counts) or all(key[2] == '0' for key in counts)\n    ) and (\n        # At least one superposed qubit (qubit 0, 3, or 4)\n        any(len(set(key[i] for key in counts)) > 1 for i in [4,1,0])\n    )\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (\n        any(\n            all(bit == '0' for bit in key[i] for key in counts) or\n            all(bit == '1' for bit in key[i] for key in counts)\n            for i in range(5)\n        )\n        and\n        any(\n            any(bit == '0' for bit in key[i] for key in counts)\n            and\n            any(bit == '1' for bit in key[i] for key in counts)\n            for i in range(5)\n        )\n    )\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (\n        any(\n            all(all(bit == b for bit in [key[4], key[3], key[2], key[1], key[0]][i] for key in counts)\n                for b in ['0', '1'])\n            for i in range(5)\n        )\n        and\n        any(\n            any(key[i] == '0' for key in counts) and any(key[i] == '1' for key in counts)\n            for i in range(5)\n        )\n    )\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (all(k[3] == '1' for k in counts) or all(k[2] == '0' for k in counts)) and (any(k[4] != k[4][0] for k in counts) or any(k[3] != k[3][0] for k in counts) or any(k[0] != k[0][0] for k in counts)), \"At least one qubit should be classical and at least one in superposition\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (all(outcome[1] == '1' for outcome in counts) or all(outcome[2] == '0' for outcome in counts)) and (any(outcome[0] == '0' for outcome in counts) and any(outcome[0] == '1' for outcome in counts))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (\n        (\n            any(all(bits[i] == '0' for bits in [k for k in counts]) or all(bits[i] == '1' for bits in [k for k in counts]) for i in range(5)) and\n            any(any(bits[i] == '0' for bits in [k for k in counts]) and any(bits[i] == '1' for bits in [k for k in counts]) for i in range(5))\n        )\n    )\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (all(all(bit == outcome[3] for outcome in counts) for bit in ['0', '1']) or all(all(bit == outcome[2] for outcome in counts) for bit in ['0', '1']) or all(all(bit == outcome[1] for outcome in counts) for bit in ['0', '1'])) and (any(any(outcome[i] != outcome[0] for outcome in counts) or any(outcome[0] != outcome[0] for outcome in counts) for i in range(1,5)))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert any(all(k[i]=='0' or k[i]=='1' for k in counts) for i in range(5)) and any(any(k[i]=='0' for k in counts) and any(k[i]=='1' for k in counts) for i in range(5))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (\n        (all(bit in {'0'} for bit in {key[2] for key in counts.keys()}) or all(bit in {'1'} for bit in {key[1] for key in counts.keys()}))\n        and\n        (any(len({key[i] for key in counts.keys()}) > 1 for i in range(5)))\n    )\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    bitstrings = list(counts.keys())\n    classical_1 = all(bits[3] == '0' for bits in bitstrings) and all(bits[4] == '0' for bits in bitstrings)\n    classical_2 = all(bits[1] == '1' for bits in bitstrings)\n    classical_3 = all(bits[2] == '0' for bits in bitstrings)\n    at_least_one_classical = classical_2 or classical_3\n    superposed_0 = any(bits[0] == '0' for bits in bitstrings) and any(bits[0] == '1' for bits in bitstrings)\n    superposed_3 = any(bits[3] == '0' for bits in bitstrings) and any(bits[3] == '1' for bits in bitstrings)\n    superposed_4 = any(bits[4] == '0' for bits in bitstrings) and any(bits[4] == '1' for bits in bitstrings)\n    at_least_one_superposed = superposed_0 or superposed_3 or superposed_4\n    assert at_least_one_classical and at_least_one_superposed\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (any(all(all(bit[i] == v for bit in [format(int(key), '05b') for key in counts]) for v in ('0','1')) for i in range(5)) == False) and (any(len(set(bit[i] for bit in [format(int(key), '05b') for key in counts])) == 2 for i in range(5)) and any(len(set(bit[i] for bit in [format(int(key), '05b') for key in counts])) == 1 for i in range(5)))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (any(all(bit in {'0', '1'} for bit in set([key[i] for key in counts.keys()])) and len(set([key[i] for key in counts.keys()])) == 1 for i in range(5)) and any(len(set([key[i] for key in counts.keys()])) == 2 for i in range(5)))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (all(k[3] == '1' for k in counts) or all(k[2] == '0' for k in counts)) and (any(k[4] == '0' for k in counts) and any(k[4] == '1' for k in counts) or any(k[3] == '0' for k in counts) and any(k[3] == '1' for k in counts) or any(k[0] == '0' for k in counts) and any(k[0] == '1' for k in counts))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (any(all(k[4-i] == v for k in counts) for i,v in [(1,'1'),(2,'0')])) and any(0 < sum(int(k[4-i]) for k in counts) < len(counts) for i in [0,3,4])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (\n        (\n            all(all(bit == '1' for bit in k[3]) for k in counts.keys())\n            or all(all(bit == '0' for bit in k[3]) for k in counts.keys())\n            or all(all(bit == '1' for bit in k[2]) for k in counts.keys())\n            or all(all(bit == '0' for bit in k[2]) for k in counts.keys())\n        ) and (\n            any(any(bit == '0' for bit in k[0]) for k in counts.keys())\n            and any(any(bit == '1' for bit in k[0]) for k in counts.keys())\n            or any(any(bit == '0' for bit in k[4]) for k in counts.keys())\n            and any(any(bit == '1' for bit in k[4]) for k in counts.keys())\n            or any(any(bit == '0' for bit in k[3]) for k in counts.keys())\n            and any(any(bit == '1' for bit in k[3]) for k in counts.keys())\n        )\n    )\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (\n        (\n            all(all(bit[1] == '1' for bit in counts) or all(bit[2] == '0' for bit in counts))\n        )\n        and\n        (\n            any(\n                len(set(bit[i] for bit in counts)) > 1\n                for i in range(5)\n            )\n        )\n    )\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    classical = any(all(bits[i] == val for bits in [format(int(key, 2), f'0{5}b') for key in counts.keys()]) for i in range(5) for val in ('0', '1'))\n    superposed = any(any(bits[i] == '0' for bits in [format(int(key, 2), f'0{5}b') for key in counts.keys()]) and any(bits[i] == '1' for bits in [format(int(key, 2), f'0{5}b') for key in counts.keys()]) for i in range(5))\n    assert classical and superposed\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    bitstrings = list(counts.keys())\n    measured_bits = [ [int(bit) for bit in bs[::-1]] for bs in bitstrings ]\n    n = 5\n    classical = [all(bits[q]==bits[0][q] for bits in measured_bits) for q in range(n)]\n    superposed = [any(bits[q]!=measured_bits[0][q] for bits in measured_bits) for q in range(n)]\n    assert any(classical) and any(superposed)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (\n        (\n            all(bit in {'0'} for bit in set(result[3] for result in counts))\n            or all(bit in {'1'} for bit in set(result[4] for result in counts))\n            or all(bit in {'0'} for bit in set(result[2] for result in counts))\n            or all(bit in {'1'} for bit in set(result[1] for result in counts))\n        )\n        and (\n            any(\n                len(set(result[i] for result in counts)) == 2\n                for i in range(5)\n            )\n        )\n    )\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (\n        any(all(key[4-i] in {'0','1'} and all(counts[k] == sum(v for j,v in counts.items() if j[4-i]==key[4-i]) for k in counts if k[4-i]!=key[4-i]) for key in counts) for i in [1,2])\n        and\n        any(any(key[4-i]=='0' for key in counts) and any(key[4-i]=='1' for key in counts) for i in [0,3,4])\n    )\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (all(all(bit[3] == bitstring[3] for bitstring in counts) or all(bit[2] == bitstring[2] for bitstring in counts) or all(bit[1] == bitstring[1] for bitstring in counts)) and (any(len(set(bitstring[4] for bitstring in counts)) > 1 for bit in [0,4]) or any(len(set(bitstring[0] for bitstring in counts)) > 1 for bit in [0,4])))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    measured_0 = set()\n    measured_1 = set()\n    for bitstring, count in counts.items():\n        for i, bit in enumerate(bitstring[::-1]):\n            if bit == '0':\n                measured_0.add(i)\n            if bit == '1':\n                measured_1.add(i)\n    classical_qubit_exists = any(\n        (i in measured_0 and i not in measured_1) or (i in measured_1 and i not in measured_0)\n        for i in range(5)\n    )\n    superposed_qubit_exists = any(\n        (i in measured_0 and i in measured_1)\n        for i in range(5)\n    )\n    assert classical_qubit_exists and superposed_qubit_exists\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (all(bit in {'0'} for bit in {key[-3] for key in counts}) or all(bit in {'1'} for bit in {key[-2] for key in counts})) and (any(len({key[-i] for key in counts}) > 1 for i in [1, 2, 3, 4, 5]))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (any(all(k[4-i] in '01' for k in counts if k[4-i] == '0' or k[4-i] == '1' and all(k[4-i] == '0' for k in counts) or all(k[4-i] == '1' for k in counts)) for i in range(5)) \n            and any(any(k[4-i] == '0' for k in counts) and any(k[4-i] == '1' for k in counts) for i in range(5)))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n# >>> ASSERTION START\nassert any(all(bit in {'0'} or bit in {'1'} for bit in [bits[i] for bits in counts for i in range(5)]) for i in [1,2]) and any(len(set(bits[i] for bits in counts)) > 1 for i in range(5))\n# <<< ASSERTION END"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert any(all(bit == v for bit in [k[-2], k[-3]]) for k in counts for v in ['0','1']) and any(any(bit != v for bit in [k[-1], k[-4], k[-5]]) for k in counts for v in ['0','1'])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    # Qubit indices: [q4 q3 q2 q1 q0]\n    qubit_counts = [set(), set(), set(), set(), set()]\n    for bitstring, count in counts.items():\n        for i, bit in enumerate(bitstring[::-1]):\n            qubit_counts[i].add(bit)\n    at_least_one_classical = any(len(bits) == 1 for bits in qubit_counts)\n    at_least_one_superposed = any(len(bits) == 2 for bits in qubit_counts)\n    assert at_least_one_classical and at_least_one_superposed, \"Circuit must have at least one classical and one superposed qubit\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (all(k[3] == '1' for k in counts) or all(k[2] == '0' for k in counts)) and any(len(set(k[i] for k in counts)) > 1 for i in [0,3,4])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (\n        any(all(bit == v for bit in [key[4], key[3], key[2], key[1], key[0]][i] for key in counts) for i in range(5) for v in '01')\n        and\n        any(\n            0 < sum(key[4 - j] == '0' for key in counts) < len(counts) and\n            0 < sum(key[4 - j] == '1' for key in counts) < len(counts)\n            for j in range(5)\n        )\n    )\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (all(all(bit == '0' for bit in key[::-1][2:3]) for key in counts) or all(all(bit == '1' for bit in key[::-1][1:2]) for key in counts)) and any(any(key[::-1][i] != key[::-1][i][0] for key in counts) or (len(set(key[::-1][i] for key in counts)) > 1) for i in [0,3,4])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert any(all(bit == '1' for bit in key[-2]) or all(bit == '0' for bit in key[-3]) for key in counts) and any(key[-1] != key[-2] or key[-1] != key[-3] for key in counts)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n    # >>> ASSERTION START\n    assert (all(all(bit == '0' for bit in key[2]) for key in counts) or all(all(bit == '1' for bit in key[1]) for key in counts)) and (any(any(bit != key[0] for bit in key[0]) for key in counts) or any(any(bit != key[3] for bit in key[3]) for key in counts) or any(any(bit != key[4] for bit in key[4]) for key in counts))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n# >>> ASSERTION START\nassert any(all(key[i] == v for key in counts for v in \"01\") for i in range(5)) and any(any(key[i] == \"0\" for key in counts) and any(key[i] == \"1\" for key in counts) for i in range(5))\n# <<< ASSERTION END"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (\n        (all(all(bits[2] == b for bits in counts for b in ['0', '1']) or all(bits[1] == b for bits in counts for b in ['0', '1']))\n        and (any(any(bits[q] == '0' for bits in counts) and any(bits[q] == '1' for bits in counts) for q in [0,3,4]))\n    ), \"At least one qubit must be classical and at least one must be in superposition\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (\n        any(\n            all(bit == val for bit in [key[-2], key[-3]])  # qubit 2 and 1 classical\n            for val in ['0', '1']\n            for key in counts\n        )\n        and (\n            any(\n                key[-1] != key2[-1] or key[-4] != key2[-4]  # qubit 0 or 3 superposed\n                for key in counts\n                for key2 in counts\n                if key != key2\n            )\n        )\n    )\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (all(int(key[3]) == 1 for key in counts) or all(int(key[2]) == 0 for key in counts)) and (any(int(key[4]) == 1 for key in counts) and any(int(key[4]) == 0 for key in counts))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB01",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert (any(all(all(bit == v for bit in [key[4-i] for key in counts.keys()]) for v in '01') for i in range(5)) and any(any('0' in [key[4-i] for key in counts.keys()] and '1' in [key[4-i] for key in counts.keys()]) for i in range(5)))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(v > 0 for v in counts.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and counts.get('00', 0) > 400 and counts.get('11', 0) > 400\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and counts.get('00',0) > 400 and counts.get('11',0) > 400\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(counts.get(state, 0) > 0 for state in ['00', '11'])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {\"00\", \"11\"} and all(counts.get(key, 0) > 0 for key in (\"00\", \"11\"))\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(counts.get(k,0) > 0 for k in ['00', '11']), \"Qubits are not entangled in a Bell state.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert set(counts.keys()).issubset({'00', '11'}) and sum(counts.get(x, 0) for x in ('00','11')) == 1024\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(counts.get(k,0) > 0 for k in ('00', '11')), \"Qubits are not entangled in a Bell state\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(count > 0 for count in counts.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(counts.get(k, 0) > 0 for k in ['00','11']), \"Qubits are not entangled in a Bell state\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and abs(counts.get('00',0) - counts.get('11',0)) < 0.2 * 1024\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(counts.get(k, 0) > 0 for k in ['00', '11']) and sum(counts.get(k, 0) for k in ['00', '11']) == sum(counts.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert set(counts.keys()).issubset({'00', '11'}) and sum(counts.get(key, 0) for key in ['00', '11']) > 900\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and counts.get('00', 0) > 400 and counts.get('11', 0) > 400\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {\"00\", \"11\"} and abs(counts.get(\"00\", 0) - counts.get(\"11\", 0)) < 0.2 * 1024\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(counts.get(k,0) > 0 for k in ['00','11'])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {\"00\", \"11\"} and abs(counts.get(\"00\", 0) - counts.get(\"11\", 0)) < 0.2 * 1024\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(counts.get(k, 0) > 0 for k in ['00', '11'])\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {\"00\", \"11\"} and all(v > 0 for v in [counts.get(\"00\", 0), counts.get(\"11\", 0)]), \"Qubits are not entangled in a Bell state\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and sum(counts.get(x, 0) for x in ('00', '11')) == 1024\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and abs(counts.get('00',0) - counts.get('11',0)) < 0.2 * sum(counts.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(counts.get(k, 0) > 0 for k in ['00', '11'])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and abs(counts.get('00',0) - counts.get('11',0)) < 0.2 * 1024\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()).issubset({'00', '11'}) and sum(counts.get(s, 0) for s in ('00','11')) > 0.9 * sum(counts.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {\"00\", \"11\"} and all(counts[k] > 0 for k in [\"00\", \"11\"])\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(v > 0 for v in counts.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(v > 0 for v in counts.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'}, \"Qubits are not in a Bell state (|00⟩ + |11⟩)/√2\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(abs(counts.get('00', 0) - counts.get('11', 0)) / 1024 < 0.2 for _ in [0])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert all(k in counts for k in ['00','11']) and all(k not in counts or counts[k] > 0 for k in ['00','11']) and all(k not in ['00','11'] or counts[k] == 0 for k in counts if k not in ['00','11'])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {\"00\", \"11\"} and all(counts.get(k,0) > 0 for k in (\"00\",\"11\"))\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(counts[k] > 0 for k in ['00','11']), \"Qubits are not in a Bell state\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(abs(counts.get(k,0) - 512) < 150 for k in ['00','11']), \"Qubits are not in a Bell state\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and abs(counts.get('00',0) - counts.get('11',0)) < 0.2 * sum(counts.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {\"00\", \"11\"} and all(c > 400 for c in counts.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(counts.get(k, 0) > 0 for k in ['00', '11'])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert all(k in ['00', '11'] for k in counts) and len(counts) == 2\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(counts.get(k, 0) > 0 for k in ['00', '11'])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and abs(counts.get('00', 0) - counts.get('11', 0)) < 0.2 * 1024\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(counts.get(k, 0) > 0 for k in ['00', '11'])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {\"00\", \"11\"} and all(v > 0 for v in counts.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and abs(counts.get('00', 0) - counts.get('11', 0)) < 0.2 * 1024\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(abs(counts.get('00',0) - counts.get('11',0)) < 0.2 * 1024 for _ in range(1)), \"The output is not a Bell state\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(counts.get(k, 0) > 0 for k in ['00', '11'])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(v > 400 for v in counts.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {\"00\", \"11\"} and all(v > 0 for v in [counts.get(\"00\", 0), counts.get(\"11\", 0)])\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and abs(counts.get('00',0) - counts.get('11',0)) < 0.2 * 1024\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n\n    # >>> ASSERTION START\n    assert all(key in counts for key in ['00', '11']) and not any(key in counts for key in ['01', '10'])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(c > 400 for c in counts.values()), \"Qubits are not in a Bell state\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB02",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n    # >>> ASSERTION START\n    assert set(counts.keys()) == {'00', '11'} and all(v > 0 for v in counts.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum(v for k, v in circuit.counts.items() if k[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0 = sum([v for k, v in circuit.counts.items() if k[-1] == '1']) / sum(circuit.counts.values())\n    assert abs(prob_q0 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    assert abs(\n        (sum([v for k, v in circuit.counts.items() if k[-1] == '1']) / sum(circuit.counts.values()))\n        - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0 = sum(count for bitstring, count in circuit.counts.items() if bitstring[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_q0 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    assert abs(\n        (sum([v for k, v in circuit.counts.items() if k[2] == '1']) / sum(circuit.counts.values())) - 0.7\n    ) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0 = sum(count for bitstr, count in circuit.counts.items() if bitstr[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_q0 - 0.7) < 0.1\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum(count for bitstring, count in circuit.counts.items() if bitstring[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n        # >>> ASSERTION START\n        prob_q0_1 = sum(c for k, c in self.counts.items() if k[-1] == '1') / shots\n        assert abs(prob_q0_1 - 0.7) < tolerance\n        # <<< ASSERTION END\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    q0_ones = sum(count for bitstr, count in circuit.counts.items() if bitstr[-1] == '1')\n    prob_q0_1 = q0_ones / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    measured_prob_q0 = sum([v for k, v in circuit.counts.items() if k[-1] == '1']) / sum(circuit.counts.values())\n    assert abs(measured_prob_q0 - 0.7) < 0.1, f\"Qubit q0 does not match initial q2 state: prob {measured_prob_q0}, expected 0.7\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        prob_q0_1 = sum(count for bitstring, count in self.counts.items() if bitstring[-1] == '1') / sum(self.counts.values())\n        assert abs(prob_q0_1 - 0.7) < tolerance, f\"Measured probability for q0={prob_q0_1}, expected ~0.7\"\n        # <<< ASSERTION END\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_one = sum([v for k, v in circuit.counts.items() if k[-1] == '1']) / sum(circuit.counts.values())\n    assert abs(prob_q0_one - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum([v for k, v in circuit.counts.items() if k[-1] == \"1\"]) / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        prob_q0_1 = sum(v for k, v in self.counts.items() if k[2] == '1') / shots\n        assert abs(prob_q0_1 - 0.7) < tolerance\n        # <<< ASSERTION END\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_1_q0 = sum(count for bitstr, count in circuit.counts.items() if bitstr[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_1_q0 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum(count for bitstr, count in circuit.counts.items() if bitstr[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0 = sum([v for k, v in circuit.counts.items() if k[-1] == '1']) / sum(circuit.counts.values())\n    assert abs(prob_q0 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum(count for bitstring, count in circuit.counts.items() if bitstring[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0 = sum(count for bitstr, count in circuit.counts.items() if bitstr[-1] == \"1\") / sum(circuit.counts.values())\n    assert abs(prob_q0 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        prob1_q0 = sum(count for bitstr, count in self.counts.items() if bitstr[-1] == \"1\") / shots\n        assert abs(prob1_q0 - 0.7) < tolerance\n        # <<< ASSERTION END\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum(count for bitstring, count in circuit.counts.items() if bitstring[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum(v for k, v in circuit.counts.items() if k[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1, \"q0 does not match initial state of q2\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum(v for k, v in circuit.counts.items() if k[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    measured_prob_q0 = sum(count for bitstring, count in circuit.counts.items() if bitstring[-1] == \"1\") / sum(circuit.counts.values())\n    assert abs(measured_prob_q0 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        prob_q0_1 = sum(v for k, v in self.counts.items() if k[-1] == '1') / shots\n        assert abs(prob_q0_1 - 0.7) < tolerance\n        # <<< ASSERTION END\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        prob_q0_1 = sum(count for bitstr, count in self.counts.items() if bitstr[-1] == \"1\") / shots\n        assert abs(prob_q0_1 - 0.7) < tolerance, f\"q0 probability {prob_q0_1} does not match expected 0.7\"\n        # <<< ASSERTION END\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0 = sum(v for k, v in circuit.counts.items() if k[-1] == \"1\") / sum(circuit.counts.values())\n    assert abs(prob_q0 - 0.7) < 0.1\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0 = sum(count for bit, count in circuit.counts.items() if bit[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_q0 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum([v for k, v in circuit.counts.items() if k[-1] == '1']) / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0 = sum([v for k, v in circuit.counts.items() if k[-1] == '1']) / sum(circuit.counts.values())\n    assert abs(prob_q0 - 0.7) < 0.1\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    shots = sum(circuit.counts.values())\n    q0_ones = sum(count for bitstr, count in circuit.counts.items() if bitstr[-1] == '1')\n    measured_prob_q0 = q0_ones / shots\n    assert abs(measured_prob_q0 - 0.7) < 0.1, f\"q0 measured probability {measured_prob_q0} differs from initial q2 state\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum(count for bitstring, count in circuit.counts.items() if bitstring[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_1_q0 = sum(count for bitstr, count in circuit.counts.items() if bitstr[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_1_q0 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        prob_1_q0 = sum([v for k, v in self.counts.items() if k[-1] == '1']) / shots\n        assert abs(prob_1_q0 - 0.7) < tolerance, f\"Qubit q0 state does not match initial state of q2: {prob_1_q0} vs 0.7\"\n        # <<< ASSERTION END\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum([v for k, v in circuit.counts.items() if k[-1] == '1']) / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum(count for bitstring, count in circuit.counts.items() if bitstring[-1] == \"1\") / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum([v for k, v in circuit.counts.items() if k[-1] == '1']) / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0 = sum([v for k, v in circuit.counts.items() if k[-1] == '1']) / sum(circuit.counts.values())\n    assert abs(prob_q0 - 0.7) < 0.1\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum([v for k, v in circuit.counts.items() if k[-1] == '1']) / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum([v for k, v in circuit.counts.items() if k[-1] == '1']) / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum(count for bitstr, count in circuit.counts.items() if bitstr[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum([v for k, v in circuit.counts.items() if k[-1] == '1']) / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum(count for bit, count in circuit.counts.items() if bit[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1, f\"Qubit q0 final probability {prob_q0_1} deviates from q2's initial 0.7\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    prob_q0_1 = sum(count for bit, count in circuit.counts.items() if bit[-1] == '1') / sum(circuit.counts.values())\n    assert abs(prob_q0_1 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        prob_q0_1 = sum(v for k, v in self.counts.items() if k[-1] == '1') / shots\n        assert abs(prob_q0_1 - 0.7) < tolerance\n        # <<< ASSERTION END\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        prob_q0 = sum(count for bitstring, count in self.counts.items() if bitstring[-1] == '1') / shots\n        assert abs(prob_q0 - 0.7) < tolerance, f\"q0 probability {prob_q0} does not match initial q2 (~0.7)\"\n        # <<< ASSERTION END\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        prob_q0_1 = sum(v for k, v in self.counts.items() if k[-1] == '1') / shots\n        assert abs(prob_q0_1 - 0.7) < tolerance, f\"Qubit q0 probability {prob_q0_1} differs from expected 0.7\"\n        # <<< ASSERTION END\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    measured_prob_q0 = sum([v for k,v in circuit.counts.items() if k[-1]==\"1\"]) / sum(circuit.counts.values())\n    assert abs(measured_prob_q0 - 0.7) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n    # >>> ASSERTION START\n    measured_prob_q0 = sum([count for bitstring, count in circuit.counts.items() if bitstring[-1] == '1']) / sum(circuit.counts.values())\n    assert abs(measured_prob_q0 - 0.7) < 0.1, f\"Measured prob. of q0 being '1' ({measured_prob_q0}) does not match initial prob. of q2 (0.7)\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB03",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        measured_1_prob_q0 = sum(v for k, v in self.counts.items() if k[-1] == '1') / shots\n        assert abs(measured_1_prob_q0 - 0.7) < tolerance, f\"Qubit q0 final probability {measured_1_prob_q0} does not match initial q2 state\"\n        # <<< ASSERTION END\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/sum(output.values()) - 0.25) < 0.05 and abs(output.get('1',0)/sum(output.values()) - 0.75) < 0.05\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0', 0)/circuit_runner.shots - 0.25) < 0.05 and abs(output.get('1', 0)/circuit_runner.shots - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    p0_expected = np.cos(np.pi/3)**2\n    p1_expected = 1 - p0_expected\n    n_shots = sum(output.values())\n    observed_p0 = output.get('0', 0) / n_shots\n    observed_p1 = output.get('1', 0) / n_shots\n    assert np.isclose(observed_p0, p0_expected, atol=0.05) and np.isclose(observed_p1, p1_expected, atol=0.05)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/circuit_runner.shots - 0.25) < 0.1 and abs(output.get('1',0)/circuit_runner.shots - 0.75) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/(output.get('0',0)+output.get('1',0)) - 0.25) < 0.06 and abs(output.get('1',0)/(output.get('0',0)+output.get('1',0)) - 0.75) < 0.06\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/(output.get('0',0)+output.get('1',0)) - 0.25) < 0.05 and abs(output.get('1',0)/(output.get('0',0)+output.get('1',0)) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    prob_0 = output.get('0', 0) / sum(output.values())\n    prob_1 = output.get('1', 0) / sum(output.values())\n    assert np.isclose(prob_0, 0.25, atol=0.05) and np.isclose(prob_1, 0.75, atol=0.05)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/sum(output.values()) - 0.25) < 0.1 and abs(output.get('1',0)/sum(output.values()) - 0.75) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/sum(output.values()) - 0.25) < 0.05 and abs(output.get('1',0)/sum(output.values()) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    p0_expected = np.cos(np.pi/3)**2\n    p1_expected = np.sin(np.pi/3)**2\n    total = sum(output.get(k,0) for k in ['0','1'])\n    p0_obs = output.get('0',0) / total\n    p1_obs = output.get('1',0) / total\n    assert abs(p0_obs - p0_expected) < 0.05 and abs(p1_obs - p1_expected) < 0.05, \"Observed measurement probabilities deviate from expected values\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('1',0)/circuit_runner.shots - 0.75) < 0.05 and abs(output.get('0',0)/circuit_runner.shots - 0.25) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0', 0) / sum(output.values()) - 0.25) < 0.05 and abs(output.get('1', 0) / sum(output.values()) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/sum(output.values()) - 0.25) < 0.07 and abs(output.get('1',0)/sum(output.values()) - 0.75) < 0.07\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/1024 - 0.25) < 0.08 and abs(output.get('1',0)/1024 - 0.75) < 0.08\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/(output.get('0',0)+output.get('1',0)) - 0.25) < 0.05 and abs(output.get('1',0)/(output.get('0',0)+output.get('1',0)) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/sum(output.values()) - 0.25) < 0.05 and abs(output.get('1',0)/sum(output.values()) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0', 0)/circuit_runner.shots - 0.25) < 0.1 and abs(output.get('1', 0)/circuit_runner.shots - 0.75) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/(output.get('0',0)+output.get('1',0)) - 0.25) < 0.05 and abs(output.get('1',0)/(output.get('0',0)+output.get('1',0)) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0', 0)/sum(output.values()) - 0.25) < 0.07 and abs(output.get('1', 0)/sum(output.values()) - 0.75) < 0.07\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/sum(output.values()) - 0.25) < 0.05 and abs(output.get('1',0)/sum(output.values()) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    prob_0 = output.get('0', 0) / circuit_runner.shots\n    prob_1 = output.get('1', 0) / circuit_runner.shots\n    expected_prob_0 = np.cos(np.pi/3)**2\n    expected_prob_1 = np.sin(np.pi/3)**2\n    assert abs(prob_0 - expected_prob_0) < 0.05 and abs(prob_1 - expected_prob_1) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs((output.get('0',0)/sum(output.values())) - 0.25) < 0.07 and abs((output.get('1',0)/sum(output.values())) - 0.75) < 0.07\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/sum(output.values()) - 0.25) < 0.05 and abs(output.get('1',0)/sum(output.values()) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('1',0)/circuit_runner.shots - 0.75) < 0.05 and abs(output.get('0',0)/circuit_runner.shots - 0.25) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    total = sum(output.values())\n    p0 = np.cos(np.pi/3)**2\n    p1 = np.sin(np.pi/3)**2\n    observed_p0 = output.get('0', 0) / total\n    observed_p1 = output.get('1', 0) / total\n    assert abs(observed_p0 - p0) < 0.05 and abs(observed_p1 - p1) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs((output.get('0',0)/sum(output.values())) - 0.25) < 0.05 and abs((output.get('1',0)/sum(output.values())) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/sum(output.values()) - 0.25) < 0.07 and abs(output.get('1',0)/sum(output.values()) - 0.75) < 0.07\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    p0 = np.cos(np.pi/3)**2\n    p1 = np.sin(np.pi/3)**2\n    shots = circuit_runner.shots\n    observed_p0 = output.get('0',0)/shots\n    observed_p1 = output.get('1',0)/shots\n    assert abs(observed_p0 - p0) < 0.05 and abs(observed_p1 - p1) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0', 0)/circuit_runner.shots - 0.25) < 0.05 and abs(output.get('1', 0)/circuit_runner.shots - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/sum(output.values()) - 0.25) < 0.05 and abs(output.get('1',0)/sum(output.values()) - 0.75) < 0.05\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    shots = sum(output.values())\n    expected_prob_0 = np.cos(np.pi/3)**2\n    expected_prob_1 = np.sin(np.pi/3)**2\n    count_0 = output.get('0', 0)\n    count_1 = output.get('1', 0)\n    observed_prob_0 = count_0 / shots\n    observed_prob_1 = count_1 / shots\n    assert abs(observed_prob_0 - expected_prob_0) < 0.05 and abs(observed_prob_1 - expected_prob_1) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/sum(output.values()) - 0.25) < 0.05 and abs(output.get('1',0)/sum(output.values()) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs((output.get('0', 0) / sum(output.values())) - 0.25) < 0.05 and abs((output.get('1', 0) / sum(output.values())) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs((output.get('0',0)/sum(output.values())) - (0.25)) < 0.07 and abs((output.get('1',0)/sum(output.values())) - (0.75)) < 0.07\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/sum(output.values()) - 0.25) < 0.05 and abs(output.get('1',0)/sum(output.values()) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/circuit_runner.shots - 0.25) < 0.1 and abs(output.get('1',0)/circuit_runner.shots - 0.75) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs((output.get('0',0)/sum(output.values())) - 0.25) < 0.05 and abs((output.get('1',0)/sum(output.values())) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/circuit_runner.shots - 0.25) < 0.08 and abs(output.get('1',0)/circuit_runner.shots - 0.75) < 0.08, \"Measurement statistics do not match expected probabilities\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs((output.get('0', 0) / sum(output.values())) - 0.25) < 0.05 and abs((output.get('1', 0) / sum(output.values())) - 0.75) < 0.05\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0', 0) / circuit_runner.shots - 0.25) < 0.07 and abs(output.get('1', 0) / circuit_runner.shots - 0.75) < 0.07\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/sum(output.values()) - 0.25) < 0.05 and abs(output.get('1',0)/sum(output.values()) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/(output.get('0',0)+output.get('1',0)) - 0.25) < 0.05\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/(output.get('0',0)+output.get('1',0)) - 0.25) < 0.05 and abs(output.get('1',0)/(output.get('0',0)+output.get('1',0)) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('1',0)/(output.get('0',0)+output.get('1',0)) - np.sin(np.pi/3)**2) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0', 0)/circuit_runner.shots - 0.25) < 0.05 and abs(output.get('1', 0)/circuit_runner.shots - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs((output.get('0', 0)/sum(output.values())) - 0.25) < 0.05 and abs((output.get('1', 0)/sum(output.values())) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/sum(output.values()) - 0.25) < 0.07 and abs(output.get('1',0)/sum(output.values()) - 0.75) < 0.07\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/sum(output.values()) - 0.25) < 0.05 and abs(output.get('1',0)/sum(output.values()) - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0', 0)/circuit_runner.shots - 0.25) < 0.05 and abs(output.get('1', 0)/circuit_runner.shots - 0.75) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB04",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0', 0)/circuit_runner.shots - 0.25) < 0.07 and abs(output.get('1', 0)/circuit_runner.shots - 0.75) < 0.07\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(0.15 < output.get(bit, 0)/circuit_runner.shots < 0.85 for bit in ['0', '1'])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.18 < output.get('0',0)/circuit_runner.shots < 0.28 and 0.72 < output.get('1',0)/circuit_runner.shots < 0.82\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.70 < output.get('0',0)/circuit_runner.shots < 0.78\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.17 < (output.get('0', 0) / circuit_runner.shots) < 0.33\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.6 < output.get('0', 0) / circuit_runner.shots < 0.8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.55 < (output.get('0', 0) / circuit_runner.shots) < 0.65\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 350 < output.get(\"0\",0) < 750 and 350 < output.get(\"1\",0) < 750\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.72 < output.get('0',0)/circuit_runner.shots < 0.8 and 0.2 < output.get('1',0)/circuit_runner.shots < 0.28\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.70 < output.get('0',0)/circuit_runner.shots < 0.80 and 0.20 < output.get('1',0)/circuit_runner.shots < 0.30\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs((output.get('0',0)/sum(output.values())) - (0.25)) < 0.08\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.71 < (output.get('0',0)/(circuit_runner.shots)) < 0.73\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.70 <= (output.get('0',0)/circuit_runner.shots) <= 0.80\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/sum(output.values()) - 0.066987298) < 0.05\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/(circuit_runner.shots) - 0.067) < 0.05 and abs(output.get('1',0)/(circuit_runner.shots) - 0.933) < 0.05\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.35 < output.get('0', 0) / circuit_runner.shots < 0.55\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.68 < output.get('0',0)/circuit_runner.shots < 0.78 and 0.22 < output.get('1',0)/circuit_runner.shots < 0.32\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    p0 = (1 + np.sin(2 * np.pi / 3) * np.cos(np.pi/2)) / 2\n    measured_p0 = output.get('0', 0) / circuit_runner.shots\n    assert np.isclose(measured_p0, p0, atol=0.1)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0', 0) / circuit_runner.shots - 0.067) < 0.05 and abs(output.get('1', 0) / circuit_runner.shots - 0.933) < 0.05\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.70 < output.get(\"0\", 0) / circuit_runner.shots < 0.80\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs((output.get('0',0)/circuit_runner.shots) - 0.25) < 0.1 and abs((output.get('1',0)/circuit_runner.shots) - 0.75) < 0.1\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.6 < output.get('0',0)/circuit_runner.shots < 0.8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.36 < output.get('0', 0) / circuit_runner.shots < 0.38 and 0.62 < output.get('1', 0) / circuit_runner.shots < 0.64\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/circuit_runner.shots - 0.625) < 0.05 and abs(output.get('1',0)/circuit_runner.shots - 0.375) < 0.05\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0', 0) / circuit_runner.shots - 0.066987298) < 0.05 and abs(output.get('1', 0) / circuit_runner.shots - 0.933012701) < 0.05\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs((output.get('0', 0) / circuit_runner.shots) - 0.125) < 0.05 and abs((output.get('1', 0) / circuit_runner.shots) - 0.875) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.6 < output.get('0', 0)/circuit_runner.shots < 0.8 and 0.2 < output.get('1', 0)/circuit_runner.shots < 0.4\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/(circuit_runner.shots) - 0.067) < 0.05 and abs(output.get('1',0)/(circuit_runner.shots) - 0.933) < 0.05\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.65 < output.get('0',0)/circuit_runner.shots < 0.75\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.58 <= (output.get('0',0)/sum(output.values())) <= 0.62\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs((output.get('0',0)/circuit_runner.shots) - 0.067) < 0.05 and abs((output.get('1',0)/circuit_runner.shots) - 0.933) < 0.05\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0', 0)/circuit_runner.shots - 0.25) < 0.1\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0',0)/(circuit_runner.shots) - 0.066987298) < 0.05 and abs(output.get('1',0)/(circuit_runner.shots) - 0.933012701) < 0.05\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    prob_0 = output.get('0', 0) / circuit_runner.shots\n    prob_1 = output.get('1', 0) / circuit_runner.shots\n    expected_prob_0 = (np.cos(np.pi/2)**2)*((np.cos(2*np.pi/3/2))**2) + (np.sin(np.pi/2)**2)*((np.sin(2*np.pi/3/2))**2)\n    assert abs(prob_0 - expected_prob_0) < 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.60 <= output.get('0',0)/sum(output.values()) <= 0.80\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.65 < output.get('0',0)/(circuit_runner.shots) < 0.75\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.65 < (output.get('0',0)/circuit_runner.shots) < 0.85\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0', 0) / circuit_runner.shots - 0.067) < 0.05 and abs(output.get('1', 0) / circuit_runner.shots - 0.933) < 0.05\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs((output.get('0',0)/circuit_runner.shots) - 0.066987298) < 0.05 and abs((output.get('1',0)/circuit_runner.shots) - 0.933012701) < 0.05\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.23 < (output.get('0',0) / circuit_runner.shots) < 0.27\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.71 < output.get('0',0)/circuit_runner.shots < 0.81 and 0.19 < output.get('1',0)/circuit_runner.shots < 0.29\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.66 <= output.get('0', 0) / circuit_runner.shots <= 0.74\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 350 < output.get('0', 0) < 650 and 350 < output.get('1', 0) < 650\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.7 < output.get('0',0)/(output.get('0',0)+output.get('1',0)) < 0.8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    prob_1 = output.get('1', 0) / circuit_runner.shots\n    assert 0.67 < prob_1 < 0.77\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.65 < output.get('0', 0) / circuit_runner.shots < 0.75\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.82 <= output.get('0',0)/circuit_runner.shots <= 0.86\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.60 < output.get('0',0)/circuit_runner.shots < 0.75 and 0.25 < output.get('1',0)/circuit_runner.shots < 0.40\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.7 < output.get('0',0)/(output.get('0',0)+output.get('1',0)) < 0.85\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert 0.69 < output.get('0',0)/circuit_runner.shots < 0.73\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB05",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert abs(output.get('0', 0) / circuit_runner.shots - 0.067) < 0.07 and abs(output.get('1', 0) / circuit_runner.shots - 0.933) < 0.07\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.7 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert max(output.values()) >= 0.7 * sum(output.values()), \"No dominant basis state detected in the result distribution\"\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.7 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.4\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    counts_sorted = sorted(output.values(), reverse=True)\n    assert len(counts_sorted) > 1 and counts_sorted[0] > sum(counts_sorted[1:]), \"No dominant basis state found\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.7 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.7 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    max_count = max(output.values())\n    total = sum(output.values())\n    assert max_count / total > 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 2 * np.median(list(output.values()))\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB06",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) * 0.4\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.3 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.1 * circuit_runner.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(abs(count - circuit_runner.shots/8) < 0.1 * circuit_runner.shots/8 for count in output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * sum(output.values()) / len(output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(abs(output.get(bin(i)[2:].zfill(3), 0) - circuit_runner.shots/8) < circuit_runner.shots*0.1 for i in range(8))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * sum(output.values()) / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < circuit_runner.shots * 0.1\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(abs(output.get(format(i, '03b'), 0)/circuit_runner.shots - 1/8) < 0.08 for i in range(8))\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(abs(count - circuit_runner.shots / 8) < 0.1 * circuit_runner.shots / 8 for count in output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(abs(v - circuit_runner.shots/8) < 0.1 * circuit_runner.shots for v in output.values()) and len(output) == 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots // 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(abs(count - sum(output.values())/8) < 0.1 * sum(output.values())/8 for count in output.values()) and len(output) == 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(abs(count - circuit_runner.shots / 8) < 0.1 * circuit_runner.shots / 8 for count in output.values()), \"Distribution not uniform enough\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(abs(output.get(format(i, '03b'), 0) / circuit_runner.shots - 1/8) < 0.05 for i in range(8))\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(abs(count - circuit_runner.shots / 8) < 0.2 * circuit_runner.shots / 8 for count in output.values()) and len(output) == 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(abs(count - circuit_runner.shots/8) < 0.20 * circuit_runner.shots/8 for count in output.values()) and len(output) == 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * sum(output.values()) / len(output)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output.values()) - min(output.values()) < 0.2 * circuit_runner.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(abs(count - circuit_runner.shots/8) < 0.1 * circuit_runner.shots/8 for count in output.values()) and len(output) == 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB07",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(abs(output.get(format(i, '03b'), 0) / sum(output.values()) - 1/8) < 0.05 for i in range(8))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"000\", \"111\"})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"000\", \"111\"}\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output) <= {'000', '111'}\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"000\", \"111\"}\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"000\", \"111\"})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"000\", \"111\"})\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"000\", \"111\"})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"000\", \"111\"}\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"000\", \"111\"})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"000\", \"111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"000\", \"111\"})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"000\", \"111\"})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"000\", \"111\"})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"000\", \"111\"}\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"000\", \"111\"})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"000\", \"111\"}\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"000\", \"111\"})\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"000\", \"111\"}\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output) <= {\"000\", \"111\"}\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"000\", \"111\"}\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"000\", \"111\"})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"000\", \"111\"}\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"000\", \"111\"}\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"000\", \"111\"}\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"000\", \"111\"}\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"000\", \"111\"}\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"000\", \"111\"}\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"000\", \"111\"})\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {'000', '111'}\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"000\", \"111\"})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'000', '111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB08",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"000\", \"111\"}\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00',0) + output.get('11',0)) / sum(output.values()) > 0.95\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00',0) + output.get('11',0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00',0) + output.get('11',0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00',0) + output.get('11',0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00',0) + output.get('11',0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert sum(count for key, count in output.items() if key[0]==key[1]) / sum(output.values()) > 0.95\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00',0) + output.get('11',0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get(\"00\", 0) + output.get(\"11\", 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00',0) + output.get('11',0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert sum([output.get(bitstring, 0) for bitstring in ('00', '11')]) / sum(output.values()) > 0.95\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(k[0] == k[1] for k in output), \"Qubit measurements are not highly correlated\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get(\"00\", 0) + output.get(\"11\", 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00',0) + output.get('11',0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00',0) + output.get('11',0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    num_same = sum(v for k, v in output.items() if k[0] == k[1])\n    assert num_same / sum(output.values()) > 0.90\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get(\"00\", 0) + output.get(\"11\", 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.95\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00', 0) + output.get('11', 0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00',0) + output.get('11',0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00',0) + output.get('11',0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(b, 0) for b in [\"00\", \"11\"]) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB09",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert (output.get('00',0) + output.get('11',0)) / sum(output.values()) > 0.9\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"0000\", \"1111\"}\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"0000\", \"1111\"}\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()) <= {\"0000\", \"1111\"}\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000','1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({\"0000\", \"1111\"})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB10",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    # >>> ASSERTION START\n    assert set(output.keys()).issubset({'0000', '1111'})\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) == {\"1\"} and output[\"1\"] == circuit_runner.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'] or (len(output) == 1 and '1' in output and output['1'] == circuit_runner.shots)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Expected deterministic outcome '1' for balanced oracle f(x)=x\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'] or (len(output) == 1 and '1' in output), \"Expected deterministic outcome '1' for balanced oracle f(x) = x\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1']\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) == {\"1\"} and sum(output.values()) == circuit_runner.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Expected deterministic output '1' for balanced oracle f(x)=x\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1']\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) == {\"1\"} and sum(output.values()) == circuit_runner.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Expected output is '1' for a balanced oracle f(x)=x\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == [\"1\"]\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n# >>> ASSERTION START\nassert list(output.keys()) == [\"1\"]\n# <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) == {\"1\"} and output[\"1\"] == circuit_runner.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) == {'1'}\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1']\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == [\"1\"] or (len(output) == 1 and \"1\" in output), \"Expected deterministic output '1' for balanced oracle\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) == {\"1\"} and output[\"1\"] == circuit_runner.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Expected deterministic outcome '1' for balanced oracle\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1']\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1']\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Expected deterministic output '1' for balanced oracle f(x)=x\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == [\"1\"]\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == [\"1\"], \"Expected deterministic output '1' for balanced oracle f(x)=x\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Expected output to be deterministic '1' for balanced oracle f(x)=x\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) == {\"1\"}\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == [\"1\"], \"Deutsch algorithm output does not match the expected result for a balanced oracle.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) == {\"1\"}, \"Expected deterministic output '1' for balanced oracle\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == '1'\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) == {'1'}, \"Expected only '1' as output for balanced oracle\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Deutsch algorithm failed: Expected deterministic output '1' for balanced oracle f(x)=x\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == [\"1\"], \"Expected deterministic outcome '1' for balanced oracle\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Expected deterministic output '1' for balanced oracle f(x)=x\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Expected measurement outcome '1' for balanced oracle f(x) = x\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Expected deterministic outcome '1' for balanced oracle f(x)=x\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Deutsch algorithm: Expected deterministic output '1' for balanced oracle f(x) = x\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert set(output.keys()) == {\"1\"} and sum(output.values()) == circuit_runner.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Expected output to be '1' for balanced oracle\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1']\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == [\"1\"]\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == [\"1\"]\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == [\"1\"], \"The measurement outcome should be '1' for the balanced oracle f(x) = x\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == [\"1\"] or (len(output) == 1 and \"1\" in output), \"Expected deterministic outcome '1' for balanced oracle\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Expected output for balanced oracle is '1'\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Deutsch algorithm output does not match expected result for balanced oracle.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == [\"1\"]\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Expected deterministic output '1' for balanced oracle f(x)=x\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == [\"1\"]\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'] or (len(output) == 1 and '1' in output), \"Expected deterministic result '1' for Deutsch balanced oracle\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1']\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB11",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys()) == ['1'], \"Deutsch algorithm output does not match expected result for a balanced oracle\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1'), f\"Oracle type {oracle_type} inconsistent with output {output}\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (max(output, key=output.get) == '0') == (oracle_type == 0)\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert max(output, key=output.get) == str(1 - oracle_type), f\"Expected measurement {1-oracle_type} for oracle_type {oracle_type}, got {max(output, key=output.get)}\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert max(output, key=output.get) == str(1-oracle_type), f\"Oracle type {oracle_type}, got result {max(output, key=output.get)}\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (max(output, key=output.get) == '0') == (oracle_type == 0), \"Measurement outcome inconsistent with oracle type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and \"0\" in output and output.get(\"0\",0) >= 0.9 * circuit_runner.shots) or (oracle_type == 1 and \"1\" in output and output.get(\"1\",0) >= 0.9 * circuit_runner.shots), \"Measurement result does not match oracle type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (('0' in output) == (oracle_type == 0)) and (('1' in output) == (oracle_type == 1))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and '0' in output and output['0'] > 0) or (oracle_type == 1 and '1' in output and output['1'] > 0)\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and '0' in output and output['0'] == max(output.values())) or (oracle_type == 1 and '1' in output and output['1'] == max(output.values()))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and '0' in output and output['0'] > 0) or (oracle_type == 1 and '1' in output and output['1'] > 0)\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and '0' in output and output['0'] > 0 and (output.get('1',0) == 0)) or (oracle_type == 1 and '1' in output and output['1'] > 0 and (output.get('0',0) == 0)), f\"Inconsistent result: oracle_type={oracle_type}, counts={output}\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == \"0\") or (oracle_type == 1 and max(output, key=output.get) == \"1\"), \"Measurement does not match expected output for oracle type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (max(output, key=output.get) == str(oracle_type)), f\"Measurement does not match oracle_type: {output}\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert max(output, key=output.get) == str(1-oracle_type), f\"Observed {max(output, key=output.get)} for oracle_type={oracle_type}\"\n        # <<< ASSERTION END"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and '0' in output and output['0'] > 0) or (oracle_type == 1 and '1' in output and output['1'] > 0)\n        # <<< ASSERTION END"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and '0' in output and output['0'] == max(output.values())) or (oracle_type == 1 and '1' in output and output['1'] == max(output.values()))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and '0' in output and output['0'] > 0) or (oracle_type == 1 and '1' in output and output['1'] > 0)\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (('0' in output and oracle_type == 0) or ('1' in output and oracle_type == 1)), f\"Oracle type {oracle_type} produced inconsistent result: {output}\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and '0' in output and output['0'] == max(output.values())) or (oracle_type == 1 and '1' in output and output['1'] == max(output.values()))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == \"0\") or (oracle_type == 1 and max(output, key=output.get) == \"1\")\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and '0' in output and output['0'] > 0) or (oracle_type == 1 and '1' in output and output['1'] > 0)\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (max(output, key=output.get) == '0') == (oracle_type == 0)\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (max(output, key=output.get) == '0') == (oracle_type == 0)\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and '0' in output and output['0'] > 0) or (oracle_type == 1 and '1' in output and output['1'] > 0)\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1'), \"Measurement result does not match oracle type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and '0' in output and output['0'] > output.get('1', 0)) or (oracle_type == 1 and '1' in output and output['1'] > output.get('0', 0))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and \"0\" in output and output[\"0\"] == max(output.values())) or (oracle_type == 1 and \"1\" in output and output[\"1\"] == max(output.values()))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == \"0\") or (oracle_type == 1 and max(output, key=output.get) == \"1\")\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == \"0\") or (oracle_type == 1 and max(output, key=output.get) == \"1\"), \"Measured outcome does not match expected for the selected oracle type.\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and max(output, key=output.get) == '0') or (oracle_type == 1 and max(output, key=output.get) == '1')\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB12",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and '0' in output and output['0'] > 0) or (oracle_type == 1 and '1' in output and output['1'] > 0)\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(bitstr != '00' for bitstr in output), \"Expected at least one non-'00' outcome for a non-constant oracle\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(key != '00' and value > 0 for key, value in output.items()), \"Oracle appears constant: only '00' observed.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] < 0.1 * circuit_runner.shots\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] < 0.1 * circuit_runner.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] == 0\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert \"00\" not in output or output[\"00\"] < 0.05 * circuit_runner.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(key != \"00\" for key in output.keys())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] < 0.1 * circuit_runner.shots\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(key != '00' and output[key] > 0 for key in output), \"Oracle appears constant, but should be balanced.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(key != \"00\" for key in output), \"Oracle appears constant: only outcome '00' observed\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(bitstr != \"00\" and output.get(bitstr, 0) > 0 for bitstr in output), \"All measurement results are |00⟩, which would indicate a constant function.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert not ('00' in output and output['00'] == circuit_runner.shots), \"Oracle is constant but should be balanced\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert \"00\" not in output or output[\"00\"] < circuit_runner.shots // 2\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert not ('00' in output and output['00'] == circuit_runner.shots)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(key != \"00\" for key in output), \"Result suggests the oracle is constant, but it should be balanced\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert \"00\" not in output or output[\"00\"] < 0.1 * circuit_runner.shots\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert not ('00' in output and output['00'] == circuit_runner.shots)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert \"00\" not in output or output[\"00\"] < circuit_runner.shots * 0.1\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] < circuit_runner.shots * 0.2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] < 0.05 * circuit_runner.shots\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(key != \"00\" and output[key] > 0 for key in output), \"Oracle appears constant, but should be balanced\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] < 0.1 * circuit_runner.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(key != \"00\" and output[key] > 0 for key in output), \"Observed results are not consistent with a balanced (non-constant) oracle.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] < circuit_runner.shots * 0.1\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] < 0.1 * circuit_runner.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert not ('00' in output and output['00'] == circuit_runner.shots)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] == 0\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(k != '00' and v > 0 for k, v in output.items()), \"Oracle appears constant: only '00' measured.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] < 100, \"Oracle appears to be constant, but should be balanced.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(bitstring != \"00\" for bitstring in output), \"Oracle is constant, but should be balanced.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(key != \"00\" for key in output.keys()), \"Oracle appears constant, but should be balanced.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(key != \"00\" and val > 0 for key, val in output.items())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] < circuit_runner.shots * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert \"00\" not in output or output[\"00\"] < 0.10 * circuit_runner.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert \"00\" not in output or output[\"00\"] < 0.1 * circuit_runner.shots\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] < 0.1 * circuit_runner.shots\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert \"00\" not in output or output[\"00\"] < 0.1 * circuit_runner.shots\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert not (len(output) == 1 and '00' in output), \"Observed results are consistent with a constant function, which is incorrect for this oracle.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert \"00\" not in output or output[\"00\"] < 0.1 * circuit_runner.shots\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(key != '00' for key in output), \"Deutsch–Jozsa result is not consistent with a balanced oracle\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert \"00\" not in output or output[\"00\"] < 0.2 * circuit_runner.shots\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] == 0\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(key != \"00\" and val > 0 for key, val in output.items())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] < 0.05 * circuit_runner.shots\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(key != \"00\" and output[key] > 0 for key in output), \"Oracle should not be constant: output shows only '00'\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(key != \"00\" and val > 0 for key, val in output.items()), \"Output is consistent with a constant oracle, which is incorrect\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert any(bitstr != \"00\" for bitstr in output), \"Oracle should not be constant: all counts are for state '00'\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert not ('00' in output and output['00'] == circuit_runner.shots), \"Observed result is consistent with a constant oracle, but the oracle is not constant.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert not (\"00\" in output and sum(output.values()) == output[\"00\"]), \"Measurement results indicate a constant oracle (all shots are '00')\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB13",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert '00' not in output or output['00'] < 0.1 * circuit_runner.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {\"00\"}) or (oracle_type == 1 and all(key != \"00\" for key in output.keys()))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and set(output.keys()) == {'00'}) or (oracle_type == 1 and set(output.keys()) == {'01', '10', '11'})), \"Measurement results are inconsistent with the oracle_type.\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {\"00\"}) or (oracle_type == 1 and set(output.keys()) == {\"01\", \"10\", \"11\"})\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and all(key != '00' for key in output)), \"Measurement outcome and oracle_type are inconsistent\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and list(output.keys()) == [\"00\"]) or (oracle_type == 1 and all(k != \"00\" for k in output)))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {'00'}) or (oracle_type == 1 and '00' not in output)\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {'00'}) or (oracle_type == 1 and set(output.keys()) == {'01', '10', '11'})\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and all(key == '00' for key in output)) or (oracle_type == 1 and all(key != '00' for key in output))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and all(k != '00' for k in output.keys()))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {'00'}) or (oracle_type == 1 and set(output.keys()) == {'01', '10', '11'}), \"Measurement results do not match the oracle type\"\n        # <<< ASSERTION END"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and set(output.keys()) == {'01', '10', '11'})), f\"Inconsistent oracle_type {oracle_type} and measurement {output}\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and all(k != '00' for k in output)), \"Measurement results do not match expected Deutsch–Jozsa outcome for the given oracle_type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and all(k != '00' for k in output.keys()))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and all(k != '00' for k in output.keys()))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and set(output.keys()) == {\"00\"}) or (oracle_type == 1 and set(output.keys()) == {\"01\", \"10\", \"11\"})), \"Measurement results are inconsistent with the oracle type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {'00'}) or (oracle_type == 1 and '00' not in output)\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {\"00\"}) or (oracle_type == 1 and set(output.keys()) == {\"01\", \"10\", \"11\"}), \"Measurement results inconsistent with oracle type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and set(output.keys()) == {'01', '10', '11', '00'} and '00' not in output)), \"Measurement results do not match oracle type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and set(output.keys()) == {'01', '10', '11', '00'} and output.get('00', 0) == 0)\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and set(output) == {\"00\"}) or (oracle_type == 1 and set(output) == {\"01\", \"10\", \"11\"})), \"Measurement results inconsistent with oracle type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {\"00\"}) or (oracle_type == 1 and set(output.keys()) == {\"01\", \"10\", \"11\"})\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {\"00\"}) or (oracle_type == 1 and not \"00\" in output), \"Measurement results do not match expected Deutsch–Jozsa outcome for the oracle type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and set(output.keys()) == {'01', '10', '11'})), \"Measurement results do not match the oracle type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and set(output.keys()) == {'00'}) or (oracle_type == 1 and not '00' in output)), \"Oracle type and measurement results are inconsistent\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {\"00\"}) or (oracle_type == 1 and \"00\" not in output)\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and set(output.keys()) == {\"00\"}) or (oracle_type == 1 and not \"00\" in output)), f\"Inconsistent result for oracle_type {oracle_type}: {output}\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and set(output.keys()) == {\"00\"}) or (oracle_type == 1 and not \"00\" in output)), \"Oracle and measurement results inconsistent\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and set(output.keys()) == {\"00\"}) or (oracle_type == 1 and set(output.keys()) == {\"01\", \"10\", \"11\"})), \"Measurement results inconsistent with oracle type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and '00' not in output)), \"Oracle type and measurement results are inconsistent\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and all(key != '00' for key in output.keys()))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {\"00\"}) or (oracle_type == 1 and set(output.keys()) == {\"01\", \"10\", \"11\"}), \"Oracle type and measurement results are inconsistent\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {'00'}) or (oracle_type == 1 and not '00' in output), \"Measurement results do not match expected function type.\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and set(output.keys()) == {'01', '10', '11'})), \"Oracle type and measurement results are inconsistent.\"\n        # <<< ASSERTION END"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {'00'}) or (oracle_type == 1 and not '00' in output), \"Measurement result inconsistent with oracle_type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and all(key != '00' for key in output.keys()))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {'00'}) or (oracle_type == 1 and not '00' in output)\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {\"00\"}) or (oracle_type == 1 and set(output.keys()) == {\"01\", \"10\", \"11\"}), \"Measurement results do not match oracle type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and set(output.keys()) == {'00'}) or (oracle_type == 1 and set(output.keys()) == {'01', '10', '11'})), \"Measurement results do not match oracle type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {'00'}) or (oracle_type == 1 and not '00' in output)\n        # <<< ASSERTION END"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and set(output.keys()) == {'01', '10', '11'}), \"Measurement results inconsistent with oracle type\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and set(output.keys()) == {'00'}) or (oracle_type == 1 and all(bitstring != '00' for bitstring in output.keys())))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and set(output.keys()) == {'01', '10', '11'})\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {\"00\"}) or (oracle_type == 1 and set(output.keys()) == {\"01\", \"10\", \"11\"})\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and set(output.keys()) == {'01', '10', '11'})\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and all(key != '00' for key in output.keys()))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {\"00\"}) or (oracle_type == 1 and not \"00\" in output)\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert ((oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and all(k != '00' for k in output.keys())))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and list(output.keys()) == ['00']) or (oracle_type == 1 and all(k != '00' for k in output.keys()))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {\"00\"}) or (oracle_type == 1 and all(k != \"00\" for k in output.keys()))\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB14",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n        # >>> ASSERTION START\n        assert (oracle_type == 0 and set(output.keys()) == {'00'}) or (oracle_type == 1 and not '00' in output), \"Measurement results do not match oracle type.\"\n        # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        probs = sv.probabilities()\n        assert all(abs(p - 1/2**(self.n + 1)) < 1e-8 for p in probs), \"State is not a uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        probs = sv.probabilities()\n        assert all(abs(p - 1/(2**(self.n + 1))) < 1e-8 for p in probs), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        probs = np.round(np.abs(sv.data) ** 2, 10)\n        assert np.allclose(probs, np.ones_like(probs) / len(probs)), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        assert np.allclose(np.abs(sv.data), np.ones(2**(self.n+1)) / 2**((self.n+1)/2))\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        state = self.circuit.copy()\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(state)\n        uniform_amp = 1 / 2 ** ((self.n + 1) / 2)\n        assert np.allclose(np.abs(sv.data), uniform_amp), \"State is not uniform after Hadamard.\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        state = Statevector(self.circuit)\n        probs = state.probabilities()\n        assert np.allclose(probs, np.full(2 ** (self.n + 1), 1 / 2 ** (self.n + 1)))\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        psi = Statevector(self.circuit)\n        amplitudes = psi.data\n        import numpy as np\n        assert np.allclose(np.abs(amplitudes), 1/2**((self.n+1)/2)), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        state = Statevector(self.circuit)\n        probs = np.abs(state.data) ** 2\n        assert np.allclose(probs, np.ones_like(probs) / len(probs)), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        probs = np.abs(sv.data) ** 2\n        assert np.allclose(probs, np.full_like(probs, 1 / len(probs))), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        amp = 1/np.sqrt(2**(self.n + 1))\n        assert np.allclose(np.abs(sv.data), amp), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        probs = sv.probabilities()\n        assert np.allclose(probs, np.full(2**(self.n + 1), 1/(2**(self.n + 1))))\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        st = Statevector(self.circuit)\n        import numpy as np\n        assert np.allclose(np.abs(st.data), 1/2**((self.n+1)/2))\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        probs = np.abs(sv.data) ** 2\n        assert np.allclose(probs, np.ones_like(probs) / probs.size)\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        state = Statevector(self.circuit)\n        probs = np.abs(state.data)**2\n        uniform_prob = 1 / (2**(self.n + 1))\n        assert np.allclose(probs, uniform_prob, atol=1e-8), \"State is not a uniform superposition.\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        expected_amp = 1 / (2 ** ((self.n + 1)/2))\n        assert np.allclose(np.abs(sv.data), expected_amp, atol=1e-8), \"Initial state is not a uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        import numpy as np\n        assert np.allclose(np.abs(sv.data), 1/2**((self.n+1)/2)), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        amplitudes = np.abs(sv.data)\n        assert np.allclose(amplitudes, np.ones_like(amplitudes) / np.sqrt(2**(self.n + 1)))\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        import numpy as np\n        state = Statevector(self.circuit)\n        probs = np.abs(state.data) ** 2\n        assert np.allclose(probs, np.full_like(probs, 1 / len(probs))), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        probs = np.abs(sv.data) ** 2\n        assert np.allclose(probs, np.full(2**(self.n + 1), 1/(2**(self.n + 1))), atol=1e-8), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        state = Statevector(self.circuit)\n        probs = state.probabilities()\n        assert np.allclose(probs, np.full(2**(self.n+1), 1/2**(self.n+1)))\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        assert np.allclose(np.abs(sv.data), 1/np.sqrt(2**(self.n+1)), atol=1e-8)\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        statevector_backend = Aer.get_backend(\"statevector_simulator\")\n        sv_circuit = self.circuit.copy()\n        from qiskit import transpile\n        transpiled_sv = transpile(sv_circuit, statevector_backend)\n        job_sv = statevector_backend.run(transpiled_sv)\n        sv = job_sv.result().get_statevector()\n        amp_magnitudes = np.abs(sv)\n        expected = np.full(2**(self.n+1), 1/np.sqrt(2**(self.n+1)))\n        assert np.allclose(amp_magnitudes, expected, atol=1e-8), \"State is not uniform superposition after Hadamards\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        probs = sv.probabilities()\n        assert all(abs(p - 1/2**(self.n+1)) < 1e-8 for p in probs), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        n = self.n + 1\n        import numpy as np\n        assert np.allclose(np.abs(sv.data), np.ones(2**n) / np.sqrt(2**n))\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        psi = Statevector(self.circuit)\n        probs = psi.probabilities()\n        assert all(abs(p - 1/2**(self.n+1)) < 1e-8 for p in probs), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        statevector = Statevector(self.circuit)\n        probs = statevector.probabilities()\n        assert all(abs(p - 1/2**(self.n + 1)) < 1e-10 for p in probs), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        probs = sv.probabilities()\n        assert np.allclose(probs, np.full(2**(self.n+1), 1/2**(self.n+1)))\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        probs = sv.probabilities()\n        assert all(abs(p - 1/(2**(self.n+1))) < 1e-8 for p in probs), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        psi = Statevector.from_instruction(self.circuit)\n        probs = psi.probabilities()\n        assert all(abs(p - 1/2**(self.n+1)) < 1e-8 for p in probs), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        uniform_amplitude = 1 / (2 ** ((self.n + 1)/2))\n        assert all(abs(abs(a) - uniform_amplitude) < 1e-8 for a in sv.data), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        uniform_prob = 1 / (2 ** (self.n + 1))\n        assert all(abs(abs(amplitude) ** 2 - uniform_prob) < 1e-8 for amplitude in sv.data), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        expected = np.ones(2**(self.n+1)) / np.sqrt(2**(self.n+1))\n        assert np.allclose(np.abs(sv.data), expected, atol=1e-8)\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        statevec = Statevector(self.circuit)\n        probs = statevec.probabilities()\n        uniform_prob = 1 / (2 ** (self.n + 1))\n        assert all(abs(p - uniform_prob) < 1e-8 for p in probs), \"State after Hadamard is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        state = Statevector(self.circuit)\n        probs = state.probabilities_dict()\n        assert all(abs(p - 1/2**(self.n + 1)) < 1e-8 for p in probs.values())\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        probs = sv.probabilities()\n        import numpy as np\n        assert np.allclose(probs, np.ones(2 ** (self.n + 1)) / 2 ** (self.n + 1))\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        probs = sv.probabilities()\n        assert np.allclose(probs, np.ones_like(probs) / len(probs)), \"State is not a uniform superposition after Hadamards\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        probs = sv.probabilities()\n        assert np.allclose(probs, np.ones_like(probs)/len(probs), atol=1e-10)\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        probs = sv.probabilities()\n        import numpy as np\n        assert np.allclose(probs, np.full(2**(self.n+1), 1/2**(self.n+1)))\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        probs = np.abs(sv.data) ** 2\n        assert np.allclose(probs, np.ones_like(probs) / len(probs))\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        expected_prob = 1 / (2 ** (self.n + 1))\n        probs = np.abs(sv.data) ** 2\n        assert np.allclose(probs, expected_prob, atol=1e-8)\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        state = Statevector.from_instruction(self.circuit)\n        probs = np.abs(state.data) ** 2\n        uniform_prob = 1 / 2 ** (self.n + 1)\n        assert np.allclose(probs, uniform_prob, atol=1e-8), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        p = np.abs(sv.data)**2\n        assert np.allclose(p, np.ones_like(p)/len(p), atol=1e-8)\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        probs = sv.probabilities()\n        assert np.allclose(probs, np.ones_like(probs)/len(probs)), \"State is not uniform after Hadamard gates\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        expected = 1 / 2 ** ((self.n + 1) / 2)\n        assert all(abs(abs(a) - expected) < 1e-8 for a in sv.data), \"State is not uniform after Hadamards\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        state = Statevector(self.circuit)\n        uniform_amp = 1 / np.sqrt(2 ** (self.n + 1))\n        assert np.allclose(np.abs(state.data), uniform_amp, atol=1e-10)\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        uniform_amp = 1/(2**((self.n+1)/2))\n        assert all(abs(abs(a) - abs(uniform_amp)) < 1e-8 for a in sv.data), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        probs = sv.probabilities()\n        assert all(abs(p - 1/2**(self.n + 1)) < 1e-9 for p in probs), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        assert np.allclose(np.abs(sv.data), np.full(2**(self.n + 1), 1/2**((self.n + 1)/2)))\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        state = Statevector.from_instruction(self.circuit)\n        amp = 1 / np.sqrt(2 ** (self.n + 1))\n        assert np.allclose(np.abs(state.data), amp, atol=1e-8)\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        state = Statevector(self.circuit)\n        probs = np.abs(state.data) ** 2\n        assert np.allclose(probs, np.full_like(probs, 1/len(probs))), \"State is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys())[0] == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert list(output.keys())[0] == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a[::-1]\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB16",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert max(output, key=output.get) == circuit_runner.a\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        expected = [0.5, 0.5, 0.5, 0.5] + [0.0]*12\n        assert all(abs(a-b) < 1e-8 for a, b in zip(sv.data.real, expected)), \"Input is not in uniform superposition.\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        input_sv = sv.data.reshape([2]*4)\n        input_register = input_sv.sum(axis=(2,3))\n        amplitudes = input_register.flatten()\n        assert np.allclose(np.abs(amplitudes), 0.5), \"Input register is not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        uniform_state = np.ones(4) / 2\n        assert np.allclose(sv.data[:4], uniform_state, atol=1e-8), \"Input register is not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n        # >>> ASSERTION START\n        assert all(abs(p - 0.25) < 1e-8 for p in (__import__('qiskit').quantum_info.Statevector.from_instruction(self.circuit).probabilities([0,1])))\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        vec = Statevector(self.circuit)\n        expected = np.ones(4) / 2\n        actual = np.abs(vec.data[:4])\n        assert np.allclose(actual, expected), \"Input qubits are not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        state = Statevector(self.circuit)\n        import numpy as np\n        expected = np.ones(4)/2\n        assert np.allclose(np.abs(state.data[:4]), expected, atol=1e-8), \"Input register is not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        expected = np.ones(4) / 2\n        assert np.allclose(np.abs(sv.data[:4]), expected, atol=1e-8), \"Input qubits are not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        state = Statevector(self.circuit)\n        import numpy as np\n        expected = np.ones(4)/2\n        actual = np.abs(state.data[:4])\n        assert np.allclose(actual, expected, atol=1e-8), \"Input register is not in uniform superposition.\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        expected = np.ones(4) / 2\n        assert np.allclose(np.abs(sv.data[:4]), expected, atol=1e-8)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        target = [0.5, 0.5, 0.5, 0.5] + [0]*12\n        assert all(abs(x - y) < 1e-8 for x, y in zip(sv.data.real, target)), \"Input register is not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        psi = sv.data\n        import numpy as np\n        n = self.n\n        uniform = np.ones(2**n) / np.sqrt(2**n)\n        assert np.allclose(psi[:2**n], uniform) and np.allclose(psi[2**n:], 0)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        assert all(abs(abs(a) - 0.5) < 1e-8 for a in sv.data[:4]), \"Input register is not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        ideal = np.ones(4) / 2\n        actual = np.abs(sv.data[:4])\n        assert np.allclose(actual, ideal), \"Input register is not in uniform superposition after Hadamard.\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        expected = [0.5, 0.5, 0.5, 0.5] + [0]*12\n        assert all(abs(a - b) < 1e-8 for a, b in zip(sv.data.real, expected)), \"Input register is not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        expected_sv = Statevector.from_label('0000').evolve(QuantumCircuit(2*self.n).h([0,1]))\n        assert sv.probabilities_dict(decimals=5) == expected_sv.probabilities_dict(decimals=5)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        expected = [1/2, 1/2, 1/2, 1/2] + [0]*12\n        assert all(abs(a - b) < 1e-8 for a, b in zip(sv.data.real, expected)), \"Uniform superposition not prepared\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        state = Statevector.from_instruction(self.circuit)\n        expected = np.ones(4) / 2\n        actual = np.abs(state.data[:4])\n        assert np.allclose(actual, expected), \"Input register is not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        assert sv.probabilities_dict() == {'0000': 0.25, '0100': 0.25, '1000': 0.25, '1100': 0.25}\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        input_sv = sv.data.reshape([2] * (2 * self.n))\n        marginal = input_sv.sum(axis=tuple(range(self.n, 2 * self.n)))\n        import numpy as np\n        expected = np.ones(2 ** self.n) / np.sqrt(2 ** self.n)\n        assert np.allclose(np.abs(marginal), np.abs(expected), atol=1e-8)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        probs = sv.probabilities_dict()\n        assert all(abs(p - 0.25) < 1e-6 for k, p in probs.items() if k[-2:] in ['00', '01', '10', '11']), \"Input register is not in a uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        expected = np.ones(4) / 2\n        actual = np.abs(sv.data[:4])\n        assert np.allclose(actual, expected), \"Input register is not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        amp = abs(sv.data[:2**self.n])\n        assert all(abs(a - amp[0]) < 1e-8 for a in amp), \"Input register is not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        import numpy as np\n        expected = np.ones(4) / 2\n        assert np.allclose(np.abs(sv.data[:4]), expected, atol=1e-8)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        input_sv = sv.data.reshape([2]*4)\n        input_marginal = np.sum(np.abs(input_sv)**2, axis=(2,3))\n        expected = np.ones(4) / 4\n        assert np.allclose(input_marginal, expected, atol=1e-8), \"Input register is not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        uniform = np.ones(4)/2\n        assert np.allclose(np.abs(sv.data[:4]), uniform, atol=1e-7), \"Input register is not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        expected_sv = [0.5, 0.5, 0.5, 0.5] + [0]*12\n        assert all(abs(sv.data[i] - expected_sv[i]) < 1e-8 for i in range(16))\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        state = Statevector(self.circuit)\n        input_superposition = [1/2]*4 + [0]*12\n        assert all(abs(a-b) < 1e-8 for a, b in zip(state.data.real, input_superposition)), \"Input is not a uniform superposition before oracle.\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        expected = np.ones(4) / 2\n        assert np.allclose(np.abs(sv.data[:4]), expected), \"Input register is not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        target = Statevector.from_label('0000').evolve([('h', [0]), ('h', [1])])\n        assert sv.equiv(target), \"Input qubits are not in a uniform superposition after Hadamards\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n        # >>> ASSERTION START\n        state = self.circuit.copy()\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(state)\n        expected = [0.5, 0.5, 0.5, 0.5] + [0]*12\n        assert all(abs(a-b)<1e-8 for a, b in zip(sv.data.real, expected)), \"Uniform superposition not prepared\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        import numpy as np\n        expected = np.ones(4) / 2\n        actual = np.abs(sv.data[:4])\n        assert np.allclose(actual, expected, atol=1e-8)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        state = Statevector(self.circuit)\n        import numpy as np\n        expected = np.ones(4)/2\n        assert np.allclose(state.probabilities([0,1]), expected, atol=1e-8)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        statevec = Statevector(self.circuit)\n        uniform = Statevector.from_label('0'*(2*self.n)).evolve([self.circuit.h(i) for i in range(self.n)])\n        assert statevec.probabilities_dict() == uniform.probabilities_dict()\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        expected = np.ones(4) / 2\n        assert np.allclose(np.abs(sv.data[:4]), expected, atol=1e-8)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        expected = np.ones(4) / 2\n        assert np.allclose(np.abs(sv.data[:4]), expected)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        assert all(abs(abs(a) - 0.5) < 1e-8 for a in sv.data[:4])\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        input_sv = sv.data.reshape([2]*4)\n        input_marginal = input_sv.sum(axis=(2,3))\n        probs = abs(input_marginal.flatten())**2\n        assert all(abs(p - 0.25) < 1e-8 for p in probs), \"Input qubits are not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        expected = [0.5, 0.5, 0.5, 0.5] + [0]*12\n        assert all(abs(a - b) < 1e-8 for a, b in zip(sv.data.real, expected)), \"Input not in uniform superposition.\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        import numpy as np\n        uniform_state = np.ones(4) / 2\n        assert np.allclose(sv.data[:4], uniform_state, atol=1e-8), \"Input register is not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        expected = np.array([0.5, 0.5, 0.5, 0.5] + [0, 0, 0, 0])\n        assert np.allclose(sv.data, expected), \"Input qubits are not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        state = Statevector(self.circuit)\n        probs = state.probabilities_dict()\n        # Only the input qubits (first n) are in superposition; ignore ancilla\n        marginal_probs = {}\n        for b in [\"00\", \"01\", \"10\", \"11\"]:\n            total = 0.0\n            for ancilla in [\"00\", \"01\", \"10\", \"11\"]:\n                full = b + ancilla\n                if full in probs:\n                    total += probs[full]\n            marginal_probs[b] = total\n        assert all(abs(p - 0.25) < 1e-6 for p in marginal_probs.values()), \"Input qubits are not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        psi = Statevector(self.circuit)\n        expected = [1/2, 1/2, 1/2, 1/2] + [0]*12\n        assert all(abs(a - b) < 1e-8 for a, b in zip(psi.data, expected))\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n\n        sv = Statevector(self.circuit)\n        probs = sv.probabilities()\n        n_basis = 2 ** (2 * self.n)\n        # Only the input register should be in uniform superposition; output register in |0>\n        # Build expected statevector: 1/sqrt(4) sum_{x in 0..3} |x>|00>\n        expected_sv = np.zeros(n_basis, dtype=complex)\n        for x in range(4):\n            idx = x * 4  # |x>|00>\n            expected_sv[idx] = 0.5\n        assert np.allclose(sv.data, expected_sv, atol=1e-8), \"Initial uniform superposition not prepared\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        import numpy as np\n        amp = np.abs(sv.data[:4])\n        assert np.allclose(amp, [0.5, 0.5, 0.5, 0.5]), \"Input register is not in uniform superposition after Hadamards\"\n        # <<< ASSERTION END\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        prob_vector = sv.probabilities([0,1])\n        assert all(abs(p - 0.25) < 1e-8 for p in prob_vector), \"Input register is not in uniform superposition.\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        import numpy as np\n        assert np.allclose(np.abs(sv.data[:4])**2, [0.25, 0.25, 0.25, 0.25], atol=1e-8), \"Input qubits are not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        import numpy as np\n        statevec_backend = Aer.get_backend(\"statevector_simulator\")\n        temp_circuit = self.circuit.copy()\n        job = statevec_backend.run(transpile(temp_circuit, statevec_backend))\n        state = job.result().get_statevector()\n        expected = np.zeros(16, dtype=complex)\n        expected[0] = 0.5\n        expected[1] = 0.5\n        expected[2] = 0.5\n        expected[3] = 0.5\n        assert np.allclose(state, expected)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        input_sv = sv.data.reshape([2]*4)\n        input_probs = abs(input_sv[:2, :2, 0, 0].flatten())**2\n        assert all(abs(p - 0.25) < 1e-8 for p in input_probs), \"Input register not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(self.circuit)\n        amplitudes = sv.data\n        assert all(abs(abs(a) - 0.25**0.5) < 1e-8 for a in amplitudes), \"Initial state is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(self.circuit)\n        expected = Statevector.from_label('00').evolve((QuantumCircuit(2*self.n)).h([0,1]))\n        assert sv.probabilities_dict(decimals=6) == expected.probabilities_dict(decimals=6)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    # >>> ASSERTION START\n    a = \"11\"\n    keys = set(output.keys())\n    def bit_dot(u, v):\n        return sum((int(b1) & int(b2)) for b1, b2 in zip(u, v)) % 2\n    def bxor(u, v):\n        return \"\".join(str(int(b1) ^ int(b2)) for b1, b2 in zip(u, v))\n    assert all(bit_dot(k, a) == 0 for k in keys), \"Measured inputs are not orthogonal to hidden string a\"\n    assert all(bxor(k, a) in keys for k in keys), \"Measured inputs are not closed under XOR with hidden string a\"\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(((format(int(k, 2) ^ int(simon_runner.a, 2), f\"0{simon_runner.n}b\") in output) or (int(k,2) == 0)) for k in output), \"Not all outcomes appear in pairs related by the hidden string.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    hidden = \"11\"\n    keys = list(output.keys())\n    key_set = set(keys)\n    pair_count = 0\n    for k in keys:\n        paired = format(int(k, 2) ^ int(hidden, 2), '0{}b'.format(len(hidden)))\n        if paired in key_set:\n            pair_count += 1\n    assert pair_count == len(keys), \"Input register measurement results do not exhibit required pairwise structure.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    bitstrings = set(output.keys())\n    a = \"11\"\n    pairs = set()\n    for b in bitstrings:\n        partner = \"{0:0{1}b}\".format(int(b, 2) ^ int(a, 2), len(a))\n        if partner in bitstrings:\n            pairs.add(frozenset([b, partner]))\n    assert 2 * len(pairs) == len(bitstrings), \"Measurement results are not pairwise related by the hidden string.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(format(int(k,2)^int('11',2),'02b') in output for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(((bin(int(x,2)^int(\"11\",2))[2:].zfill(2) in output) or int(x,2)^int(\"11\",2)==int(x,2)) for x in output), \"Not all results appear in pairs related by the hidden string.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(output.get(format(int(k, 2) ^ int(simon_runner.a, 2), f'0{simon_runner.n}b'), 0) == v for k, v in output.items()), \"Input register measurement results do not exhibit Simon's pairwise structure\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all('{0:0{1}b}'.format(int(k, 2) ^ int(simon_runner.a, 2), simon_runner.n) in output for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(((format(int(k,2)^int(simon_runner.a,2), '0{}b'.format(simon_runner.n)) in output) or (int(k,2)^int(simon_runner.a,2)==int(k,2))) for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((bin(int(k,2)^int(\"11\",2))[2:].zfill(2) in output) for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(output.get(f\"{(int(k,2)^int(simon_runner.a,2)):0{len(k)}b}\", 0) == output[k] for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(bin(int(k,2)^int('11',2)).count('1')!=1 for k in output), \"Measurement results should appear in pairs related by the hidden string.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(((format(int(k,2)^int(simon_runner.a,2), f'0{simon_runner.n}b') in output) for k in output)), \"Measurement results do not exhibit Simon's pairwise structure\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    s = '11'\n    keys = list(output.keys())\n    pairs = set()\n    for k in keys:\n        paired = ''.join(str(int(a)^int(b)) for a,b in zip(k[::-1], s))\n        paired = paired[::-1]\n        pairs.add(frozenset([k, paired]))\n    assert all(len([x for x in pair if x in output]) == 2 for pair in pairs), \"Input register results do not appear in pairs related by the hidden string.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    # >>> ASSERTION START\n    assert all((format(int(k, 2) ^ int(simon_runner.a, 2), '0' + str(simon_runner.n) + 'b') in output) for k in output)\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    pairs = set()\n    for bitstring in output:\n        paired = ''.join(str((int(b) ^ int(a))) for b, a in zip(bitstring, simon_runner.a))\n        pairs.add(frozenset([bitstring, paired]))\n    assert all(len({b for b in pair if b in output}) in [0,2] for pair in pairs)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(bin(int(x,2) ^ int(simon_runner.a,2))[2:].zfill(simon_runner.n) in output for x in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(((format(int(k,2)^int(\"11\",2), '02b') in output) or output[k]==0) for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(((format(int(k,2)^int(simon_runner.a,2), '0{}b'.format(simon_runner.n)) in output) or (k == format(int(k,2)^int(simon_runner.a,2), '0{}b'.format(simon_runner.n)))) for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    a = \"11\"\n    keys = list(output.keys())\n    pairs = set()\n    for k in keys:\n        paired = '{:0{}b}'.format(int(k,2)^int(a,2), len(a))\n        pairs.add(frozenset([k, paired]))\n    assert len(pairs) * 2 == len(keys), \"Input register measurements do not exhibit the expected pairwise structure.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(((bin((int(k,2) ^ int('11',2)))[2:].zfill(2)) in output) for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(((format(int(bitstring, 2) ^ int(simon_runner.a, 2), f'0{simon_runner.n}b') in output) or (output[bitstring] == 0)) for bitstring in output)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(('{:0{}b}'.format(int(bitstring, 2) ^ int(simon_runner.a, 2), simon_runner.n) in output) for bitstring in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(((format(int(k,2)^int(simon_runner.a,2), \"0{}b\".format(simon_runner.n)) in output) or (k == format(int(k,2)^int(simon_runner.a,2), \"0{}b\".format(simon_runner.n)))) for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    keys = set(output.keys())\n    paired = all(format(int(k, 2) ^ int(simon_runner.a, 2), '0{}b'.format(simon_runner.n)) in keys for k in keys)\n    assert paired, \"Input register results do not exhibit Simon's pairwise structure\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    pairs = set()\n    for bitstring in output:\n        pair = \"{:0{}b}\".format(int(bitstring,2)^int(simon_runner.a,2), simon_runner.n)\n        pairs.add(frozenset([bitstring, pair]))\n    assert len(pairs) == len(output), \"Input register results do not exhibit expected pairwise structure.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    n = 2\n    a = \"11\"\n    keys = list(output.keys())\n    pairs = set()\n    for k in keys:\n        partner = \"{:0{}b}\".format(int(k,2)^int(a,2), n)\n        pairs.add(frozenset([k, partner]))\n    assert len(pairs) == len(keys)//2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    bitstrings = set(output)\n    a = \"11\"\n    pairs = set()\n    for b in bitstrings:\n        pair = format(int(b, 2) ^ int(a, 2), \"0\" + str(len(a)) + \"b\")\n        pairs.add(frozenset([b, pair]))\n    assert all(len({b, format(int(b, 2) ^ int(a, 2), \"0\" + str(len(a)) + \"b\")} & bitstrings) == 2 for b in bitstrings), \"Measurement results do not exhibit the required pairwise structure.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(format(int(bitstring, 2) ^ int(simon_runner.a, 2), '0{}b'.format(simon_runner.n)) in output for bitstring in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    hidden = \"11\"\n    keys = list(output.keys())\n    pairs = set()\n    for k in keys:\n        mate = '{:0{n}b}'.format(int(k,2)^int(hidden,2), n=2)\n        if mate in output:\n            pairs.add(frozenset([k, mate]))\n    assert len(pairs)*2 == len(keys)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(format(int(key, 2) ^ int(simon_runner.a, 2), f'0{simon_runner.n}b') in output for key in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(format(int(k, 2) ^ int(simon_runner.a, 2), f'0{simon_runner.n}b') in output for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    s = set(int(x, 2) for x in output)\n    a = int(simon_runner.a, 2)\n    for x in s:\n        assert ((x ^ a) in s) or ((x ^ a) == x)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    period = \"11\"\n    results = set(output)\n    assert all(('{0:02b}'.format((int(r,2)^int(period,2))) in results) for r in results), \"Measurement results do not exhibit the required pairwise structure\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    keys = list(output.keys())\n    a = \"11\"\n    for k in keys:\n        k_int = int(k, 2)\n        pair_int = k_int ^ int(a, 2)\n        pair = format(pair_int, '0{}b'.format(len(k)))\n        assert (pair in output), f\"Pair {pair} for {k} missing in results\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((format(int(k, 2) ^ int(simon_runner.a, 2), '0{}b'.format(simon_runner.n)) in output) for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    pairs = set()\n    for bitstr in output:\n        complement = '{:0{}b}'.format(int(bitstr,2)^int(simon_runner.a,2), simon_runner.n)\n        if complement in output:\n            pairs.add(frozenset([bitstr, complement]))\n    assert len(pairs) >= 1, \"Input register measurement results do not exhibit the required pairwise structure.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(bin(int(k,2)^int('11',2))[2:].zfill(2) in output for k in output)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(format(int(bitstring, 2) ^ int(\"11\", 2), '02b') in output for bitstring in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    n = 2\n    a = \"11\"\n    keys = set(output.keys())\n    pairs = set()\n    for b in keys:\n        b_xor_a = format(int(b, 2) ^ int(a, 2), f'0{n}b')\n        pair = frozenset([b, b_xor_a])\n        pairs.add(pair)\n    assert all(len(pair & keys) == 2 for pair in pairs)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(format(int(k, 2) ^ int(\"11\", 2), \"0{}b\".format(simon_runner.n)) in output for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(((format(int(k,2)^int(simon_runner.a,2), f'0{simon_runner.n}b') in output) for k in output)), \"Not all pairs related by the hidden string appear in the results.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(output.get(format(i, \"0{}b\".format(simon_runner.n)), 0) == output.get(format(i ^ int(simon_runner.a, 2), \"0{}b\".format(simon_runner.n)), 0) for i in range(2**simon_runner.n))\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(((format(int(k,2)^int(simon_runner.a,2), f'0{simon_runner.n}b') in output) for k in output)), \"Not all results appear in expected pairs related by the hidden string.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    a = \"11\"\n    keys = list(output.keys())\n    key_set = set(keys)\n    pairs = set()\n    for k in keys:\n        kxor = \"{0:0{1}b}\".format(int(k,2) ^ int(a,2), len(a))\n        pair = tuple(sorted([k, kxor]))\n        pairs.add(pair)\n    assert all(pair[0] in key_set and pair[1] in key_set for pair in pairs)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    bitstrings = list(output.keys())\n    a_int = int('11', 2)\n    matched = set()\n    for b in bitstrings:\n        b_int = int(b, 2)\n        pair = format(b_int ^ a_int, '0{}b'.format(len(b)))\n        if pair in output:\n            matched.add(frozenset({b, pair}))\n    assert len(matched) * 2 == len(bitstrings)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    a_int = int(simon_runner.a, 2)\n    keys = list(output.keys())\n    pairs = set()\n    for k in keys:\n        k_int = int(k, 2)\n        pair = format(k_int ^ a_int, '0{}b'.format(simon_runner.n))\n        if pair in output:\n            pairs.add(frozenset([k, pair]))\n    assert len(pairs)*2 == len(keys)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(output.get(format(int(k,2)^int(simon_runner.a,2), f'0{simon_runner.n}b'), 0) == output[k] for k in output), \"Measurement results do not exhibit the required pairwise structure.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(format(int(k, 2) ^ int(simon_runner.a, 2), f'0{simon_runner.n}b') in output for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB18",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(((format(int(k, 2) ^ int(simon_runner.a, 2), '0{}b'.format(simon_runner.n))) in output) for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstring[0]) ^ int(bitstring[1])) == 0 for bitstring in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(k[0]) ^ int(k[1])) == 0 for k in output.keys())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(sum(int(b) for b, a_i in zip(key, simon_runner.a) if a_i == '1') % 2 == 0 for key in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstring[0]) ^ int(bitstring[1])) == 0 for bitstring in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output.keys())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstring[0]) ^ int(bitstring[1])) == 0 for bitstring in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(((int(key[0]) ^ int(key[1])) == 0) for key in output)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(key[0]) ^ int(key[1])) == 0 for key in output.keys())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bits[0]) ^ int(bits[1])) == 0 for bits in output), \"Measurement results do not satisfy y·a=0 (mod 2) for a=11\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstring[0]) ^ int(bitstring[1])) == 0 for bitstring in output.keys())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(k[0]) ^ int(k[1])) == 0 for k in output.keys())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstring[0]) ^ int(bitstring[1])) == 0 for bitstring in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstring[0]) ^ int(bitstring[1])) == 0 for bitstring in output), \"Measurement results do not satisfy the hidden string constraint.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output.keys())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(k[0]) ^ int(k[1])) == 0 for k in output.keys())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(key[0]) ^ int(key[1])) == 0 for key in output.keys())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(k[0]) ^ int(k[1])) == 0 for k in output.keys())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(k[0]) ^ int(k[1])) == 0 for k in output.keys())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(k[0]) ^ int(k[1])) == 0 for k in output.keys())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(k[0]) ^ int(k[1])) == 0 for k in output.keys())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    # >>> ASSERTION START\n    assert all((int(bitstring[0]) ^ int(bitstring[1])) == 0 for bitstring in output)\n    # <<< ASSERTION END\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output), \"Measurement results do not satisfy y·a=0 (mod 2) for a='11'\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bits[0]) ^ int(bits[1])) == 0 for bits in output.keys())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output), \"Measurement results do not satisfy the linear constraint: y·a = 0\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(k[0]) ^ int(k[1])) == 0 for k in output)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(k[0]) ^ int(k[1])) == 0 for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output), \"Constraint not satisfied: y·a = 0 mod 2\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr, 2) & 0b11) % 2 == 0 for bitstr in output), \"All measurement results must satisfy y·a=0 mod 2\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output.keys())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(key[0]) ^ int(key[1])) == 0 for key in output)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr, 2) & 0b11) in (0, 3) for bitstr in output), \"Measurement outcome does not satisfy y·a=0 mod 2\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(k[0]) ^ int(k[1])) == 0 for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstring[0]) ^ int(bitstring[1])) == 0 for bitstring in output), \"All outputs must satisfy y·a=0 mod 2\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output.keys())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(key[0]) ^ int(key[1])) == 0 for key in output), \"Measurement results do not satisfy the hidden string constraint\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(k[0]) ^ int(k[1])) == 0 for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bits[0]) ^ int(bits[1])) == 0 for bits in output), \"Observed results do not satisfy the linear constraint with respect to the hidden string.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(k[0]) ^ int(k[1])) == 0 for k in output), \"Measurement results do not satisfy the constraint: y·a=0 mod 2\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(k[0]) ^ int(k[1])) == 0 for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all(((int(bitstring[0]) ^ int(bitstring[1])) == 0) for bitstring in output)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bits[0]) ^ int(bits[1])) == 0 for bits in output.keys())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB19",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n    # >>> ASSERTION START\n    assert all((int(bitstr[0]) ^ int(bitstr[1])) == 0 for bitstr in output), \"Measurement results do not satisfy the linear constraint with respect to the hidden string.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For each input x, check f(x) == f(x XOR a) where a = \"11\"\n    input_to_output = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        input_to_output[inputs] = outputs\n    for x in input_to_output:\n        # XOR x with \"11\" (which is 3)\n        x_val = int(x, 2)\n        x_xor_a = format(x_val ^ 0b11, '02b')\n        assert input_to_output[x] == input_to_output[x_xor_a], f\"Assertion failed for {x} and {x_xor_a}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in mapping:\n        x_xor_a = \"{0:02b}\".format(int(x, 2) ^ 0b11)\n        assert mapping[x] == mapping.get(x_xor_a, mapping[x]), f\"Assertion failed: f({x}) != f({x_xor_a})\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    a = 3  # hidden period \"11\"\n    input_to_output = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        input_to_output[inputs] = outputs\n    for inputs in input_to_output:\n        x = int(inputs, 2)\n        x_paired = x ^ a\n        inputs_paired = format(x_paired, '02b')\n        if inputs_paired in input_to_output:\n            assert input_to_output[inputs] == input_to_output[inputs_paired], f\"f({inputs}) != f({inputs_paired})\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    a = \"11\"\n    mapping = {}\n    for bitstring, cnt in counts.items():\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for inputs in mapping:\n        paired = format(int(inputs, 2) ^ int(a, 2), \"02b\")\n        assert mapping[inputs] == mapping[paired], f\"f({inputs}) != f({paired})\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    a = '11'\n    input_to_output = {}\n    for bitstring in counts.keys():\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        input_to_output[inputs] = outputs\n    for x in input_to_output:\n        x_xor_a = '{:02b}'.format(int(x, 2) ^ int(a, 2))\n        if x_xor_a in input_to_output:\n            assert input_to_output[x] == input_to_output[x_xor_a], f\"Assertion failed for x={x}, x⊕a={x_xor_a}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n\n    # >>> ASSERTION START\n    # For each input x, check f(x) == f(x XOR a) where hidden period a = \"11\"\n    input_to_output = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        input_to_output[inputs] = outputs\n    for inputs in input_to_output:\n        # XOR with \"11\" (bitwise NOT for 2 bits)\n        x = int(inputs, 2)\n        a = 0b11\n        paired_x = x ^ a\n        paired_inputs = format(paired_x, \"02b\")\n        assert input_to_output[inputs] == input_to_output[paired_inputs], f\"f({inputs}) != f({paired_inputs})\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        mapping[inputs] = outputs\n    for inputs in mapping:\n        # XOR with hidden period '11'\n        paired = f\"{int(inputs,2)^0b11:02b}\"\n        assert mapping[inputs] == mapping[paired], f\"Assertion failed: Output for {inputs} != Output for {paired}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For each input x, output is same as for input x XOR a (where a = \"11\")\n    mapping = {}\n    for bitstring, _ in counts.items():\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for inputs in mapping:\n        x = int(inputs, 2)\n        a = 0b11\n        paired_x = x ^ a\n        paired_inputs = format(paired_x, \"02b\")\n        assert mapping[inputs] == mapping.get(paired_inputs, mapping[inputs]), f\"Outputs differ for {inputs} and {paired_inputs}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    period = '11'\n    input_to_output = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        input_to_output[inputs] = outputs\n    for inputs, outputs in input_to_output.items():\n        paired_inputs = '{:02b}'.format(int(inputs, 2) ^ int(period, 2))\n        if paired_inputs in input_to_output:\n            assert input_to_output[inputs] == input_to_output[paired_inputs], f\"Output mismatch for {inputs} and {paired_inputs}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    a = \"11\"\n    mapping = {}\n    for bitstring, cnt in counts.items():\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in mapping:\n        x_xor_a = \"{:02b}\".format(int(x, 2) ^ int(a, 2))\n        assert mapping[x] == mapping.get(x_xor_a, mapping[x]), f\"Assertion failed for inputs {x} and {x_xor_a}: {mapping[x]} != {mapping.get(x_xor_a)}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For each input x, check that output for x and x XOR a (\"11\") is the same\n    mapping = {}\n    for bitstring in counts:\n        out = bitstring[:2]\n        inp = bitstring[-2:]\n        mapping[inp] = out\n    for inp in mapping:\n        x_xor_a = f\"{int(inp,2)^0b11:02b}\"\n        assert mapping[inp] == mapping.get(x_xor_a, mapping[inp]), f\"Outputs differ for {inp} and {x_xor_a}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for i in range(4):\n        x = format(i, \"02b\")\n        a = \"11\"\n        x_xor_a = format(int(x,2) ^ int(a,2), \"02b\")\n        if x_xor_a in mapping and x in mapping:\n            assert mapping[x] == mapping[x_xor_a], f\"Assertion failed: Output for {x} ({mapping[x]}) != Output for {x_xor_a} ({mapping[x_xor_a]})\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # Pairing each input x with x XOR a (where a = \"11\")\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in mapping:\n        x_xor_a = \"{:02b}\".format(int(x, 2) ^ 0b11)\n        assert mapping[x] == mapping[x_xor_a], f\"Assertion failed: Output for {x} != Output for {x_xor_a}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    a = 3  # binary '11'\n    output_for_input = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        x = int(inputs, 2)\n        output_for_input[x] = outputs\n    for x in range(4):\n        paired_x = x ^ a\n        assert output_for_input.get(x) == output_for_input.get(paired_x), f\"Assertion failed: Output for input {x:02b} != output for input {paired_x:02b}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # Check that for each input x, output is same as for x XOR a (a=\"11\"=3)\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in mapping:\n        x_int = int(x, 2)\n        a_int = 3\n        x_xor_a = format(x_int ^ a_int, '02b')\n        assert mapping[x] == mapping.get(x_xor_a, mapping[x]), f\"Assertion failed for inputs {x} and {x_xor_a}: {mapping[x]} vs {mapping.get(x_xor_a)}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # Create a mapping from input bits to output bits\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    a = \"{0:02b}\".format(int('11', 2))\n    for x in mapping:\n        x_xor_a = \"{0:02b}\".format(int(x,2) ^ int(a,2))\n        if x_xor_a in mapping:\n            assert mapping[x] == mapping[x_xor_a], f\"Assertion failed: f({x}) != f({x_xor_a})\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in [\"00\", \"01\", \"10\", \"11\"]:\n        x_xor_a = \"{0:02b}\".format(int(x, 2) ^ int(\"11\", 2))\n        assert mapping[x] == mapping[x_xor_a], f\"Assertion failed: Output for {x} != Output for {x_xor_a}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # Assert for each input x, output equals output for (x XOR a), with a=\"11\"\n    a = '11'\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in mapping:\n        x_xor_a = f\"{int(x, 2) ^ int(a, 2):0{len(x)}b}\"\n        assert mapping[x] == mapping[x_xor_a], f\"Output differs for {x} and {x_xor_a}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # Prepare mapping: input -> output\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        mapping[inputs] = outputs\n    for inputs in mapping:\n        # XOR with period \"11\" (binary), i.e., flip both bits\n        x = int(inputs, 2)\n        x_xor_a = x ^ 0b11\n        xor_inputs = format(x_xor_a, '02b')\n        # Both inputs and their pair must be in mapping (since superposition covers all)\n        assert mapping[inputs] == mapping[xor_inputs], f\"f({inputs}) != f({xor_inputs})\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    a = \"{0:02b}\".format(3)  # hidden period a = '11'\n    for x in mapping:\n        x_xor_a = \"{0:02b}\".format(int(x, 2) ^ int(a, 2))\n        if x_xor_a in mapping:\n            assert mapping[x] == mapping[x_xor_a], f\"Oracle not periodic: f({x}) != f({x_xor_a})\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For hidden period a = \"11\", check that outputs for x and x XOR a are equal\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in mapping:\n        # XOR with \"11\" flips both bits\n        x_xor_a = \"\".join(\"0\" if b == \"1\" else \"1\" for b in x)\n        assert mapping[x] == mapping[x_xor_a], f\"Output mismatch for {x} and {x_xor_a}\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For all inputs x, the output is the same as for x XOR a (\"11\")\n    a = 0b11\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        input_int = int(inputs, 2)\n        mapping[input_int] = outputs\n    for x in range(4):\n        x_pair = x ^ a\n        assert mapping[x] == mapping[x_pair], f\"f({x:02b}) != f({x_pair:02b})\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    a = \"11\"\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in mapping:\n        x_xor_a = f\"{int(x,2) ^ int(a,2):02b}\"\n        assert mapping[x] == mapping[x_xor_a], f\"Output mismatch for inputs {x} and {x_xor_a}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For all input x, output should be equal to output for x XOR a (a=\"11\")\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for inputs, outputs in mapping.items():\n        x = int(inputs, 2)\n        a = 0b11\n        x_pair = x ^ a\n        inputs_pair = format(x_pair, '02b')\n        if inputs_pair in mapping:\n            assert mapping[inputs] == mapping[inputs_pair], f\"f({inputs}) != f({inputs_pair})\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For all x, output for x == output for x XOR a ('11')\n    period = '11'\n    outputs_for_input = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        outputs_for_input[inputs] = outputs\n    for x in outputs_for_input:\n        x_int = int(x, 2)\n        a_int = int(period, 2)\n        x_xor_a = format(x_int ^ a_int, '02b')\n        if x_xor_a in outputs_for_input:\n            assert outputs_for_input[x] == outputs_for_input[x_xor_a], f\"Assertion failed: Output for {x} != Output for {x_xor_a}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n\n    # >>> ASSERTION START\n    output_map = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        output_map[inputs] = outputs\n    for x in [\"00\", \"01\", \"10\", \"11\"]:\n        x_xor_a = format(int(x, 2) ^ 0b11, \"02b\")\n        assert output_map[x] == output_map[x_xor_a], f\"Assertion failed for input {x} and {x_xor_a}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For all x, check f(x) == f(x XOR a) for a=11\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in ['00', '01', '10', '11']:\n        x_xor_a = ''.join(str(int(b)^1) for b in x)  # XOR with \"11\"\n        assert mapping.get(x) == mapping.get(x_xor_a), f\"Assertion failed: f({x}) != f({x_xor_a})\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For each input x, check that outputs for x and x XOR '11' are the same\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in mapping:\n        x_xor_a = \"{:02b}\".format(int(x, 2) ^ 0b11)\n        assert mapping[x] == mapping[x_xor_a], f\"f({x}) != f({x_xor_a})\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    a = '11'\n    mapping = {}\n    for bitstring, cnt in counts.items():\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in mapping:\n        x_xor_a = f\"{int(x,2)^int(a,2):02b}\"\n        if x_xor_a in mapping:\n            assert mapping[x] == mapping[x_xor_a], f\"Output mismatch: f({x})={mapping[x]} vs f({x_xor_a})={mapping[x_xor_a]}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For each x, check f(x) == f(x XOR a) for a = \"11\" (binary 3)\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in mapping:\n        # XOR with \"11\" to get x_a\n        x_int = int(x, 2)\n        x_a_int = x_int ^ 0b11\n        x_a = format(x_a_int, '02b')\n        assert mapping[x] == mapping[x_a], f\"Assertion failed: f({x}) != f({x_a})\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For each input x, the output is the same as for x XOR a (a = \"11\")\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in mapping:\n        x_xor_a = format(int(x, 2) ^ 0b11, '02b')\n        assert mapping[x] == mapping.get(x_xor_a, mapping[x]), f\"Outputs differ for x={x} and x⊕a={x_xor_a}: {mapping[x]} vs {mapping.get(x_xor_a)}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    a = 0b11\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for inputs in mapping:\n        x = int(inputs, 2)\n        x_xor_a = format(x ^ a, '02b')\n        if x_xor_a in mapping:\n            assert mapping[inputs] == mapping[x_xor_a], f\"Output mismatch: {inputs} -> {mapping[inputs]}, {x_xor_a} -> {mapping[x_xor_a]}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For each input x, check f(x) == f(x XOR a) where a = \"11\"\n    oracle_map = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        oracle_map[inputs] = outputs\n    a = \"11\"\n    for x in oracle_map:\n        x_xor_a = \"{:02b}\".format(int(x,2) ^ int(a,2))\n        assert oracle_map[x] == oracle_map[x_xor_a], f\"Assertion failed: Output mismatch for x={x} and x^a={x_xor_a}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For each input, check output equals output for input XOR a (a=\"11\")\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in mapping:\n        # XOR input x with a=\"11\"\n        x_int = int(x, 2)\n        a_int = 0b11\n        x_pair = format(x_int ^ a_int, '02b')\n        assert mapping[x] == mapping[x_pair], f\"Assertion failed: Output for {x} ({mapping[x]}) != Output for {x_pair} ({mapping[x_pair]})\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    a = '11'\n    for x in mapping:\n        x_xor_a = format(int(x, 2) ^ int(a, 2), '02b')\n        assert mapping[x] == mapping.get(x_xor_a, mapping[x]), f\"Outputs differ for {x} and {x_xor_a}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        mapping[inputs] = outputs\n    for inputs in mapping:\n        x = int(inputs, 2)\n        a = 0b11\n        x_xor_a = x ^ a\n        xor_inputs = format(x_xor_a, '02b')\n        assert mapping[inputs] == mapping.get(xor_inputs, mapping[inputs])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For each input x, check output equals output for x XOR a (with a = \"11\")\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in [\"00\", \"01\", \"10\", \"11\"]:\n        x_xor_a = \"{0:02b}\".format(int(x, 2) ^ int(\"11\", 2))\n        assert mapping[x] == mapping[x_xor_a], f\"Output for {x} != output for {x_xor_a}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    a = \"11\"\n    input_to_output = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        input_to_output[inputs] = outputs\n    for x in input_to_output:\n        x_xor_a = \"{:02b}\".format(int(x, 2) ^ int(a, 2))\n        if x_xor_a in input_to_output:\n            assert input_to_output[x] == input_to_output[x_xor_a], f\"Output mismatch: {x} vs {x_xor_a}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For each input x, check that output is same as for x XOR a (a = '11')\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in mapping:\n        x_xor_a = f\"{int(x, 2) ^ 0b11:02b}\"\n        assert mapping[x] == mapping[x_xor_a], f\"Output for x={x} and x XOR a={x_xor_a} differ: {mapping[x]} != {mapping[x_xor_a]}\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n\n    # >>> ASSERTION START\n    # Verify for each input x, the output matches that for x XOR a (a = '11')\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    a = '11'\n    for x in mapping:\n        x_xor_a = format(int(x, 2) ^ int(a, 2), '02b')\n        assert mapping[x] == mapping.get(x_xor_a, mapping[x]), f\"f({x}) != f({x_xor_a})\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # Check that for each input x, output == output for x XOR a (a=\"11\")\n    output_map = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        output_map[inputs] = outputs\n    for inputs in output_map:\n        # XOR with \"11\" (bitwise not): flip both bits\n        xora = \"{:02b}\".format(int(inputs, 2) ^ 0b11)\n        assert output_map[inputs] == output_map[xora], f\"Output mismatch: {inputs} vs {xora}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For hidden period a = \"11\"\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        mapping[inputs] = outputs\n    a = '11'\n    for x in mapping:\n        x_xor_a = format(int(x,2)^int(a,2),'02b')\n        if x_xor_a in mapping:\n            assert mapping[x] == mapping[x_xor_a], f\"f({x}) != f({x_xor_a}): {mapping[x]} vs {mapping[x_xor_a]}\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    a = 3  # hidden period \"11\"\n    input_to_output = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        input_to_output[inputs] = outputs\n    for x in input_to_output:\n        x_int = int(x, 2)\n        x_xor_a = format(x_int ^ a, '02b')\n        if x_xor_a in input_to_output:\n            assert input_to_output[x] == input_to_output[x_xor_a], f\"f({x}) != f({x_xor_a})\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For all x, output(x) == output(x XOR a), a = '11'\n    mapping = {}\n    for bitstring in counts.keys():\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in mapping:\n        a = \"{:02b}\".format(int('11', 2))\n        x_xor_a = \"{:02b}\".format(int(x, 2) ^ int(a, 2))\n        if x_xor_a in mapping:\n            assert mapping[x] == mapping[x_xor_a], f\"Assertion failed for x={x}, x^a={x_xor_a}: {mapping[x]} != {mapping[x_xor_a]}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    a = 0b11\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for x in mapping:\n        x_int = int(x, 2)\n        x_xor_a = format(x_int ^ a, '02b')\n        if x_xor_a in mapping:\n            assert mapping[x] == mapping[x_xor_a], f\"Assertion failed: f({x}) != f({x_xor_a})\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    a = '11'\n    input_to_output = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        input_to_output[inputs] = outputs\n    for inputs, outputs in input_to_output.items():\n        paired_input = format(int(inputs, 2) ^ int(a, 2), '02b')\n        if paired_input in input_to_output:\n            assert input_to_output[paired_input] == outputs, f\"Assertion failed: Input {inputs} and its pair {paired_input} do not map to the same output.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For hidden period a = \"11\", check f(x) == f(x XOR a)\n    input_output_map = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs  = bitstring[-2:]\n        input_output_map[inputs] = outputs\n    for inputs in input_output_map:\n        # XOR with \"11\" (i.e., flip both bits)\n        paired_inputs = '{:02b}'.format(int(inputs,2) ^ 0b11)\n        assert input_output_map[inputs] == input_output_map[paired_inputs], f\"Assertion failed for {inputs} and {paired_inputs}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For each input x, assert output for x == output for x XOR a (a=\"11\")\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    period = \"{0:02b}\".format(int(\"11\", 2))\n    for inputs in mapping:\n        x = int(inputs, 2)\n        a = int(period, 2)\n        x_xor_a = x ^ a\n        x_xor_a_bits = \"{0:02b}\".format(x_xor_a)\n        if x_xor_a_bits in mapping:\n            assert mapping[inputs] == mapping[x_xor_a_bits], f\"Assertion failed for inputs {inputs} and {x_xor_a_bits}: outputs {mapping[inputs]} vs {mapping[x_xor_a_bits]}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    a = \"11\"\n    for x in mapping:\n        x_xor_a = \"{:02b}\".format(int(x,2)^int(a,2))\n        assert mapping[x] == mapping.get(x_xor_a, mapping[x]), f\"Outputs differ for x={x}, x XOR a={x_xor_a}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB20",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n    # >>> ASSERTION START\n    # For hidden period a=\"11\", check that f(x) == f(x XOR a) for all observed x\n    mapping = {}\n    for bitstring in counts:\n        outputs = bitstring[:2]\n        inputs = bitstring[-2:]\n        mapping[inputs] = outputs\n    for inputs, outputs in mapping.items():\n        # XOR with \"11\" (i.e., flip both bits)\n        paired_inputs = \"\".join('1' if b == '0' else '0' for b in inputs)\n        if paired_inputs in mapping:\n            assert mapping[inputs] == mapping[paired_inputs], f\"Assertion failed: f({inputs}) != f({paired_inputs})\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) > (sum(output.values()) / len(output)), \"Measurement distribution appears uniform\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n    # >>> ASSERTION START\n    assert any(abs(cnt - sum(output.values())/len(output)) > 0.1 * sum(output.values())/len(output) for cnt in output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n    # >>> ASSERTION START\n    assert len(output) < 2 ** qft_runner.n\n    # <<< ASSERTION END\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) != min(output.values()), \"Measurement distribution is uniform\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    from collections import Counter\n    probs = [cnt / qft_runner.shots for cnt in output.values()]\n    uniform_prob = 1 / (2 ** qft_runner.n)\n    assert any(abs(p - uniform_prob) > 0.1 for p in probs)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) > int(qft_runner.shots / (2 ** qft_runner.n)) + 10\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    from scipy.stats import chisquare\n    assert chisquare(list(output.values()))[1] < 0.01\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert any(abs(cnt / qft_runner.shots - 1 / (2 ** qft_runner.n)) > 0.05 for cnt in output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # >>> ASSERTION START\n    assert any(abs((cnt / sum(output.values())) - (1/2**3)) > 0.05 for cnt in output.values())\n    # <<< ASSERTION END\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n    # >>> ASSERTION START\n    assert max(output.values()) > (sum(output.values()) // (2 ** qft_runner.n))\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n    # >>> ASSERTION START\n    assert max(output.values()) > sum(output.values()) // len(output)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # >>> ASSERTION START\n    assert any(abs(count / qft_runner.shots - 1/(2**qft_runner.n)) > 0.05 for count in output.values()), \"Output distribution appears uniform\"\n    # <<< ASSERTION END\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # >>> ASSERTION START\n    from statistics import variance\n    counts = list(output.values())\n    assert variance(counts) > 0, \"Measurement distribution is uniform, expected non-uniform.\"\n    # <<< ASSERTION END\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert any(abs((cnt / qft_runner.shots) - (1/2**qft_runner.n)) > 0.05 for cnt in output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # >>> ASSERTION START\n    assert max(output.values()) != min(output.values()), \"QFT output distribution is uniform, but should not be.\"\n    # <<< ASSERTION END\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    from collections import Counter\n    import numpy as np\n    probs = np.array([output.get(format(i, f'0{qft_runner.n}b'), 0) / qft_runner.shots for i in range(2**qft_runner.n)])\n    assert not np.allclose(probs, np.full_like(probs, 1.0/len(probs))), \"Output distribution is uniform\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # >>> ASSERTION START\n    assert any(abs((cnt / qft_runner.shots) - (1 / 8)) > 0.05 for cnt in output.values())\n    # <<< ASSERTION END\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # >>> ASSERTION START\n    probs = [v / sum(output.values()) for v in output.values()]\n    uniform_prob = 1 / 8\n    assert any(abs(p - uniform_prob) > 0.05 for p in probs)\n    # <<< ASSERTION END\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) / min(output.values()) > 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) != min(output.values()), \"Measurement distribution is uniform, but should not be.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    from collections import Counter\n    import numpy as np\n    probs = np.array([output.get(format(i, f'0{qft_runner.n}b'), 0) / qft_runner.shots for i in range(2 ** qft_runner.n)])\n    uniform = np.ones(2 ** qft_runner.n) / (2 ** qft_runner.n)\n    # Compute total variation distance\n    tvd = 0.5 * np.sum(np.abs(probs - uniform))\n    assert tvd > 0.1, \"Measurement distribution is too close to uniform\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    from collections import Counter\n    probs = [c / qft_runner.shots for c in output.values()]\n    uniform_prob = 1 / (2 ** qft_runner.n)\n    assert any(abs(p - uniform_prob) > 0.05 for p in probs)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    from collections import Counter\n    num_outcomes = 2 ** qft_runner.n\n    expected_uniform = qft_runner.shots / num_outcomes\n    counts = list(output.values())\n    assert any(abs(c - expected_uniform) > 0.2 * expected_uniform for c in counts)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    probs = [c / qft_runner.shots for c in output.values()]\n    uniform = 1 / (2 ** qft_runner.n)\n    assert any(abs(p - uniform) > 0.05 for p in probs)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # >>> ASSERTION START\n    assert max(output.values()) > (qft_runner.shots // (2 ** qft_runner.n))\n    # <<< ASSERTION END\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    # The measurement distribution should not be uniform; check using a simple chi-square approach.\n    import numpy as np\n    probs = np.array([output.get(format(i, '03b'), 0)/1024 for i in range(8)])\n    uniform = np.ones(8)/8\n    chi2 = np.sum((probs - uniform)**2 / (uniform + 1e-12))\n    assert chi2 > 0.1, \"Resulting measurement distribution is too close to uniform.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # >>> ASSERTION START\n    assert max(output.values()) > min(output.values())\n    # <<< ASSERTION END\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB21",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    probs = [v / qft_runner.shots for v in output.values()]\n    uniform = 1.0 / (2 ** qft_runner.n)\n    assert any(abs(p - uniform) > 0.1 for p in probs)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\" and counts[\"101\"] > 0\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\" and counts[\"101\"] > 0 and all(k == \"101\" or counts[k] == 0 for k in counts)\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")\n"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == '101'\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == '101'\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\" and counts[\"101\"] > 0\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\" and sum(counts.values()) == 1024\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")\n"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == '101'\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\" and counts[\"101\"] > 0\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")\n"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\", \"Output bitstring does not match prepared input state |101>\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")\n"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == '101'\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")\n"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == '101'\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")\n"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == '101' and counts['101'] > 0.9 * qft_runner.shots\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")\n"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\" and sum([k != \"101\" for k in counts]) == 0\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\" and counts[\"101\"] > 0.9 * sum(counts.values())\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\" and counts[\"101\"] > 0.8 * qft_runner.shots\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB22",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # >>> ASSERTION START\n    assert max(counts, key=counts.get) == \"101\"\n    # <<< ASSERTION END\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > sum(v for k, v in output.items() if k not in ['101', '110'])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get(\"101\", 0) + output.get(\"110\", 0) > sum(output.values()) / 2\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(s, 0) for s in ['101', '110']) > 0.8 * sum(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) >= int(0.9 * grover.shots), f\"Marked states not dominant: {output}\"\n    # <<< ASSERTION END\n    print(\"Grover search results (3 qubits):\", output)"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > sum(output.values()) * 0.5\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > sum(output.values()) * 0.6\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get(\"101\", 0) + output.get(\"110\", 0)) > 0.5 * sum(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > sum(output.values()) * 0.5\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(x, 0) for x in [\"101\", \"110\"]) > sum(output.get(x, 0) for x in output if x not in [\"101\", \"110\"])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(state, 0) for state in [\"101\", \"110\"]) > sum(output.values()) / 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > 0.8 * sum(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > 0.5 * sum(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > sum(output.values()) / 2\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > 0.6 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(state, 0) for state in ['101', '110']) > 0.5 * sum(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > sum(output.values()) / 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > sum(output.values()) * 0.6\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get(\"101\", 0) + output.get(\"110\", 0)) > sum(output.values()) / 2\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > 0.8 * sum(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get(\"101\",0) + output.get(\"110\",0) > 0.5 * sum(output.values()), \"Marked states are not dominant\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(k, 0) for k in [\"101\", \"110\"]) > grover.shots // 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get(\"101\", 0) + output.get(\"110\", 0) > sum(output.values()) / 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(s,0) for s in ['101', '110']) > 0.6 * sum(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > sum(output.values()) * 0.7\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > sum(output.values()) / 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get(\"101\", 0) + output.get(\"110\", 0) > sum(output.values()) / 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(s,0) for s in [\"101\", \"110\"]) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get(\"101\", 0) + output.get(\"110\", 0) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > sum(output.values()) / 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > 0.8 * sum(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(s, 0) for s in ['101', '110']) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > sum(output.values()) / 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(state, 0) for state in [\"101\", \"110\"]) > 0.5 * sum(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum([output.get(state, 0) for state in [\"101\", \"110\"]]) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(state, 0) for state in ['101', '110']) > 0.5 * sum(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > sum(output.values()) / 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(state, 0) for state in [\"101\", \"110\"]) > 0.6 * sum(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(x, 0) for x in ['101', '110']) > 0.5 * sum(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > sum(output.values()) / 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get(\"101\", 0) + output.get(\"110\", 0) > sum(output.values()) / 2\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(s, 0) for s in [\"101\", \"110\"]) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(state, 0) for state in ['101', '110']) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > 0.5 * sum(output.values())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > sum(output.values()) * 0.5\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB23",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > sum(output.values()) / 2\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        import numpy as np\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities()\n        assert np.allclose(probs, [1/8]*8, atol=0.05), \"Initial state is not approximately uniform.\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(qc)\n        probs = sv.probabilities()\n        assert all(abs(p - 1/8) < 0.01 for p in probs), \"Initial state is not uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities_dict()\n        expected = 1 / 2**self.n\n        assert all(np.isclose(p, expected, atol=0.01) for p in probs.values()), \"Initial state is not approximately uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        state = Statevector.from_instruction(qc)\n        probs = state.probabilities()\n        assert np.allclose(probs, np.full(2**self.n, 1/2**self.n), atol=0.05)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities()\n        assert all(abs(p - 1/8) < 0.01 for p in probs), \"Initial state is not approximately uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        state = np.asarray(qc.save_statevector().definition[0][1][0]._data)\n        uniform_prob = 1 / 8\n        assert np.allclose(np.abs(state)**2, [uniform_prob]*8, atol=1e-6)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities_dict()\n        uniform = 1 / 8\n        assert all(abs(probs.get(f\"{i:03b}\", 0) - uniform) < 1e-6 for i in range(8)), \"Initial state is not uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        import numpy as np\n        sv = Statevector.from_instruction(qc)\n        probs = np.abs(sv.data) ** 2\n        assert np.allclose(probs, np.full(2**self.n, 1/2**self.n), atol=1e-6), \"Initial state is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        psi = Statevector.from_instruction(qc)\n        probs = psi.probabilities()\n        assert np.allclose(probs, np.full(2**self.n, 1/2**self.n), atol=1e-6), \"Qubits not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities()\n        assert all(abs(p - 1/8) < 0.05 for p in probs), \"Initial state is not approximately uniform.\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = np.abs(sv.data) ** 2\n        assert np.allclose(probs, np.full(2 ** self.n, 1 / 2 ** self.n), atol=0.02)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities()\n        assert all(abs(p - 1/8) < 0.01 for p in probs), \"Initial state is not approximately uniform.\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        import numpy as np\n        state = Statevector.from_instruction(qc)\n        probs = state.probabilities()\n        assert np.allclose(probs, [1/8]*8, atol=0.05), \"Initial state is not approximately uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        state = np.asarray(qc.save_statevector().definition[0][1], dtype=complex) if hasattr(qc, \"save_statevector\") else None\n        if state is None:\n            from qiskit.quantum_info import Statevector\n            state = Statevector.from_instruction(qc).data\n        probs = np.abs(state) ** 2\n        assert np.allclose(probs, np.ones(2**self.n)/2**self.n, atol=1e-2), \"Initial state is not approximately uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities_dict()\n        assert all(abs(probs.get(f\"{i:03b}\", 0) - 1/8) < 0.05 for i in range(8))\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities()\n        assert np.allclose(probs, [1/8]*8, atol=0.05), \"Initial state is not approximately uniform.\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities()\n        assert np.allclose(probs, np.full(2**self.n, 1/2**self.n), atol=0.01)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        import numpy as np\n        sv = Statevector.from_instruction(qc)\n        probs = np.abs(sv.data) ** 2\n        assert np.allclose(probs, np.full(2 ** self.n, 1 / 2 ** self.n), atol=1e-2)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        import numpy as np\n        sv = Statevector.from_instruction(qc)\n        probs = np.abs(sv.data)**2\n        assert np.allclose(probs, np.full(2**self.n, 1/2**self.n), atol=1e-6)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities()\n        assert all(abs(p - 1/8) < 0.05 for p in probs), \"Initial state is not approximately uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        import numpy as np\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities()\n        assert np.allclose(probs, [1/8]*8, atol=0.02)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        state = Statevector.from_instruction(qc)\n        probabilities = np.abs(state.data) ** 2\n        assert np.allclose(probabilities, [1/8]*8, atol=0.02)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities()\n        assert all(abs(p - 1/8) < 0.01 for p in probs), \"Initial state is not approximately uniform.\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities_dict()\n        uniform_prob = 1 / 8\n        assert all(abs(p - uniform_prob) < 0.01 for p in probs.values()), \"Initial state is not approximately uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = np.abs(sv.data) ** 2\n        uniform = np.ones(2 ** self.n) / (2 ** self.n)\n        assert np.allclose(probs, uniform, atol=1e-6), \"Initial state is not uniformly distributed.\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = np.abs(sv.data)**2\n        assert np.allclose(probs, np.full(2**self.n, 1/2**self.n), atol=0.05)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = np.abs(sv.data) ** 2\n        assert np.allclose(probs, np.full(2 ** self.n, 1 / 2 ** self.n), atol=1e-5), \"Initial state is not uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities_dict()\n        uniform_prob = 1 / 2 ** self.n\n        assert all(abs(probs.get(format(i, f'0{self.n}b'), 0) - uniform_prob) < 1e-6 for i in range(2 ** self.n)), \"Initial state is not uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(qc)\n        probs = sv.probabilities()\n        assert all(abs(p - 1/8) < 1e-6 for p in probs), \"Initial state is not uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        svsim = Aer.get_backend('statevector_simulator')\n        qc_copy = qc.copy()\n        from qiskit import transpile\n        t_qc = transpile(qc_copy, svsim)\n        from qiskit.providers.aer import AerSimulator\n        job = svsim.run(t_qc)\n        sv = job.result().get_statevector()\n        probs = np.abs(sv) ** 2\n        assert np.allclose(probs, np.full(2 ** self.n, 1 / 8), atol=0.01)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities()\n        assert all(abs(p - 1/8) < 0.05 for p in probs), \"Initial superposition is not uniform enough\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = np.abs(sv.data) ** 2\n        assert np.allclose(probs, np.ones(2 ** self.n) / (2 ** self.n), atol=1e-6)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        state = Statevector.from_instruction(qc)\n        probs = np.abs(state.data) ** 2\n        assert np.allclose(probs, np.full(2 ** self.n, 1/8), atol=0.01)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities_dict()\n        uniform_prob = 1/8\n        assert all(abs(probs.get(format(i, '03b'), 0) - uniform_prob) < 1e-6 for i in range(8)), \"Superposition state is not uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        import numpy as np\n        state = Statevector.from_instruction(qc)\n        probs = np.abs(state.data) ** 2\n        assert np.allclose(probs, np.full(2 ** self.n, 1 / (2 ** self.n)), atol=1e-6)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities()\n        assert all(abs(p - 1/8) < 0.01 for p in probs), \"Qubits not in uniform superposition\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities_dict()\n        assert all(abs(p - 1/8) < 0.02 for p in probs.values())\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = np.abs(sv.data)**2\n        assert np.allclose(probs, np.ones(2**self.n)/(2**self.n), atol=1e-8), \"Initial state is not uniform superposition.\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n        # >>> ASSERTION START\n        assert (\n            (backend := Aer.get_backend(\"statevector_simulator\")) and\n            (sv := backend.run(transpile(qc, backend)).result().get_statevector()) is not None and\n            max(abs(abs(a)**2 - 1 / (2 ** self.n)) for a in sv) < 1e-6\n        ), \"Initial state is not approximately uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        import numpy as np\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities()\n        assert np.allclose(probs, np.ones(2**self.n)/2**self.n, atol=1e-6)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = sv.probabilities()\n        assert all(abs(p - 1/8) < 0.05 for p in probs), \"Initial state is not approximately uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        import numpy as np\n        sv = Statevector.from_instruction(qc)\n        probs = np.abs(sv.data) ** 2\n        assert np.allclose(probs, [1/8]*8, atol=1e-2), \"Initial state is not approximately uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        psi = Statevector.from_instruction(qc)\n        probs = psi.probabilities_dict()\n        assert all(abs(p - 1/8) < 0.01 for p in probs.values()), \"Initial state is not approximately uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n        # >>> ASSERTION START\n        from qiskit.quantum_info import Statevector\n        state = Statevector.from_instruction(qc)\n        probs = state.probabilities()\n        import numpy as np\n        assert np.allclose(probs, [1/8]*8, atol=1e-2)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        state = Statevector.from_instruction(qc)\n        probs = np.abs(state.data) ** 2\n        assert np.allclose(probs, np.full(2 ** self.n, 1/8), atol=1e-2), \"Qubits are not in a uniform superposition state.\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(qc)\n        probs = np.abs(sv.data) ** 2\n        assert np.allclose(probs, np.ones(2**self.n)/2**self.n, atol=0.05)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector(qc)\n        probs = np.abs(sv.data) ** 2\n        assert np.allclose(probs, np.full(8, 1/8), atol=1e-3)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        from qiskit.quantum_info import Statevector\n        sv = Statevector.from_instruction(qc)\n        probs = np.abs(sv.data) ** 2\n        assert np.allclose(probs, [1/8]*8, atol=0.05), \"Initial state is not approximately uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        state = np.array([1/np.sqrt(8)]*8)\n        assert np.allclose(np.abs(qc.get_statevector().data), state, atol=1e-6)\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # >>> ASSERTION START\n        import numpy as np\n        state = np.asarray(qc.save_statevector().definition[0][1])\n        expected_prob = 1/2**self.n\n        assert np.allclose(np.abs(state)**2, [expected_prob]*2**self.n, atol=1e-6), \"Initial state is not uniform\"\n        # <<< ASSERTION END\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    total = sum(output.values())\n    marked_probs = sum(output.get(state, 0) for state in [\"101\", \"110\"]) / total\n    assert marked_probs > 0.4, f\"Marked states do not dominate: probability is {marked_probs}\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > 0.4 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    marked_states = [\"101\", \"110\"]\n    total = sum(output.values())\n    prob_marked = sum(output.get(s, 0) for s in marked_states) / total\n    assert prob_marked > 0.4, f\"Marked states probability too low: {prob_marked}\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > 0.3 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get(\"101\", 0) + output.get(\"110\", 0) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    marked_states = ['101', '110']\n    marked_prob = sum(output.get(state, 0) for state in marked_states) / grover.shots\n    assert marked_prob > 0.5, f\"Marked state probability too low: {marked_prob}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101',0) / sum(output.values()) > 0.2 and output.get('110',0) / sum(output.values()) > 0.2\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > 2 * (grover.shots / 8), \"Marked states do not dominate after diffusion operator\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    marked = ['101', '110']\n    marked_counts = sum(output.get(state, 0) for state in marked)\n    assert marked_counts / sum(output.values()) > 0.35\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    marked_states = ['101', '110']\n    marked_counts = sum(output.get(bitstr, 0) for bitstr in marked_states)\n    assert marked_counts > 0.4 * grover.shots, \"Marked states do not dominate measurement outcomes after diffusion.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(x, 0) for x in [\"101\", \"110\"]) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    marked_states = ['101', '110']\n    total_shots = sum(output.values())\n    marked_counts = sum(output.get(s, 0) for s in marked_states)\n    assert marked_counts / total_shots > 0.5, \"Marked states do not dominate after diffusion operator\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get(\"101\",0) + output.get(\"110\",0)) > 0.4 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(x, 0) for x in [\"101\", \"110\"]) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(s, 0) for s in [\"101\", \"110\"]) > 0.5 * grover.shots\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > (0.4 * grover.shots)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(x, 0) for x in (\"101\", \"110\")) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    marked = ['101', '110']\n    total = sum(output.values())\n    marked_prob = sum(output.get(state, 0) for state in marked) / total\n    assert marked_prob > 0.6, f\"Marked states probability {marked_prob} not significantly larger than uniform (0.25)\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(s,0) for s in [\"101\",\"110\"]) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101',0) + output.get('110',0)) > 0.4 * grover.shots\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > 0.4 * grover.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > 0.4 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > 0.4 * grover.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get(\"101\", 0) + output.get(\"110\", 0) > 0.5 * grover.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get(\"101\", 0) + output.get(\"110\", 0)) > 0.4 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    marked_states = ['101', '110']\n    total_counts = sum(output.values())\n    marked_counts = sum([output.get(s, 0) for s in marked_states])\n    assert marked_counts / total_counts > 0.35\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get(\"101\", 0) + output.get(\"110\", 0) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get(\"101\", 0) + output.get(\"110\", 0) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    marked_states = ['101', '110']\n    marked_prob = sum(output.get(s, 0) for s in marked_states) / sum(output.values())\n    assert marked_prob > 0.5, f\"Marked states probability {marked_prob} not significantly higher than uniform (should be >0.5)\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101',0)+output.get('110',0))/(sum(output.values())) > 0.4\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(s, 0) for s in [\"101\", \"110\"]) > 0.4 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(s, 0) for s in ['101', '110']) > 2 * grover.shots / 8\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101',0) + output.get('110',0)) > 0.4 * grover.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    total = sum(output.values())\n    marked_states = [\"101\", \"110\"]\n    marked_counts = sum([output.get(state, 0) for state in marked_states])\n    assert marked_counts / total > 0.5, \"Marked states do not dominate after diffusion operator.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > 0.6 * grover.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > 2 * (grover.shots / 8)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    marked_states = ['101', '110']\n    total_marked = sum(output.get(state, 0) for state in marked_states)\n    total = sum(output.values())\n    assert total_marked / total > 0.5, \"Marked states do not dominate the measurement outcomes.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    marked_states = [\"101\", \"110\"]\n    marked_counts = sum(output.get(s, 0) for s in marked_states)\n    total_counts = sum(output.values())\n    assert marked_counts / total_counts > 2 * (len(marked_states) / 8)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > 0.50 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get('101', 0) + output.get('110', 0) > 0.5 * grover.shots\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(state, 0) for state in ['101', '110']) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(s,0) for s in [\"101\",\"110\"]) > 0.3 * grover.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert output.get(\"101\", 0) + output.get(\"110\", 0) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get('101', 0) + output.get('110', 0)) > 0.5 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(x, 0) for x in ['101', '110']) > 0.4 * sum(output.values())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get(\"101\", 0) + output.get(\"110\", 0)) > 0.4 * grover.shots\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert (output.get(\"101\", 0) + output.get(\"110\", 0)) > 0.4 * grover.shots\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB25",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n    # >>> ASSERTION START\n    assert sum(output.get(x, 0) for x in ['101', '110']) > (0.5 * sum(output.values()))\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(key[-3:], 2) in [0, 2, 4, 6] for key in output), \"Measurement outcomes do not show expected period r=4\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(k[::-1][:3], 2) in [0, 2, 4, 6] for k in output.keys())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any('{:03b}'.format(i) in [k[-3:] for k in output.keys()] for i in [0,2,4,6]), \"Measurement outcomes do not include expected multiples of 2\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(k[-3:], 2) % 2 == 0 for k in output), \"No multiples of 2 found in measurement outcomes\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(bitstring[-3:], 2) % 2 == 0 for bitstring in output)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(bitstring[-3:], 2) % 2 == 0 for bitstring in output.keys())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(key[-3:], 2) % 2 == 0 for key in output.keys())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(bin(int(bits[:3][::-1], 2)).count('1') == 1 for bits in output if int(bits[:3][::-1], 2) % 2 == 0)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(key[0:3][::-1], 2) % 2 == 0 for key in output), \"No period-4 multiples found in measurement outcomes\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(key[0:3] in ['000', '010', '100', '110'] for key in output.keys())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(bitstring[-3:], 2) % 2 == 0 for bitstring in output), \"No multiples of 2 found in 3-bit measurement outcomes.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(key[-3:], 2) % 2 == 0 for key in output.keys())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(bits[-3:], 2) % 2 == 0 for bits in output), \"No multiples of 2 measured in 3-bit register\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(x[-3:] in {'000', '010', '100', '110'} for x in output), \"Measured results do not show expected period multiples in 3-bit register\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(bitstr[-3:], 2) in [0, 2, 4, 6] for bitstr in output)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(all(bit in k[-3:] for bit in ['000','010','100','110']) for k in [ ''.join([format(i,'03b') for i in [0,1,2]]) ]) or all(state in output for state in ['000','010','100','110'])\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(state[-3:], 2) % 2 == 0 for state in output), \"Measurement outcomes do not include multiples of 2 in the 3-bit register\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(k[-3:] in {'000', '010', '100', '110'} for k in output), \"No period-4 state found in measurement outcomes.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(bitstring[:3][::-1], 2) in [0, 2, 4, 6] for bitstring in output), \"Expected 3-bit measurement outcomes to include multiples of 2\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(\n        int(bitstring[-3:], 2) in {0, 2, 4, 6} for bitstring in output\n    ), \"Measurement outcomes do not include expected multiples of 2 in the 3-bit register.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(k[-3:] in {\"000\", \"010\", \"100\", \"110\"} for k in output), \"Measurement outcomes do not include required periodic states\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any((int(k[-3:], 2) % 2 == 0) for k in output), \"No measurement outcome corresponds to a multiple of 2 in the 3-bit register\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(bin(int(key, 2))[2:].zfill(3) in ['000', '010', '100', '110'] for key in output.keys()), \"Measurement outcomes do not include expected period states.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(bitstr[-3:], 2) in [0, 2, 4, 6] for bitstr in output), \"Expected periodic states not found in measurement outcomes\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(count > 0 for key, count in output.items() if int(key[-3:], 2) in [0, 2, 4, 6])\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(count for state, count in output.items() if int(state[:3][::-1], 2) % 2 == 0), \"Measurement outcomes do not include expected period-multiples in 3-bit register.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(key[-3:], 2) % 2 == 0 for key in output), \"No multiples of 2 found in measurement outcomes\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(k[-3:], 2) in [0, 2, 4, 6] for k in output)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(k[:3] in {\"000\", \"010\", \"100\", \"110\"} for k in output.keys())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(state[-3:], 2) % 2 == 0 for state in output), \"Measurement outcomes do not include multiples of 2 within the 3-bit register.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(\n        (k[::-1][:3] in {\"000\", \"010\", \"100\", \"110\"}) for k in output.keys()\n    ), \"Measurement outcomes do not include expected periodic states (multiples of 2 in 3-bit register)\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(k[-3:], 2) % 2 == 0 for k in output), \"Measurement outcomes do not include states corresponding to multiples of 2.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(key[-3:] in {\"000\", \"010\", \"100\", \"110\"} for key in output), \"Measurement outcomes do not include expected periodic states for r=4.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(k[-3:], 2) % 2 == 0 for k in output), \"No outcome corresponds to a multiple of 2 in the 3-bit register\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(bin(int(k[:3][::-1], 2)).count('1') == 1 and int(k[:3][::-1], 2) % 2 == 0 for k in output), \"No expected periodic outcomes found\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(k[:3][::-1], 2) % 2 == 0 for k in output.keys())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(b in output for b in ['000', '010', '100', '110']), \"Measurement outcomes do not include expected period multiples\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(k[-3:], 2) % 2 == 0 for k in output), \"No expected periodic measurement outcome found\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(key[-3:], 2) in [0, 2, 4, 6] for key in output), \"Measurement results do not include expected period multiples in 3-bit register\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(key[-3:], 2) % 2 == 0 for key in output.keys())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(key[-3:], 2) in [0, 2, 4, 6] for key in output.keys()), \"No measurement outcome corresponds to multiples of 2 in the 3-bit register.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(k[-3:], 2) % 2 == 0 for k in output.keys())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(key[-3:] in {'000', '010', '100', '110'} for key in output), \"No period-4 states found in measurement outcomes\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(k[:3], 2) % 2 == 0 for k in output.keys())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(bits[:3][::-1], 2) % 2 == 0 for bits in output), \"No measurement outcome corresponds to multiples of 2 in the 3-bit register.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(key[-3:], 2) % 2 == 0 for key in output)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(k[-3:] in ['000', '010', '100', '110'] for k in output), \"Expected periodic states not found in measurement outcomes\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(bitstr[-3:], 2) % 2 == 0 for bitstr in output.keys())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(key[:3] in ['000','010','100','110'] for key in output), \"Expected measurement outcomes with periodicity r=4 not found.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB26",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n    # >>> ASSERTION START\n    assert any(int(key[:3][::-1], 2) % 2 == 0 for key in output), \"Results do not contain expected multiples of 2 in 3-bit register\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction(x, N):\n        cf = []\n        while x and len(cf) < 10:\n            a = x // N\n            cf.append(a)\n            x, N = N, x - a * N\n        return cf\n\n    def convergents(cf):\n        n0, d0 = 1, 0\n        n1, d1 = cf[0], 1\n        convs = [(n1, d1)]\n        for a in cf[1:]:\n            n2 = a * n1 + n0\n            d2 = a * d1 + d0\n            convs.append((n2, d2))\n            n0, d0 = n1, d1\n            n1, d1 = n2, d2\n        return convs\n\n    measured = max(output, key=output.get)\n    s = int(measured, 2)\n    Q = 2 ** shor.n\n    cf = continued_fraction(s, Q)\n    conv = convergents(cf)\n    r_candidates = [d for (n, d) in conv if d > 0 and d < Q]\n    assert 2 in r_candidates\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    # >>> ASSERTION START\n    assert any(__import__(\"fractions\").Fraction(int(k, 2), 2**shor.n).limit_denominator(2**shor.n).denominator == 2 for k, c in output.items() if c > 0), \"Continued fraction post-processing failed to recover period r=2\"\n    # <<< ASSERTION END\n    print(\"Shor simplified period finding measurement:\", output)"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    # >>> ASSERTION START\n    assert any(__import__(\"fractions\").Fraction(int(k, 2), 2 ** shor.n).limit_denominator(2 ** shor.n).denominator == 2 for k in output), \"Continued fraction failed to recover period r=2\"\n    # <<< ASSERTION END\n    print(\"Shor simplified period finding measurement:\", output)"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction_expansion(x, N, max_denominator=15):\n        quotients = []\n        while x and len(quotients) < 20:\n            a = int(x)\n            quotients.append(a)\n            x -= a\n            if x == 0:\n                break\n            x = 1 / x\n        # Compute convergents\n        n0, d0 = 0, 1\n        n1, d1 = 1, 0\n        for q in quotients:\n            n2 = q * n1 + n0\n            d2 = q * d1 + d0\n            n0, d0 = n1, d1\n            n1, d1 = n2, d2\n            if d2 > max_denominator:\n                break\n        return d1\n\n    measured = max(output, key=output.get)\n    N = 2 ** shor.n\n    x = int(measured, 2)\n    frac = x / N\n    r = continued_fraction_expansion(frac, N)\n    assert r == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n\n    # >>> ASSERTION START\n    from fractions import Fraction\n    measured_bitstring = max(output, key=output.get)\n    measured_value = int(measured_bitstring, 2)\n    N = 2 ** shor.n\n    frac = Fraction(measured_value, N).limit_denominator(N)\n    if frac.denominator == 1:\n        recovered_r = 1\n    else:\n        recovered_r = frac.denominator\n    assert recovered_r == 2\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction(x, N):\n        \"\"\"Return denominator of the best rational approximation of x with denominator <= N.\"\"\"\n        from fractions import Fraction\n        return Fraction(x).limit_denominator(N).denominator\n\n    n = shor.n\n    N = 2 ** n\n    # Get the most frequent measurement outcome\n    measured_str = max(output, key=output.get)\n    measured_int = int(measured_str, 2)\n    frac = measured_int / N\n    # The \"oracle\" is set up for period r=2\n    r_true = 2\n    r_found = continued_fraction(frac, N)\n    assert r_found == r_true, f\"Recovered period {r_found}, expected {r_true}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    # Identify the highest-probability measurement outcome\n    measured_str = max(output, key=output.get)\n    measured_int = int(measured_str, 2)\n    N = 2 ** shor.n\n    measured_frac = measured_int / N\n    # Continued fraction expansion to find r\n    def continued_fraction(x, max_denominator):\n        from fractions import Fraction\n        return Fraction(x).limit_denominator(max_denominator).denominator\n    r_found = continued_fraction(measured_frac, N)\n    assert r_found == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    from fractions import Fraction\n    measured = max(output, key=output.get)\n    measured_int = int(measured, 2)\n    N = 2 ** shor.n\n    frac = Fraction(measured_int, N).limit_denominator(15)\n    r_recovered = frac.denominator\n    assert r_recovered == 2\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    # Known period for this simplified circuit is r = 2\n    def continued_fraction(numerator, denominator, max_denominator):\n        from fractions import Fraction\n        frac = Fraction(numerator, denominator).limit_denominator(max_denominator)\n        return frac.denominator\n\n    measured = max(output, key=output.get)  # Most probable measurement\n    s = int(measured, 2)\n    N = 2 ** shor.n\n    found_r = continued_fraction(s, N, N)\n    assert found_r == 2, f\"Recovered period {found_r}, expected 2\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    most_probable = max(output, key=output.get)\n    measured_int = int(most_probable, 2)\n    N = 2 ** shor.n\n    frac = measured_int / N\n    # Continued fraction expansion to estimate denominator\n    def cont_frac(x, max_denom):\n        h1, h2, k1, k2 = 1, 0, 0, 1\n        b = x\n        while True:\n            a = int(b)\n            h = a * h1 + h2\n            k = a * k1 + k2\n            if k > max_denom or b - a == 0:\n                break\n            h2, h1 = h1, h\n            k2, k1 = k1, k\n            b = 1 / (b - a)\n        return k1\n    r_est = cont_frac(frac, N)\n    assert r_est == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    # We expect peaks at multiples of 2 (binary: 000, 010, 100, 110) => decimals: 0, 2, 4, 6\n    # For each outcome, estimate r by continued fractions and check r==2\n    def continued_fraction_solve(y, nbits):\n        Q = 2**nbits\n        frac = y / Q\n        # continued fraction expansion to get denominator\n        # (use fractions module for quick convergents)\n        from fractions import Fraction\n        convergent = Fraction(frac).limit_denominator(Q)\n        if convergent.denominator == 0:\n            return None\n        return convergent.denominator\n\n    expected_r = 2\n    nbits = shor.n\n    for outcome in output.keys():\n        y = int(outcome, 2)\n        if y == 0:\n            continue\n        r = continued_fraction_solve(y, nbits)\n        assert r == expected_r, f\"Period recovery failed for outcome {outcome}: got r={r}, expected {expected_r}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction(x, Q, max_den=16):\n        \"\"\"Compute the denominator from continued fraction expansion for x/Q.\"\"\"\n        a = []\n        q = x / Q\n        while True:\n            ai = int(q)\n            a.append(ai)\n            frac = q - ai\n            if frac < 1e-8 or len(a) > 10:\n                break\n            q = 1 / frac\n\n        num1, denom1 = 1, 0\n        num2, denom2 = a[0], 1\n        for ai in a[1:]:\n            num_next = ai * num2 + num1\n            denom_next = ai * denom2 + denom1\n            if denom_next > max_den:\n                break\n            num1, denom1 = num2, denom2\n            num2, denom2 = num_next, denom_next\n        return denom2\n\n    n = 3\n    Q = 2 ** n\n    # Simulated circuit produces peaks at s = 0 and s = 4 for 3 qubits (r=2)\n    # Find the most probable measurement (ignore trivial s=0)\n    most_common = sorted([(int(k, 2), v) for k, v in output.items() if int(k,2)!=0], key=lambda x: -x[1])[0][0]\n    recovered_r = continued_fraction(most_common, Q)\n    assert recovered_r == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction(x, N):\n        a = []\n        while x != 0 and len(a) < 20:\n            q = int(N // x)\n            a.append(q)\n            x, N = N % x, x\n        num, den = 1, 0\n        for q in reversed(a):\n            num, den = den + num * q, num\n        return num, den\n\n    n = shor.n\n    shots = shor.shots\n    counts = output\n    max_bin = max(counts, key=counts.get)\n    s = int(max_bin, 2)\n    Q = 2 ** n\n    frac = s / Q\n    _, r_candidate = continued_fraction(s, Q)\n    assert r_candidate == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n\n    # >>> ASSERTION START\n    def continued_fraction_expansion(x, N):\n        a = []\n        while x != 0 and len(a) < 20:\n            q = N // x\n            a.append(q)\n            x, N = N % x, x\n        return a\n\n    def convergents(a):\n        n = len(a)\n        convs = []\n        for i in range(n):\n            num, den = 1, 0\n            for j in reversed(range(i + 1)):\n                num, den = a[j]*num + den, num\n            convs.append((num, den))\n        return convs\n\n    n = shor.n\n    N = 2 ** n\n    # Expect period r = 2 for this oracle\n    true_r = 2\n    # Find the most frequent measurement outcome\n    most_common = max(output, key=output.get)\n    s = int(most_common, 2)\n    frac = s / N\n    cf = continued_fraction_expansion(s, N)\n    convs = convergents(cf)\n    recovered_r = None\n    for num, den in convs:\n        if den > 0 and abs(frac - num/den) < 1/(2*N):\n            recovered_r = den\n            break\n    assert recovered_r == true_r\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    # Extract the most probable outcome\n    measured_str = max(output, key=output.get)\n    measured = int(measured_str, 2)\n    N = 2 ** shor.n\n    frac = measured / N\n\n    # Continued fraction expansion to guess r\n    def continued_fraction(x, max_den=15):\n        p0, q0 = 0, 1\n        p1, q1 = 1, 0\n        a = math.floor(x)\n        x0 = x\n        while True:\n            a = int(math.floor(x0))\n            q2 = a * q1 + q0\n            if q2 > max_den:\n                break\n            p2 = a * p1 + p0\n            p0, q0 = p1, q1\n            p1, q1 = p2, q2\n            x0 = 1 / (x0 - a) if x0 - a != 0 else 0\n            if x0 == 0:\n                break\n        return q1\n\n    r_recovered = continued_fraction(frac)\n    assert r_recovered == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n\n    # >>> ASSERTION START\n    from fractions import Fraction\n    n = shor.n\n    N = 2 ** n\n    period = 2  # Expected period in this circuit\n    # Find the most frequent measurement outcome\n    measured = max(output.items(), key=lambda x: x[1])[0]\n    k = int(measured, 2)\n    if k == 0:\n        # Should not happen, but if so, do not assert\n        recovered_r = None\n    else:\n        frac = Fraction(k, N).limit_denominator(N)\n        # Try denominators from continued fraction\n        recovered_r = frac.denominator\n    assert recovered_r == period, f\"Continued fraction failed: got {recovered_r}, expected {period}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n\n    most_common = max(output.items(), key=lambda x: x[1])[0]\n    measured_int = int(most_common, 2)\n    N = 2 ** shor.n\n    x_over_N = measured_int / N\n\n    def continued_fraction_expansion(x, max_denominator):\n        from fractions import Fraction\n        return Fraction(x).limit_denominator(max_denominator)\n\n    frac = continued_fraction_expansion(x_over_N, N)\n    recovered_r = frac.denominator\n\n    # >>> ASSERTION START\n    assert recovered_r == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n\n    # >>> ASSERTION START\n    def continued_fraction(num, denom, max_depth=10):\n        cf = []\n        for _ in range(max_depth):\n            if denom == 0:\n                break\n            q = num // denom\n            cf.append(q)\n            num, denom = denom, num - q * denom\n        return cf\n\n    def convergents_from_cf(cf):\n        n0, d0 = 1, 0\n        n1, d1 = cf[0], 1\n        res = [(n1, d1)]\n        for q in cf[1:]:\n            n2 = q * n1 + n0\n            d2 = q * d1 + d0\n            res.append((n2, d2))\n            n0, d0 = n1, d1\n            n1, d1 = n2, d2\n        return res\n\n    measured_bit = max(output, key=output.get)\n    s = int(measured_bit, 2)\n    N = 2 ** shor.n\n    cf = continued_fraction(s, N)\n    convergents = convergents_from_cf(cf)\n    periods = [d for (_, d) in convergents if d > 0 and d < N]\n    recovered_r = None\n    true_r = 2  # hardcoded: the circuit's periodicity is 2\n    for r in periods:\n        if pow(2, r, 15) == 1:\n            recovered_r = r\n            break\n    assert recovered_r == true_r\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    from fractions import Fraction\n    n = 3\n    expected_r = 2\n    most_common = max(output.items(), key=lambda x: x[1])[0]\n    s = int(most_common, 2)\n    N = 2 ** n\n    frac = Fraction(s, N).limit_denominator(N)\n    recovered_r = frac.denominator\n    assert recovered_r == expected_r, f\"Recovered period {recovered_r} != expected {expected_r}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    # Find the most probable outcome\n    measured = max(output, key=output.get)\n    measured_int = int(measured, 2)\n    N = 2 ** shor.n\n    x = measured_int / N\n    # Continued fraction to find denominator r\n    def continued_fraction(x, max_denominator=15):\n        from fractions import Fraction\n        return Fraction(x).limit_denominator(max_denominator).denominator\n    recovered_r = continued_fraction(x)\n    assert recovered_r == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction_expansion(y, N):\n        \"\"\"Compute the denominator of y/N as a continued fraction approximation.\"\"\"\n        from fractions import Fraction\n        return Fraction(y, N).limit_denominator(N).denominator\n\n    n = shor.n\n    N = 2 ** n\n    most_common = max(output, key=output.get)\n    y = int(most_common, 2)\n    r_cf = continued_fraction_expansion(y, N)\n    r_true = 2  # For this circuit, period is 2\n    assert r_cf == r_true, f\"Recovered period {r_cf} does not match expected {r_true}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    # Find the most probable outcome\n    outcome = max(output, key=output.get)\n    measured_int = int(outcome, 2)\n    N = 2 ** shor.n\n    frac = measured_int / N\n    def continued_fraction(x, max_denominator=15):\n        from fractions import Fraction\n        return Fraction(x).limit_denominator(max_denominator)\n    frac_approx = continued_fraction(frac)\n    r_candidate = frac_approx.denominator\n    assert r_candidate == 2, f\"Recovered period {r_candidate} does not match expected period 2\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction_expansion(x, q_max):\n        \"\"\"Compute the denominator of the best rational approximation to x with denominator <= q_max\"\"\"\n        from fractions import Fraction\n        frac = Fraction(x).limit_denominator(q_max)\n        return frac.denominator\n\n    n = shor.n\n    N = 2 ** n\n    most_likely = max(output, key=output.get)\n    phase = int(most_likely, 2) / N\n    recovered_r = continued_fraction_expansion(phase, N)\n    assert recovered_r == 2, f\"Recovered period r={recovered_r}, expected 2\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    # Find the most probable output bitstring\n    measured = max(output, key=output.get)\n    measured_int = int(measured, 2)\n    N = 2 ** shor.n\n    x_over_N = measured_int / N\n    # Continued fraction to recover r\n    def cont_frac(x, max_den):\n        a = []\n        q = x\n        for _ in range(10):\n            if q == 0:\n                break\n            ai = int(1 / q)\n            a.append(ai)\n            q = 1 / q - ai\n        # Convert a to convergents\n        num1, num2 = 1, 0\n        den1, den2 = 0, 1\n        for ai in a:\n            num = ai * num1 + num2\n            den = ai * den1 + den2\n            if den > max_den:\n                break\n            num2, num1 = num1, num\n            den2, den1 = den1, den\n        return den1\n    recovered_r = cont_frac(x_over_N, 15)\n    assert recovered_r == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction(x, N):\n        cf = []\n        while x and len(cf) < 10:\n            a = int(x)\n            cf.append(a)\n            if x == a:\n                break\n            x = 1/(x - a)\n        num, denom = 1, 0\n        for a in reversed(cf):\n            num, denom = denom + a * num, num\n        return num, denom\n\n    N = 2 ** shor.n\n    most_common = max(output, key=output.get)\n    s = int(most_common, 2)\n    frac = s / N\n    num, denom = continued_fraction(frac, N)\n    r_true = 2\n    assert denom == r_true\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction_expansion(x, Q, max_denominator=15):\n        fractions = []\n        q = x / Q\n        while q != int(q):\n            a = int(q)\n            fractions.append(a)\n            q = 1 / (q - a)\n            if len(fractions) > 10:\n                break\n        num1, denom1 = 1, 0\n        num2, denom2 = fractions[0], 1\n        for a in fractions[1:]:\n            num = a * num2 + num1\n            denom = a * denom2 + denom1\n            num1, denom1 = num2, denom2\n            num2, denom2 = num, denom\n            if denom2 > max_denominator:\n                break\n        return denom2\n\n    Q = 2 ** shor.n\n    most_likely = max(output.items(), key=lambda kv: kv[1])[0]\n    measured = int(most_likely, 2)\n    r_est = continued_fraction_expansion(measured, Q)\n    assert r_est == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction_expansion(x, Q):\n        \"\"\"Continued fraction expansion to approximate x/Q as s/r with r<=Q\"\"\"\n        a = []\n        q = Q\n        frac = x / Q\n        while True:\n            ai = int(math.floor(frac))\n            a.append(ai)\n            frac = 1/(frac - ai) if frac - ai != 0 else 0\n            if frac == 0 or len(a) > 20:\n                break\n        # Now build convergents\n        num, denom = 1, 0\n        for ai in reversed(a):\n            num, denom = denom + ai*num, num\n        return num, denom\n\n    measured_bitstring = max(output, key=lambda k: output[k])\n    x = int(measured_bitstring, 2)\n    Q = 2 ** shor.n\n    _, r_candidate = continued_fraction_expansion(x, Q)\n    r_true = 2\n    assert r_candidate == r_true, f\"Recovered period r={r_candidate}, expected r={r_true}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction(x, Q, max_denominator):\n        \"\"\"Compute the denominator r from x/Q using continued fractions up to max_denominator.\"\"\"\n        a = []\n        q = x / Q\n        for _ in range(20):\n            if abs(q - round(q)) < 1e-8:\n                a.append(int(round(q)))\n                break\n            a.append(int(math.floor(q)))\n            q = 1 / (q - a[-1])\n        # Now compute convergents\n        n0, d0 = 1, 0\n        n1, d1 = a[0], 1\n        for ai in a[1:]:\n            n2 = ai * n1 + n0\n            d2 = ai * d1 + d0\n            if d2 > max_denominator:\n                break\n            n0, d0 = n1, d1\n            n1, d1 = n2, d2\n        return d1\n    n_count = shor.n\n    N = 2 ** n_count\n    measured_str = max(output, key=output.get)\n    measured = int(measured_str, 2)\n    r_recovered = continued_fraction(measured, N, 15)\n    assert r_recovered == 2\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction(numerator, denominator, max_denominator):\n        cf = []\n        while denominator:\n            q = numerator // denominator\n            cf.append(q)\n            numerator, denominator = denominator, numerator - q * denominator\n        # Rebuild fraction with convergents\n        def convergent(cf):\n            num, den = 1, 0\n            for a in reversed(cf):\n                num, den = den + num * a, num\n            return num, den\n        for i in range(1, len(cf)+1):\n            num_c, den_c = convergent(cf[:i])\n            if den_c <= max_denominator and den_c != 0:\n                yield num_c, den_c\n    n = 3\n    N = 2 ** n\n    # Period is 2 for this toy example (see oracle)\n    true_r = 2\n    max_key = max(output, key=output.get)\n    s = int(max_key, 2)\n    found_r = None\n    for num_c, den_c in continued_fraction(s, N, N):\n        if den_c != 0 and abs(s / N - num_c / den_c) < 1/(2*N):\n            found_r = den_c\n            break\n    assert found_r == true_r\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction(x, Q, max_denominator):\n        \"\"\"Compute denominator r of the best rational approximation s/r of x, with r ≤ max_denominator.\"\"\"\n        # x is a float, Q is the number of possible measurement outcomes (2^n)\n        a = []\n        q = x\n        for _ in range(20):\n            if abs(q - round(q)) < 1e-12:\n                a.append(int(round(q)))\n                break\n            ai = int(math.floor(q))\n            a.append(ai)\n            q = 1/(q - ai)\n        num1, num2 = 1, 0\n        den1, den2 = 0, 1\n        for ai in a:\n            num = ai*num1 + num2\n            den = ai*den1 + den2\n            if den > max_denominator:\n                break\n            num2, num1 = num1, num\n            den2, den1 = den1, den\n        return den1\n\n    n = shor.n\n    Q = 2**n\n    # The circuit simulates period r=2, so expect large counts only at even k.\n    measured_bits = [int(k, 2) for k in output if output[k] > 0]\n    # Pick the most probable outcome\n    most_common = max(output, key=lambda k: output[k])\n    k = int(most_common, 2)\n    frac = k / Q\n    recovered_r = continued_fraction(frac, Q, Q)\n    assert recovered_r == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    # extract the most frequent measurement outcome\n    most_common_bitstring = max(output, key=output.get)\n    s = int(most_common_bitstring, 2)\n    N = 2 ** shor.n\n    x = s / N\n    # continued fraction expansion to find r\n    def continued_fraction(x, max_denominator):\n        from fractions import Fraction\n        return Fraction(x).limit_denominator(max_denominator).denominator\n    recovered_r = continued_fraction(x, N)\n    assert recovered_r == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    # r is the true period (2 for the simulated circuit), post-process the most probable output.\n    most_probable = max(output, key=output.get)\n    x = int(most_probable, 2)\n    N = 2 ** shor.n\n    frac = x / N\n    def continued_fraction(num, denom, max_depth=20):\n        cf = []\n        for _ in range(max_depth):\n            if denom == 0:\n                break\n            a = num // denom\n            cf.append(a)\n            num, denom = denom, num - a * denom\n            if denom == 0:\n                break\n        return cf\n    def convergents(cf):\n        convs = []\n        n0, d0 = cf[0], 1\n        convs.append((n0, d0))\n        if len(cf) == 1:\n            return convs\n        n1 = cf[1]*cf[0]+1\n        d1 = cf[1]\n        convs.append((n1, d1))\n        for k in range(2, len(cf)):\n            n = cf[k]*convs[-1][0]+convs[-2][0]\n            d = cf[k]*convs[-1][1]+convs[-2][1]\n            convs.append((n, d))\n        return convs\n    cf = continued_fraction(x, N)\n    convs = convergents(cf)\n    r = 2\n    found = False\n    for num, denom in convs:\n        if denom > 0 and abs(frac - num/denom) < 1/(2*N) and denom == r:\n            found = True\n            break\n    assert found, \"Continued fraction failed to recover period r=2\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    # Post-process: Find the most frequent measurement\n    measured = max(output, key=output.get)\n    N = 2 ** shor.n\n    s = int(measured, 2)\n    x = s / N\n\n    # Continued fraction expansion to estimate period r\n    def continued_fraction(x, max_denominator):\n        a = []\n        q = x\n        for _ in range(10):\n            if q == 0:\n                break\n            ai = int(1.0 / q)\n            a.append(ai)\n            q = 1.0 / q - ai\n        # Reconstruct denominator\n        num1, num2 = 1, 0\n        den1, den2 = 0, 1\n        for ai in a:\n            num = ai * num1 + num2\n            den = ai * den1 + den2\n            if den > max_denominator:\n                break\n            num2, num1 = num1, num\n            den2, den1 = den1, den\n        return den1\n\n    recovered_r = continued_fraction(x, N)\n    assert recovered_r == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction(numerator, denominator, max_denominator):\n        from fractions import Fraction\n        frac = Fraction(numerator, denominator).limit_denominator(max_denominator)\n        return frac.denominator\n    n = shor.n\n    period_true = 2\n    bitstrings = list(output.keys())\n    s = max(bitstrings, key=lambda x: output[x])\n    s_decimal = int(s, 2)\n    measured = s_decimal / (2 ** n)\n    recovered_r = continued_fraction(s_decimal, 2 ** n, 15)\n    assert recovered_r == period_true\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    # Find the most frequent measurement outcome\n    measured_str = max(output, key=output.get)\n    measured_value = int(measured_str, 2)\n    n = shor.n\n    N = 2 ** n\n    x_over_N = measured_value / N\n    # Use continued fraction to recover r\n    def continued_fraction(x, max_denominator):\n        from fractions import Fraction\n        return Fraction(x).limit_denominator(max_denominator).denominator\n    recovered_r = continued_fraction(x_over_N, N)\n    assert recovered_r == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction_expansion(value, qmax):\n        fractions = []\n        while value.denominator != 1 and len(fractions) < 20:\n            a = value.numerator // value.denominator\n            fractions.append(a)\n            if value.numerator % value.denominator == 0:\n                break\n            value = 1 / (value - a)\n        result = 0\n        for a in reversed(fractions):\n            if result == 0:\n                result = a\n            else:\n                result = a + 1 / result\n        return result\n\n    # Target period for the constructed circuit is r=2 (since the circuit is designed this way)\n    n = shor.n\n    N = 2 ** n\n    # Find the most probable output\n    max_key = max(output, key=output.get)\n    s = int(max_key, 2)\n\n    # Fraction s/N\n    from fractions import Fraction\n    frac = Fraction(s, N).limit_denominator(N)\n\n    # Use continued fraction to guess period r\n    # Try all denominators up to N\n    found_r = None\n    for denominator in range(1, N+1):\n        if abs(frac - Fraction(round(frac * denominator), denominator)) < 1e-6:\n            r_candidate = denominator\n            if r_candidate != 0:\n                found_r = r_candidate\n                break\n    assert found_r == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction(x, Q, max_denominator=15):\n        from fractions import Fraction\n        return Fraction(x, Q).limit_denominator(max_denominator).denominator\n    counts_sorted = sorted(output.items(), key=lambda kv: kv[1], reverse=True)\n    most_probable = counts_sorted[0][0]\n    s = int(most_probable, 2)\n    Q = 2 ** shor.n\n    r_candidate = continued_fraction(s, Q)\n    assert r_candidate == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction(x, N, max_den=15):\n        # Returns denominator of best fraction <= max_den\n        a, b = 0, 1\n        c, d = 1, 0\n        while True:\n            mediant = (a + c) / (b + d)\n            if x == mediant or (b + d > max_den):\n                break\n            if x > mediant:\n                a, b = a + c, b + d\n            else:\n                c, d = a + c, b + d\n        if b + d <= max_den:\n            k = b + d\n        else:\n            k = d if abs(x - a/b) < abs(x - c/d) else b\n        return k\n\n    max_count = max(output, key=output.get)\n    measured = int(max_count, 2)\n    n_count = shor.n\n    N = 2 ** n_count\n    x_over_N = measured / N\n    recovered_r = continued_fraction(x_over_N, N)\n    assert recovered_r == 2\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    r_actual = 2  # Expected period for the simplified oracle\n    counts = output\n    N = 2 ** shor.n\n    most_common = max(counts, key=counts.get)\n    s = int(most_common, 2)\n    x_over_N = s / N\n    def continued_fraction(x, max_denominator):\n        from fractions import Fraction\n        return Fraction(x).limit_denominator(max_denominator).denominator\n    r_recovered = continued_fraction(x_over_N, N)\n    assert r_recovered == r_actual, f\"Recovered period {r_recovered} does not match expected {r_actual}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction_expansion(x, N, max_denominator=15):\n        \"\"\"Find the denominator of the best fraction approximating x/N.\"\"\"\n        from fractions import Fraction\n        frac = Fraction(x, N).limit_denominator(max_denominator)\n        return frac.denominator\n\n    N = 2**shor.n\n    # Most probable output should be either 0, 2, 4, or 6 (period 2 peaks)\n    most_common_outcome = max(output.items(), key=lambda k: k[1])[0]\n    measured_x = int(most_common_outcome, 2)\n    recovered_r = continued_fraction_expansion(measured_x, N)\n    assert recovered_r == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    from fractions import Fraction\n    n = shor.n\n    N = 2 ** n\n    # Find the most frequent outcome\n    max_bitstring = max(output, key=output.get)\n    measured = int(max_bitstring, 2)\n    frac = Fraction(measured, N).limit_denominator(N)\n    # Try denominators up to N to recover candidate period r\n    found_r = frac.denominator\n    # In this simplified circuit, periodicity peaks at a multiple of 2 (e.g., r=2 or r=4)\n    # Since the oracle is constructed to use CZ gates, the period is 2\n    assert found_r == 2, f\"Recovered period {found_r} does not match expected period 2\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n\n    # >>> ASSERTION START\n    def get_period_from_counts(counts, n):\n        N = 2 ** n\n        most_common_bitstring = max(counts, key=counts.get)\n        s = int(most_common_bitstring, 2)\n        x = s / N\n        from fractions import Fraction\n        cf = Fraction(x).limit_denominator(N)\n        r = cf.denominator\n        return r\n\n    period = get_period_from_counts(output, shor.n)\n    assert period == 2, f\"Recovered period {period} does not match expected value 2\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction(x, N):\n        fractions = []\n        while True:\n            a = int(x)\n            fractions.append(a)\n            x -= a\n            if abs(x) < 1e-10:\n                break\n            x = 1 / x\n        # Compute convergents\n        num, denom = 1, 0\n        for a in reversed(fractions):\n            num, denom = denom + num * a, num\n        return num, denom\n\n    counts = output\n    N = 2 ** shor.n\n    most_likely = max(counts, key=counts.get)\n    s = int(most_likely, 2)\n    frac = s / N\n    _, denom = continued_fraction(frac, N)\n    r = 2  # expected period\n    assert denom == r, f\"Recovered period {denom} does not match expected {r}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    # Classical post-processing to extract period r from output\n    n_bits = shor.n\n    N = 2**n_bits\n    # Find the most frequent measurement bitstring\n    measured = max(output, key=output.get)\n    s = int(measured, 2)\n    # Avoid trivial s = 0\n    if s == 0:\n        s = 1\n    # Continued fraction expansion to approximate s/N\n    def continued_fraction(x, max_den):\n        from fractions import Fraction\n        return Fraction(x).limit_denominator(max_den)\n    frac = continued_fraction(s / N, N)\n    r_candidate = frac.denominator\n    # For this circuit, the period that creates peaks is 2\n    assert r_candidate == 2, f\"Recovered period is {r_candidate}, expected 2\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    from fractions import Fraction\n    # Find most probable outcome\n    most_probable = max(output, key=output.get)\n    measured_int = int(most_probable, 2)\n    N = 2 ** shor.n\n    x_over_N = measured_int / N\n    # Continued fraction expansion to find r\n    cf = Fraction(x_over_N).limit_denominator(N)\n    r_recovered = cf.denominator\n    assert r_recovered == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    # Find the most probable measured value\n    max_bitstring = max(output, key=output.get)\n    measured = int(max_bitstring, 2)\n    N = 2 ** shor.n\n    # Continued fraction expansion to estimate the period r\n    def continued_fraction(x, y, max_den=15):\n        a, b = x, y\n        cf = []\n        while b:\n            q = a // b\n            cf.append(q)\n            a, b = b, a - b * q\n        # Convert continued fraction to convergents\n        def convergents(cf):\n            convs = []\n            for i in range(1, len(cf)+1):\n                num, den = 1, 0\n                for q in reversed(cf[:i]):\n                    num, den = den + num * q, num\n                convs.append((num, den))\n            return convs\n        for num, den in convergents(cf):\n            if den > 0 and den <= max_den:\n                yield (num, den)\n    period_guess = None\n    for num, den in continued_fraction(measured, N, max_den=15):\n        if den != 0 and abs(measured / N - num / den) < 1/(2*N):\n            period_guess = den\n            break\n    # In this simplified circuit, the period r is known to be 2\n    assert period_guess == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    most_common = max(output.items(), key=lambda x: x[1])[0]\n    measured_int = int(most_common, 2)\n    q = 2 ** shor.n\n    x_over_q = measured_int / q\n    def continued_fraction(x, N):\n        cf = []\n        for _ in range(N):\n            a = int(x)\n            cf.append(a)\n            x = x - a\n            if x == 0:\n                break\n            x = 1 / x\n        return cf\n    def convergents(cf):\n        n, d = 1, 0\n        n1, d1 = cf[0], 1\n        convergents = [(n1,d1)]\n        for a in cf[1:]:\n            n2 = a * n1 + n\n            d2 = a * d1 + d\n            convergents.append((n2,d2))\n            n, d = n1, d1\n            n1, d1 = n2, d2\n        return convergents\n    cf = continued_fraction(x_over_q, 10)\n    convs = convergents(cf)\n    period_candidates = [d for (n, d) in convs if d != 0]\n    r = 2  # expected period for constructed circuit\n    assert r in period_candidates, f\"Recovered period {period_candidates} does not include expected period {r}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction_expansion(measured, n_bits):\n        N = 2 ** n_bits\n        x_over_N = measured / N\n        # Use continued fractions to approximate x_over_N as s/r\n        def cont_frac(x, depth=20):\n            cf = []\n            for _ in range(depth):\n                if x == 0:\n                    break\n                a = int(1 / x)\n                cf.append(a)\n                x = 1 / x - a\n                if x < 1e-8:\n                    break\n            return cf\n\n        def convergents(cf):\n            num = [0, 1]\n            den = [1, 0]\n            for a in cf:\n                num.append(a * num[-1] + num[-2])\n                den.append(a * den[-1] + den[-2])\n            return [(num[i], den[i]) for i in range(2, len(num))]\n\n        frac = cont_frac(x_over_N)\n        converg = convergents(frac)\n        for s, r in converg:\n            if r == 0:\n                continue\n            if abs(x_over_N - s / r) < 1/(2 * (2 ** (n_bits))):\n                return r\n        return None\n\n    n_bits = shor.n\n    # Find the most likely measurement outcome (peak)\n    peak_bitstring = max(output, key=output.get)\n    measured = int(peak_bitstring, 2)\n    recovered_r = continued_fraction_expansion(measured, n_bits)\n    assert recovered_r == 2, f\"Recovered period r={recovered_r}, expected 2\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n    # >>> ASSERTION START\n    def continued_fraction_expansion(x, qmax):\n        \"\"\"Compute the denominator of the best rational approximation to x with denominator <= qmax.\"\"\"\n        from fractions import Fraction\n        return Fraction(x).limit_denominator(qmax).denominator\n\n    n = shor.n\n    N = 2 ** n\n    most_common = max(output.items(), key=lambda item: item[1])[0]\n    s = int(most_common, 2)\n    x = s / N\n    r_recovered = continued_fraction_expansion(x, N)\n    assert r_recovered == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB27",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n\n    # >>> ASSERTION START\n    # r = 2 for simulated peaks at multiples of 2\n    N = 2 ** shor.n\n    measured_bits = max(output, key=output.get)\n    x = int(measured_bits, 2)\n    if x == 0:\n        recovered_r = None\n    else:\n        frac = x / N\n        # Continued fraction expansion to recover denominator\n        def contfrac(x, y, max_den=16):\n            a = []\n            while y and len(a) < 20:\n                q = x // y\n                a.append(q)\n                x, y = y, x - q * y\n            # Now build denominator from continued fraction\n            n0, d0 = 1, 0\n            n1, d1 = a[0], 1\n            for q in a[1:]:\n                n2 = q * n1 + n0\n                d2 = q * d1 + d0\n                n0, d0 = n1, d1\n                n1, d1 = n2, d2\n                if d1 > max_den:\n                    break\n            return d1\n        recovered_r = contfrac(x, N)\n    assert recovered_r == 2\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert (lambda counts: (sum(counts.values()) > 0) and (sum(v for k, v in counts.items() if k[1] == '0') / sum(counts.values()) > 0.6) and ((sum(v for k, v in counts.items() if (k[0] == '1' and k[2] == '0')) / max(1, sum(v for k, v in counts.items() if k[0] == '1'))) > 0.55))(self.counts), \"Result distribution does not align with expected HHL solution dominance\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert max(self.counts.values()) / sum(self.counts.values()) > 0.4 and max(self.counts, key=self.counts.get) in ('001', '101'), \"HHL output is not dominated by the expected solution state.\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        # Dominant state expected: solution encoded in qubit 1 (the system register), qubit 2 (ancilla) == 1, qubit 0 (QPE) == 0 or 1\n        # The solution state is expected to be of the form 'x1x', where x=don't care, 1=ancilla=1. Qiskit order: q2 q1 q0.\n        # So, success if the sum of all counts ending with '1' (ancilla) is large compared to total.\n        solution_counts = sum(v for k, v in self.counts.items() if k[0] == '1')\n        assert solution_counts / self.shots > 0.6, f\"Dominant solution state not observed: {solution_counts/self.shots:.2f}\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert (sum(v for k, v in program.counts.items() if k[0] == '1') > 0) and (program.counts.get('100', 0) / sum(v for k, v in program.counts.items() if k[0] == '1') > 0.7)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert max(self.counts.get(k, 0) for k in self.counts if k[0] == '1') > 0.7 * sum(self.counts.get(k, 0) for k in self.counts if k[0] == '1'), \"Solution state is not dominant.\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(self.counts.get(state, 0) for state in self.counts if state[-1] == '1') > 0.6 * self.shots\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert max(self.counts.values()) / sum(self.counts.values()) > 0.6\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum([v for k, v in self.counts.items() if k[-1] == '1']) / self.shots > 0.6, \"Dominant solution state not found in output.\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(v for k, v in self.counts.items() if k[-1] == '1') > self.shots * 0.4\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert max(self.counts.get(s, 0) for s in self.counts if s[-1] == '1') > 0.5 * self.shots, \"Solution state is not dominant in measurement results\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum([self.counts.get(state,0) for state in self.counts if state[-1]==\"1\"]) > 0.6 * self.shots\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert max(self.counts.get(s, 0) for s in self.counts if s[-1] == '1') > 0.5 * sum(self.counts.get(s, 0) for s in self.counts), \"Dominant solution state not found in HHL output.\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum([self.counts.get(key, 0) for key in self.counts if key[-1] == '1']) > 0.8 * self.shots\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert max(self.counts.get(state, 0) for state in self.counts if state[0] == '1') > 0.5 * self.shots\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(self.counts.get(k, 0) for k in self.counts if k[-1] == '1') > 0.7 * sum(self.counts.values()), \"Output is not dominated by correct solution state\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(v for k, v in self.counts.items() if k[-1] == '1') > 0.6 * self.shots, \"HHL output is not dominated by the expected solution state.\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(v for k, v in self.counts.items() if k[0] == '1') > 0.7 * self.shots\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(self.counts.get(key, 0) for key in self.counts if key[-1] == '1') > 0.6 * self.shots\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(self.counts.get(bitstr, 0) for bitstr in self.counts if bitstr[0:2] == '00') / self.shots > 0.7, \"The correct solution state does not dominate the output distribution.\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert max(self.counts.values()) / self.shots > 0.4 and max(self.counts, key=self.counts.get)[0] == '1', \"HHL solution state is not dominant in the output.\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(self.counts.get(key, 0) for key in self.counts if key.endswith('1')) > 0.6 * self.shots\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum([self.counts.get(key, 0) for key in self.counts if key[-1] == '1']) > 0.7 * self.shots\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum([v for k, v in self.counts.items() if k[::-1][2] == '1']) / self.shots > 0.7, \"Dominant solution state not found\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        solution_state = max(self.counts, key=self.counts.get)\n        assert self.counts[solution_state] / sum(self.counts.values()) > 0.6, \"Dominant solution state not found in output.\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert max(self.counts.get(key, 0) for key in self.counts if key[-1] == '1') > 0.5 * sum(self.counts.values())\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert max(self.counts.get(k, 0) for k in self.counts if k[-1] == '1') > 0.7 * self.shots, \"HHL output is not dominated by the correct solution state (ancilla = 1).\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(self.counts.get(s, 0) for s in self.counts if s[-1] == '1') / self.shots > 0.6, \"HHL solution not dominant: ancilla not measured as '1' frequently enough.\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(v for k, v in self.counts.items() if k[-1] == '1') > 0.6 * self.shots, \"Output is not dominated by expected solution state.\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(self.counts.get(bitstr, 0) for bitstr in self.counts if bitstr[0] == '1') / self.shots > 0.5, \"Dominant solution state not measured\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert max(self.counts.get(k, 0) for k in self.counts if k.endswith('1')) > 0.5 * sum(self.counts.values()), \"Dominant outcome is not correct solution\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum([v for k,v in self.counts.items() if k[-1]=='1']) > 0.6 * self.shots\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(self.counts.get(key, 0) for key in self.counts if key[0] == '1') > 0.7 * self.shots\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert max(self.counts.get(k, 0) for k in self.counts if k[-1] == '1') > 0.7 * self.shots, \"Dominant solution state (ancilla=1) not observed\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert max(self.counts.get(k, 0) for k in self.counts if k[-1] == '1') > 0.5 * sum(self.counts.values())\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(self.counts.get(x, 0) for x in self.counts if x[-1] == '1') / self.shots > 0.6, \"HHL solution state is not dominant in the output distribution.\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum([self.counts.get(state, 0) for state in self.counts if state[-1] == '1']) > 0.6 * self.shots, \"HHL output is not dominated by expected solution state.\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        # Expect the solution qubit |1> (bit 1, counting from right in string) to dominate when ancilla (bit 2) is |1>\n        # Find keys where ancilla qubit (leftmost bit) is '1'\n        filtered = {k: v for k, v in self.counts.items() if k[0] == '1'}\n        total = sum(filtered.values())\n        # Of those, dominant state should be '110' (ancilla=1, reg=1, reg=0), which is |1⟩ solution\n        dominant = filtered.get('110', 0)\n        assert total > 0 and dominant / total > 0.7, \"Dominant solution state not observed in output.\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert self.counts.get('001', 0) / self.shots > 0.4, \"Dominant solution state '001' not observed\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(v for k, v in self.counts.items() if k[-1] == '1') > 0.7 * self.shots\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum([self.counts.get(bitstr, 0) for bitstr in self.counts if bitstr[-1] == '1']) > 0.7 * self.shots\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(self.counts.get(key, 0) for key in self.counts if key[-1] == '1') / self.shots > 0.6, \"HHL output not dominated by solution state (ancilla=1)\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(self.counts.get(bitstring, 0) for bitstring in self.counts if bitstring[0]=='0' and bitstring[2]=='1') / self.shots > 0.5, \"Solution state not dominant in output distribution\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert sum([v for k,v in program.counts.items() if k[0]=='1']) / program.shots > 0.7, \"HHL output is not dominated by correct solution state\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert max(self.counts.get(x, 0) for x in self.counts if x[0] == '1') / sum(self.counts.values()) > 0.5, \"Output not dominated by solution state\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(v for k, v in self.counts.items() if k[-1] == '1') > 0.7 * self.shots\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum([self.counts.get(bitstr, 0) for bitstr in self.counts if bitstr[-1] == '1']) > 0.7 * self.shots\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert max(self.counts.values()) / sum(self.counts.values()) > 0.5, \"HHL output is not dominated by the correct solution state\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        sol = '010'\n        assert self.counts.get(sol, 0) / self.shots > 0.4, \"Output not dominated by expected solution state '010'\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum(v for k, v in self.counts.items() if k[-1] == '1') > 0.7 * self.shots, \"HHL output not dominated by expected solution\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB28",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        assert sum([self.counts.get(s, 0) for s in self.counts if s[0] == \"1\"]) > 0.6 * self.shots\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    n = program.num_qubits\n    period = program.period\n    N = 2 ** n\n    expected_freqs = [k for k in range(0, N, N // period)]\n    peaks = sorted([int(bitstr, 2) for bitstr, count in program.counts.items() if count > 0])\n    assert any(abs((peak % (N // period))) == 0 for peak in peaks), \"QFT output does not have peaks at expected frequencies\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    _counts = program.counts\n    n = program.num_qubits\n    period = program.period\n    # Peaks expected at multiples of N/period\n    N = 2 ** n\n    expected_peaks = [format(i, '0{}b'.format(n)) for i in range(0, N, N // period)]\n    measured_counts = set(k for k, v in _counts.items() if v > 0)\n    hits = sum(1 for peak in expected_peaks if peak in measured_counts)\n    assert hits >= period // 2, f\"QFT peaks not detected as expected: found {hits}, expected at least {period//2}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert any(abs(int(bitstr, 2) % (2 ** program.num_qubits // program.period)) == 0 and count > program.shots * 0.005 for bitstr, count in program.counts.items())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n        # >>> ASSERTION START\n        expected_peaks = [format(i, f'0{self.num_qubits}b') for i in range(0, 2**self.num_qubits, 2**(self.num_qubits - int(np.log2(self.period))))]\n        observed_peaks = sorted(self.counts, key=self.counts.get, reverse=True)[:len(expected_peaks)]\n        assert any(peak in observed_peaks for peak in expected_peaks), \"QFT output does not show expected frequency peaks\"\n        # <<< ASSERTION END\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert any((int(bitstring, 2) % (program.num_qubits * program.period // 2**(program.num_qubits - int(np.log2(program.period)))) == 0 and count > 0) for bitstring, count in program.counts.items())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n        # >>> ASSERTION START\n        expected_period = self.period\n        n = self.num_qubits\n        peak_spacing = 2**n // expected_period\n        measured = set(int(k, 2) for k in self.counts)\n        expected_peaks = set(i * peak_spacing for i in range(expected_period))\n        assert len(measured & expected_peaks) >= max(1, expected_period // 2), \"QFT peak structure not detected\"\n        # <<< ASSERTION END\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    period = program.period\n    n = program.num_qubits\n    expected_freqs = [format(k * (2**n // period), f'0{n}b') for k in range(period)]\n    peaks = sorted(program.counts.items(), key=lambda x: -x[1])\n    top_outputs = [k for k, _ in peaks[:period]]\n    assert any(freq in top_outputs for freq in expected_freqs)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    peak_bins = [format(i, f\"0{program.num_qubits}b\") for i in range(0, 2**program.num_qubits, 2**(program.num_qubits - int(np.log2(program.period))))]\n    counts = program.counts\n    total = sum(counts.get(bin, 0) for bin in peak_bins)\n    assert total / program.shots > 0.8, \"QFT output does not show expected peaks for periodic input\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        # >>> ASSERTION START\n        n = self.num_qubits\n        period = self.period\n        # The expected peaks are at k = multiples of 2^n / period\n        expected_spacing = 2**n // period\n        observed = [int(k, 2) for k in self.counts.keys()]\n        found_peak = False\n        for i in range(period):\n            peak_bin = i * expected_spacing\n            # Check if a measured outcome is within ±2 bins of the expected peak\n            if any(abs(x - peak_bin) <= 2 for x in observed):\n                found_peak = True\n        assert found_peak, \"QFT output does not contain peaks at expected frequency components\"\n        # <<< ASSERTION END\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert any(int(k, 2) % (program.num_qubits // program.period) == 0 and v > 0 for k, v in program.counts.items())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    period = program.period\n    n = program.num_qubits\n    expected_peaks = [format(k, f'0{n}b') for k in range(0, 2**n, 2**n // period)]\n    measured_peaks = sorted(program.counts, key=lambda k: program.counts[k], reverse=True)[:period]\n    assert any(p in measured_peaks for p in expected_peaks), \"QFT output does not contain expected frequency peaks\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    expected_period = program.period\n    n = program.num_qubits\n    expected_peaks = [format(i, '0{}b'.format(n)) for i in range(0, 2**n, 2**n // expected_period)]\n    actual_peaks = sorted(program.counts, key=program.counts.get, reverse=True)[:expected_period]\n    assert any(peak in expected_peaks for peak in actual_peaks)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    top_counts = sorted(program.counts.items(), key=lambda x: x[1], reverse=True)\n    n = program.num_qubits\n    period = program.period\n    expected_freq = 2 ** n // period\n    top_states = [int(bitstr, 2) for bitstr, _ in top_counts[:period]]\n    assert any(abs(state % expected_freq) < 2 for state in top_states)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    n = program.num_qubits\n    period = program.period\n    N = 2 ** n\n    expected_freq = N // period\n    top_counts = sorted(program.counts.items(), key=lambda x: x[1], reverse=True)[:8]\n    top_indices = [int(bitstring, 2) for bitstring, _ in top_counts]\n    assert any((idx % expected_freq == 0) for idx in top_indices)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert any(bin(int(k, 2)).count(\"1\") == 1 and int(k, 2) % (program.num_qubits // program.period) == 0 for k in program.counts.keys()) or any(int(k, 2) % (2**program.num_qubits // program.period) == 0 for k in program.counts.keys())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    n = program.num_qubits\n    period = program.period\n    expected_peaks = list(range(0, 2**n, 2**n // period))\n    observed = [int(bitstr, 2) for bitstr in program.counts]\n    overlap = any(((x % (2**n // period)) == 0 and program.counts.get(format(x, f'0{n}b'), 0) > 0) for x in observed)\n    assert overlap, \"QFT output does not show peaks at expected frequency components.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert any(\n        abs(int(k, 2) % (program.num_qubits // program.period)) == 0 and v > program.shots * 0.005\n        for k, v in program.counts.items()\n    ), \"QFT output does not contain expected frequency peaks\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    top_keys = sorted(program.counts, key=program.counts.get, reverse=True)[:8]\n    top_ints = [int(k, 2) for k in top_keys]\n    assert any(abs((x % (2**program.num_qubits)) % (2**program.num_qubits // program.period)) == 0 for x in top_ints)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    expected_period = program.period\n    n = program.num_qubits\n    expected_peaks = list(range(0, 2**n, 2**n // expected_period))\n    observed_peaks = [int(k, 2) for k, v in program.counts.items() if v > program.shots * 0.05]\n    assert any(p in observed_peaks for p in expected_peaks), \"QFT output does not contain expected frequency peaks\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    expected_peaks = [format(i, '0{}b'.format(program.num_qubits)) for i in range(0, 2**program.num_qubits, 2**(program.num_qubits - int(np.log2(program.period))))]\n    observed_peaks = sorted(program.counts.items(), key=lambda item: item[1], reverse=True)[:len(expected_peaks)]\n    observed_keys = set(k for k, v in observed_peaks)\n    assert any(pk in observed_keys for pk in expected_peaks), \"QFT output does not show expected periodic peaks\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert any(int(bin_key, 2) % (program.num_qubits // program.period + 1) == 0 and count > program.shots * 0.01 for bin_key, count in program.counts.items())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n        # >>> ASSERTION START\n        n = self.num_qubits\n        period = self.period\n        expected_frequencies = [k for k in range(0, 2 ** n, 2 ** n // period)]\n        expected_binstrings = {format(f, f'0{n}b') for f in expected_frequencies}\n        observed_binstrings = set(self.counts.keys())\n        assert len(expected_binstrings & observed_binstrings) > 0, \"QFT output does not contain expected frequency peaks\"\n        # <<< ASSERTION END\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    n = program.num_qubits\n    period = program.period\n    N = 2 ** n\n    expected_freq = N // period\n    threshold = 0.1 * program.shots\n    peak_counts = sum(count for bitstr, count in program.counts.items() if int(bitstr, 2) % expected_freq == 0)\n    assert peak_counts >= threshold, \"QFT output does not contain expected frequency peaks.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n        # >>> ASSERTION START\n        # After QFT on a periodic input of period p, peaks should be at indices k such that k mod (N/p) == 0.\n        # N = 2^n\n        n = self.num_qubits\n        N = 2 ** n\n        expected_freq = N // self.period\n        # Get integer indices of measured states\n        peak_indices = [int(bitstr, 2) for bitstr, c in self.counts.items() if c > 0.05 * self.shots / (N // self.period)]\n        # There should be at least one index that is a multiple of expected_freq\n        assert any(idx % expected_freq == 0 for idx in peak_indices)\n        # <<< ASSERTION END\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    # The QFT of a state with period p has peaks at frequencies k = t*N/p for t = 0,1,...,p-1, where N=2^n\n    n = program.num_qubits\n    p = program.period\n    N = 2 ** n\n    expected_peaks = [format((t * N) // p, f'0{n}b') for t in range(p)]\n    top_counts = sorted(program.counts.items(), key=lambda x: -x[1])\n    top_keys = [k for k, v in top_counts[:p]]\n    assert any(pk in top_keys for pk in expected_peaks), \"QFT output does not show expected frequency peaks\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    num_qubits = program.num_qubits\n    period = program.period\n    N = 2 ** num_qubits\n    f = N // period\n    threshold = 0.01 * program.shots\n    peak_states = [format((k * f) % N, f'0{num_qubits}b') for k in range(period)]\n    counts = program.counts\n    assert any(counts.get(state, 0) > threshold for state in peak_states), \"QFT output does not show expected peaks at period harmonics.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    expected_peaks = set()\n    n = program.num_qubits\n    N = 2**n\n    period = program.period\n    for k in range(0, N, N // period):\n        binary = format(k, f'0{n}b')\n        expected_peaks.add(binary)\n    measured_peak_prob = sum([program.counts.get(peak, 0) for peak in expected_peaks]) / program.shots\n    assert measured_peak_prob > 0.6, \"QFT output does not show expected frequency peaks\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n        # >>> ASSERTION START\n        # Peaks should be at integer multiples of 2^n/period = 1024/4 = 256 (i.e., at 0, 256, 512, 768)\n        bitstrings = [bin(i)[2:].zfill(self.num_qubits) for i in range(0, 2**self.num_qubits)]\n        expected_peaks = set([format(k, '0{}b'.format(self.num_qubits)) for k in range(0, 2**self.num_qubits, 2**self.num_qubits // self.period)])\n        measured = set([k for k, v in self.counts.items() if v > 0])\n        assert len(expected_peaks & measured) >= len(expected_peaks) - 1\n        # <<< ASSERTION END\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert any(int(bitstring, 2) % (program.num_qubits // program.period) == 0 and count > program.shots * 0.01 for bitstring, count in program.counts.items())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    expected_peaks = [format(i, f\"0{program.num_qubits}b\") for i in range(0, 2**program.num_qubits, 2**(program.num_qubits - int(np.log2(program.period))))] if (2**program.num_qubits) % program.period == 0 else [format(i, f\"0{program.num_qubits}b\") for i in range(0, 2**program.num_qubits) if i % (2**program.num_qubits // program.period) == 0]\n    measured_keys = set(program.counts.keys())\n    found_peak = any(key in measured_keys for key in expected_peaks)\n    assert found_peak, \"QFT output does not show expected frequency peaks for periodic input\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n        # >>> ASSERTION START\n        period = self.period\n        n = self.num_qubits\n        total_shots = self.shots\n        expected_freqs = [i for i in range(0, 2**n, 2**n // period)]\n        expected_keys = set(format(f, \"0{}b\".format(n)) for f in expected_freqs)\n        measured_keys = set(self.counts.keys())\n        observed = sum(self.counts[k] for k in expected_keys if k in measured_keys)\n        assert observed / total_shots > 0.7, \"QFT output does not have expected frequency peaks\"\n        # <<< ASSERTION END\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    period = program.period\n    n = program.num_qubits\n    expected_peaks = set()\n    for k in range(0, 2**n, 2**n // period):\n        peak = format(k, f'0{n}b')\n        expected_peaks.add(peak)\n    measured_peaks = set([k for k, v in program.counts.items() if v > 0])\n    assert len(expected_peaks & measured_peaks) >= len(expected_peaks) // 2\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    period = program.period\n    n = program.num_qubits\n    N = 2**n\n    expected_freqs = [k for k in range(0, N, N // period)]\n    measured_ints = [int(bitstr, 2) for bitstr in program.counts]\n    peak_hits = sum(any(abs(m - f) < 2 for f in expected_freqs) for m in measured_ints)\n    assert peak_hits >= period, \"QFT output does not show expected frequency peaks for periodic input\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert any(int(k, 2) % (program.num_qubits // program.period) == 0 and v > program.shots // 32 for k, v in program.counts.items())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    n = program.num_qubits\n    period = program.period\n    expected_freqs = [format(k * (2 ** n // period), f'0{n}b') for k in range(period)]\n    assert any(key in program.counts and program.counts[key] > 0.05 * program.shots for key in expected_freqs), \"QFT output does not show expected frequency peaks\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    period = program.period\n    n = program.num_qubits\n    total_counts = sum(program.counts.values())\n    # QFT of periodic input produces peaks at multiples of N/period\n    expected_spacing = 2**n // period\n    peak_bin_indices = [i * expected_spacing for i in range(period)]\n    peak_keys = {format(idx, f'0{n}b') for idx in peak_bin_indices}\n    observed_peaks = sum(program.counts.get(k, 0) for k in peak_keys)\n    assert observed_peaks / total_counts > 0.5, \"QFT output does not show expected frequency peaks\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n        # >>> ASSERTION START\n        period = self.period\n        n = self.num_qubits\n        shots = self.shots\n        peaks = [format(i, f'0{n}b') for i in range(0, 2**n, 2**n // period)]\n        found_peaks = sum([self.counts.get(p, 0) for p in peaks])\n        assert found_peaks / shots > 0.6\n        # <<< ASSERTION END\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    expected_spacing = 2 ** program.num_qubits // program.period\n    peaks = [int(bitstr, 2) for bitstr, c in program.counts.items() if c > program.shots * 0.01]\n    assert any(abs((x - y) % expected_spacing) == 0 for i, x in enumerate(peaks) for y in peaks[i+1:]), \"QFT output does not contain peaks at expected frequency components\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    dom = sorted([(int(k, 2), v) for k, v in program.counts.items()], key=lambda x: x[1], reverse=True)\n    n = program.num_qubits\n    period = program.period\n    expected_peaks = [int(round(j * (2 ** n) / period)) % (2 ** n) for j in range(period)]\n    observed = set([x[0] for x in dom[:period]])\n    assert any(abs((obs - peak) % (2 ** n)) < 2 for peak in expected_peaks for obs in observed)\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert any(abs(int(bitstr, 2) % (program.num_qubits * 2 // program.period) == 0) and count > 0 for bitstr, count in program.counts.items())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    n = program.num_qubits\n    period = program.period\n    N = 2 ** n\n    expected_frequencies = [(k * N) // period for k in range(period)]\n    expected_frequencies = [f % N for f in expected_frequencies]\n    expected_keys = set(format(f, f'0{n}b') for f in expected_frequencies)\n    measured_keys = set(program.counts.keys())\n    assert any(k in measured_keys for k in expected_keys), \"QFT output does not show peaks at expected frequency components.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    # The QFT of a periodic input of period p yields peaks at integer multiples of N/p\n    n = program.num_qubits\n    N = 2**n\n    period = program.period\n    expected_freqs = [i * (N // period) for i in range(period)]\n    expected_bin_strs = {format(freq, f'0{n}b') for freq in expected_freqs}\n    measured = set(program.counts.keys())\n    found = any(binstr in measured for binstr in expected_bin_strs)\n    assert found, f\"QFT output does not contain expected peaks at {expected_bin_strs}\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    n = program.num_qubits\n    period = program.period\n    shots = program.shots\n    # The expected frequency should be 2^n / period\n    step = (2**n) // period\n    expected_peaks = set([(i * step) % (2**n) for i in range(period)])\n    top_k = 4\n    sorted_counts = sorted(program.counts.items(), key=lambda x: x[1], reverse=True)\n    measured_peaks = set([int(bitstr, 2) for bitstr, _ in sorted_counts[:top_k]])\n    assert len(expected_peaks.intersection(measured_peaks)) >= 2, \"QFT output does not show expected periodic peaks\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert any(int(k, 2) % (program.num_qubits * 2 // program.period) == 0 and v > 0 for k, v in program.counts.items())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert any(int(bitstr, 2) % (2**program.num_qubits // program.period) == 0 and count > program.shots * 0.01 for bitstr, count in program.counts.items())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert any(int(bitstring, 2) % (program.num_qubits // program.period) == 0 and count > program.shots * 0.01 for bitstring, count in program.counts.items())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert any(int(bitstring, 2) % (2**program.num_qubits // program.period) == 0 and count > 0 for bitstring, count in program.counts.items())\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    peaks = sorted([int(bitstr, 2) for bitstr in program.counts if program.counts[bitstr] > 0], key=lambda x: program.counts[format(x, f'0{program.num_qubits}b')], reverse=True)\n    expected = program.num_qubits // program.period\n    top_counts = [int(bitstr, 2) for bitstr in sorted(program.counts, key=program.counts.get, reverse=True)[:expected]]\n    assert all(abs((k % (program.num_qubits // program.period)) * program.period) == 0 for k in top_counts), \"QFT output does not contain expected frequency peaks.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    expected_spacing = program.num_qubits // int(np.log2(program.period))\n    freq = 2**program.num_qubits // program.period\n    peaks = [format(i * freq % 2**program.num_qubits, '0{}b'.format(program.num_qubits)) for i in range(program.period)]\n    measured_peaks = sorted(program.counts, key=program.counts.get, reverse=True)[:program.period]\n    assert any(peak in measured_peaks for peak in peaks)\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB29",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n    # >>> ASSERTION START\n    assert any(int(bitstring, 2) % (2 ** program.num_qubits // program.period) == 0 and count > program.shots * 0.01 for bitstring, count in program.counts.items())\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    counts = np.array([v for v in result.values()])\n    fft_counts = np.abs(np.fft.fft(counts))\n    assert np.max(fft_counts[1:]) > 0.5 * fft_counts[0], \"Output distribution is not strongly periodic\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    # >>> ASSERTION START\n    assert (lambda res, n: (lambda p: (lambda F: (np.max(F[1:]) / (np.median(F[1:]) + 1e-12)) > 1.05)(np.abs(np.fft.rfft(p / max(1.0, p.sum())))))(np.array([res.get(format(i, '0{}b'.format(n)), 0) for i in range(1 << n)], dtype=float)))(result, program.n_count), \"Output distribution lacks strong periodicity in counting register\"\n    # <<< ASSERTION END\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from collections import Counter\n    keys = list(result.keys())\n    ints = [int(k, 2) for k in keys]\n    ints_sorted = sorted(ints)\n    diffs = [b - a for a, b in zip(ints_sorted[:-1], ints_sorted[1:])]\n    most_common_gap, freq = Counter(diffs).most_common(1)[0]\n    assert most_common_gap > 0 and freq >= max(2, len(ints_sorted)//10), \"Output distribution does not show strong periodicity\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    counts = result\n    bitstrings = list(counts.keys())\n    bit_ints = [int(bs, 2) for bs in bitstrings]\n    hist = np.zeros(2**program.n_count)\n    for b, c in zip(bit_ints, counts.values()):\n        hist[b] = c\n    fft = np.fft.fft(hist)\n    peaks = np.argsort(np.abs(fft))[::-1][:3]\n    assert np.abs(fft[peaks[0]]) > 5 * np.abs(fft[peaks[1]]), \"No strong periodicity detected in measurement results\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.fft import fft\n    bitstrings = list(result.keys())\n    freqs = np.array([int(b, 2) for b in bitstrings])\n    dist = np.zeros(2 ** program.n_count)\n    for b, c in result.items():\n        dist[int(b, 2)] = c\n    spectrum = np.abs(fft(dist))\n    spectrum[0] = 0\n    periodic_peak = np.max(spectrum)\n    mean_other = (np.sum(spectrum) - periodic_peak) / (len(spectrum) - 1)\n    assert periodic_peak > 3 * mean_other, \"Output distribution does not show strong periodicity\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from collections import Counter\n    counts = Counter({int(k,2):v for k,v in result.items()})\n    spectrum = np.abs(np.fft.fft([counts.get(i,0) for i in range(2**program.n_count)]))\n    spectrum[0] = 0\n    assert np.max(spectrum) > 0.25 * program.shots, \"Output does not exhibit strong periodicity\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    import collections\n    bitstrings = [int(b, 2) for b in result.keys()]\n    counter = collections.Counter((b % 8) for b in bitstrings)\n    periodicity_detected = max(counter.values()) > 0.15 * sum(counter.values())\n    assert periodicity_detected, \"No strong periodicity detected in the counting register.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    # >>> ASSERTION START\n    measured = np.array([int(bitstr, 2) for bitstr in result.keys()])\n    counts_arr = np.array([result[bitstr] for bitstr in result.keys()])\n    spectrum = np.abs(np.fft.fft(counts_arr)) ** 2\n    fundamental = np.argmax(spectrum[1:len(spectrum)//2]) + 1\n    assert spectrum[fundamental] > 0.2 * np.sum(spectrum), \"Output lacks strong periodicity\"\n    # <<< ASSERTION END\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    counts_arr = np.array([v for _, v in sorted(result.items(), key=lambda x: int(x[0], 2))])\n    fft = np.fft.fft(counts_arr)\n    prominent_freqs = np.sum(np.abs(fft[1:len(fft)//2]) > 0.2 * np.max(np.abs(fft)))\n    assert prominent_freqs >= 1, \"No strong periodicity detected in the output distribution.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from collections import Counter\n    counts = Counter(result)\n    bitstrings = [int(k, 2) for k in counts.keys()]\n    bitstrings.sort()\n    diffs = [j - i for i, j in zip(bitstrings[:-1], bitstrings[1:])]\n    most_common_diff = Counter(diffs).most_common(1)[0][0] if diffs else None\n    occurrences = sum(1 for d in diffs if d == most_common_diff)\n    assert occurrences >= max(1, len(diffs) // 4), \"Output does not show strong periodicity in counting register.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.signal import find_peaks\n    hist = np.array([result.get(f\"{i:08b}\", 0) for i in range(2**8)])\n    peaks, _ = find_peaks(hist, height=np.max(hist)*0.2)\n    assert len(peaks) > 2, \"Output distribution does not show strong periodicity.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.signal import find_peaks\n    y = np.array([result[k] for k in sorted(result.keys(), key=lambda x: int(x, 2))])\n    peaks, _ = find_peaks(y, height=max(y)*0.5)\n    assert len(peaks) >= 2, \"Output lacks strong periodicity: less than 2 significant peaks detected.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.signal import find_peaks\n    counts = np.array([result.get(format(i, '08b'), 0) for i in range(2**8)])\n    peaks, _ = find_peaks(counts, height=max(counts)*0.2)\n    assert len(peaks) >= 2 and np.std(np.diff(peaks)) < 3, \"Output distribution does not exhibit strong periodicity\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from collections import Counter\n    bitstrings = [k for k in result.keys()]\n    int_results = [int(b, 2) for b in bitstrings]\n    hist = Counter([(i % 8) for i in int_results])\n    periodicity_strength = max(hist.values()) / sum(hist.values())\n    assert periodicity_strength > 0.30, \"Measurement distribution does not exhibit sufficient periodicity in counting register.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    import numpy as np\n    bitstrings = np.array([int(b, 2) for b in result.keys()])\n    counts = np.array(list(result.values()))\n    fft = np.fft.fft(counts)\n    fft_magnitudes = np.abs(fft)\n    dominant = np.partition(fft_magnitudes, -2)[-2:]\n    assert dominant[1] > 3 * np.median(fft_magnitudes), \"Output does not exhibit strong periodicity in the counting register\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.signal import find_peaks\n    import numpy as np\n    shots = program.shots\n    n_count = program.n_count\n    dist = np.zeros(2 ** n_count)\n    for bitstring, count in result.items():\n        idx = int(bitstring, 2)\n        dist[idx] = count\n    peaks, _ = find_peaks(dist, height=shots*0.01)\n    assert len(peaks) >= 2, \"Output distribution does not exhibit strong periodicity in the counting register.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    import numpy as np\n    bitstrings = np.array([int(b, 2) for b in result.keys()])\n    counts = np.array(list(result.values()))\n    fft_mags = np.abs(np.fft.fft(counts))\n    max_idx = np.argmax(fft_mags[1:]) + 1\n    assert fft_mags[max_idx] > 2 * np.mean(fft_mags), \"No strong periodicity detected in counting register\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    import collections\n    from scipy.signal import periodogram\n    counts_list = [result.get(k,0) for k in sorted(result.keys())]\n    f, Pxx = periodogram(counts_list)\n    assert np.max(Pxx[1:]) > 0.07 * np.sum(Pxx), \"Output distribution does not show strong periodicity in the counting register.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    # >>> ASSERTION START\n    bitstrings = np.array([int(x, 2) for x in result.keys()])\n    values, counts_hist = np.unique(bitstrings % 2, return_counts=True)\n    assert np.max(counts_hist) / np.sum(counts_hist) > 0.4, \"Output distribution does not exhibit strong periodicity.\"\n    # <<< ASSERTION END\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    # >>> ASSERTION START\n    from collections import Counter\n    counts = Counter()\n    for bitstring, count in result.items():\n        counts[int(bitstring, 2)] += count\n    n = program.n_count\n    spectrum = np.array([counts.get(i, 0) for i in range(2**n)])\n    spectrum = spectrum / spectrum.sum()\n    fft = np.abs(np.fft.fft(spectrum))\n    fft[0] = 0\n    period_idx = np.argmax(fft)\n    assert fft[period_idx] > 0.25 * fft.sum(), \"Output distribution does not exhibit strong periodicity\"\n    # <<< ASSERTION END\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    import numpy as np\n    keys = np.array([int(k, 2) for k in result.keys()])\n    values = np.array([v for v in result.values()])\n    fft = np.abs(np.fft.fft(values))\n    fft[0] = 0\n    peak = np.max(fft)\n    mean = np.mean(fft)\n    assert peak > 4 * mean, \"Output distribution does not exhibit strong periodicity\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.fft import fft\n    counts_array = np.zeros(2**program.n_count)\n    for bitstring, count in result.items():\n        idx = int(bitstring, 2)\n        counts_array[idx] = count\n    spectrum = np.abs(fft(counts_array))\n    spectrum[0] = 0\n    periodicity_strength = np.max(spectrum) / np.sum(spectrum)\n    assert periodicity_strength > 0.2, \"Output does not exhibit strong periodicity in counting register.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from collections import Counter\n    bitstrings = list(result.keys())\n    bit_ints = [int(b, 2) for b in bitstrings]\n    if len(bit_ints) > 1:\n        diffs = [abs(bit_ints[i] - bit_ints[j]) for i in range(len(bit_ints)) for j in range(i+1, len(bit_ints))]\n        common_gcd = np.gcd.reduce(diffs)\n        assert common_gcd > 1 and common_gcd < 2**program.n_count, \"Output does not show strong periodicity.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    # >>> ASSERTION START\n    from numpy.fft import fft\n    vals = np.array([result.get(f\"{i:08b}\", 0) for i in range(256)])\n    spectrum = np.abs(fft(vals))\n    periodicity_strength = np.max(spectrum[1:]) / (np.sum(spectrum) / len(spectrum))\n    assert periodicity_strength > 5, \"Output distribution does not exhibit strong periodicity.\"\n    # <<< ASSERTION END\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    values = [int(b, 2) for b in result.keys()]\n    values.sort()\n    from collections import Counter\n    spacing = [j-i for i,j in zip(values[:-1], values[1:])]\n    spacing_counts = Counter(spacing)\n    periodic_spacing = max(spacing_counts, key=spacing_counts.get)\n    assert spacing_counts[periodic_spacing] > len(values) // 4\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.signal import find_peaks\n    import numpy as np\n    output_dist = np.zeros(2**program.n_count)\n    for bitstring, count in result.items():\n        idx = int(bitstring.replace(' ',''), 2)\n        output_dist[idx] = count\n    peaks, _ = find_peaks(output_dist, height=program.shots*0.02)\n    assert len(peaks) >= 2, \"Output distribution does not exhibit strong periodicity\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    vals = np.array([int(k,2) for k in result.keys()])\n    hist = np.zeros(2**program.n_count)\n    for k, v in result.items():\n        hist[int(k,2)] = v\n    fft = np.abs(np.fft.fft(hist))\n    fft[0] = 0\n    periodic_peaks = np.sum(fft > (0.2 * np.max(fft)))\n    assert periodic_peaks > 2, \"Output does not display strong periodicity.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    # >>> ASSERTION START\n    import numpy as np\n    vals = np.array([int(x, 2) for x in result.keys()])\n    hist = np.array(list(result.values()))\n    fft = np.abs(np.fft.fft(hist))\n    fundamental = np.argmax(fft[1:len(fft)//2]) + 1\n    assert fft[fundamental] > 2 * np.mean(fft), \"Output distribution does not show strong periodicity.\"\n    # <<< ASSERTION END\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    import scipy.signal\n    vals = np.zeros(2**program.n_count)\n    for k,v in result.items():\n        vals[int(k,2)] = v\n    fft = np.abs(np.fft.fft(vals))\n    peaks, _ = scipy.signal.find_peaks(fft, height=0.1*np.max(fft))\n    assert len(peaks) >= 2, \"No strong periodicity detected in counting register output\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    # >>> ASSERTION START\n    import collections\n    from scipy.signal import find_peaks\n    arr = np.zeros(2 ** program.n_count)\n    for bstr, c in result.items():\n        idx = int(bstr.replace(\" \", \"\")[::-1], 2)\n        arr[idx] = c\n    arr = arr / arr.sum()\n    fft = np.abs(np.fft.fft(arr))\n    peaks, _ = find_peaks(fft, height=0.05)\n    assert len(peaks) >= 2, \"No strong periodicity detected in measurement results\"\n    # <<< ASSERTION END\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    counts = np.array([v for _, v in sorted(result.items(), key=lambda x: int(x[0], 2))])\n    spectrum = np.abs(np.fft.fft(counts))\n    dominant_freq = np.argmax(spectrum[1:]) + 1\n    periodicity_score = spectrum[dominant_freq] / spectrum[0]\n    assert periodicity_score > 0.2, \"Output distribution does not show strong periodicity.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from collections import Counter\n    from scipy.signal import find_peaks\n\n    values = [int(bitstring, 2) for bitstring in result]\n    freq = np.zeros(2 ** program.n_count)\n    for bitstring, count in result.items():\n        freq[int(bitstring, 2)] = count\n    peaks, _ = find_peaks(freq, height=np.max(freq) * 0.3, distance=2)\n    assert len(peaks) >= 2, \"Output distribution does not exhibit strong periodicity.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.signal import find_peaks\n    hist = np.zeros(2**program.n_count)\n    for b, c in result.items():\n        idx = int(b, 2)\n        hist[idx] = c\n    norm_hist = hist / np.sum(hist)\n    peaks, _ = find_peaks(norm_hist, height=0.03)\n    assert len(peaks) >= 2, \"Output distribution does not exhibit strong periodicity in counting register\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    # >>> ASSERTION START\n    from collections import Counter\n    keys = [int(bitstring, 2) for bitstring in result]\n    spectrum = np.abs(np.fft.fft([result.get(f\"{k:08b}\", 0) for k in range(2**8)]))\n    prominent_peaks = np.sum(spectrum > 0.2 * np.max(spectrum))\n    assert prominent_peaks < 20, \"Output distribution does not exhibit strong periodicity\"\n    # <<< ASSERTION END\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    # >>> ASSERTION START\n    periodicity = np.gcd.reduce([int(bitstr, 2) for bitstr in result if int(bitstr, 2) != 0])\n    assert periodicity > 1, \"Output does not exhibit strong periodicity in the counting register\"\n    # <<< ASSERTION END\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    # >>> ASSERTION START\n    from collections import Counter\n    bitstrings = list(result.keys())\n    int_vals = [int(b, 2) for b in bitstrings]\n    diffs = [j - i for i, j in zip(sorted(int_vals)[:-1], sorted(int_vals)[1:])]\n    periodic = any(diffs.count(d) > 3 and d > 0 for d in set(diffs))\n    assert periodic, \"Output distribution does not exhibit strong periodicity in the counting register.\"\n    # <<< ASSERTION END\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.fft import fft\n    y = np.array([result.get(f\"{i:08b}\", 0) for i in range(2 ** 8)])\n    f = np.abs(fft(y))\n    f[0] = 0\n    assert np.max(f) > 0.2 * np.sum(f), \"Output distribution does not show strong periodicity\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from collections import Counter\n    counts = Counter()\n    for bitstring, c in result.items():\n        counts[int(bitstring, 2)] = c\n    n = program.n_count\n    spectrum = np.fft.fft([counts.get(i,0) for i in range(2**n)])\n    powers = np.abs(spectrum) ** 2\n    top_freqs = np.argsort(powers)[-5:]\n    # Strong periodicity: more than one strong frequency and top not only at zero\n    assert any(f != 0 for f in top_freqs), \"No strong periodicity detected in output distribution\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from collections import Counter\n    from math import gcd\n\n    bitstrings = list(result.keys())\n    n = 8\n    bits_int = [int(x, 2) for x in bitstrings]\n    spectrum = [0]*256\n    for b in bits_int:\n        spectrum[b] = result[format(b, '08b')]\n    spectrum = np.array(spectrum)\n    fft = np.abs(np.fft.fft(spectrum))\n    dominant_freqs = np.argsort(fft)[-5:]\n    freq_gaps = np.diff(np.sort(dominant_freqs))\n    detected_period = np.gcd.reduce(freq_gaps) if len(freq_gaps) > 0 else 0\n    assert detected_period > 1 and fft[dominant_freqs].mean() > 5*np.median(fft), \"Output distribution lacks strong periodicity\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.fft import fft\n    vals = np.array([result.get(f\"{i:08b}\", 0) for i in range(256)])\n    spectrum = np.abs(fft(vals))\n    spectrum[0] = 0\n    assert np.max(spectrum) > 3 * np.median(spectrum), \"Output lacks strong periodicity in counting register\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    # >>> ASSERTION START\n    import collections\n    bitstrings = [int(k, 2) for k in result.keys()]\n    hist = [result.get(format(i, '08b'), 0) for i in range(256)]\n    fft = np.fft.fft(hist)\n    freqs = np.abs(fft)\n    periodic_score = (np.max(freqs[1:]) / np.sum(freqs)) > 0.15\n    assert periodic_score, \"Output distribution does not exhibit strong periodicity in the counting register.\"\n    # <<< ASSERTION END\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.signal import find_peaks\n    data = np.array([result.get(format(i, '08b'), 0) for i in range(2**8)])\n    peaks, _ = find_peaks(data, height=np.max(data)*0.2, distance=2)\n    assert len(peaks) >= 2, \"Output distribution does not exhibit strong periodic peaks.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from collections import Counter\n    bitstrings = [int(bs, 2) for bs in result.keys()]\n    diffs = [abs(bitstrings[i] - bitstrings[j]) for i in range(len(bitstrings)) for j in range(i+1, len(bitstrings))]\n    diffs = [d for d in diffs if d > 0]\n    most_common_diff, freq = Counter(diffs).most_common(1)[0]\n    assert freq > 0.4 * len(diffs), \"Output distribution does not exhibit strong periodicity in counting register.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.signal import find_peaks\n    p = program.n_count\n    histogram = np.zeros(2**p)\n    for bitstring, count in result.items():\n        idx = int(bitstring.replace(' ',''), 2)\n        histogram[idx] = count\n    peaks, _ = find_peaks(histogram, height=np.max(histogram)*0.25, distance=2)\n    assert len(peaks) >= 2, \"Output distribution does not exhibit strong periodicity.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.signal import find_peaks\n    counts_array = np.zeros(2**program.n_count)\n    for bitstring, count in result.items():\n        idx = int(bitstring, 2)\n        counts_array[idx] = count\n    spectrum = np.abs(np.fft.fft(counts_array))\n    peaks, _ = find_peaks(spectrum, height=np.max(spectrum)*0.25)\n    assert len(peaks) >= 2, \"Output distribution does not exhibit strong periodicity in the counting register.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.signal import find_peaks\n    y = np.zeros(2**program.n_count)\n    for bitstring, count in result.items():\n        idx = int(bitstring.replace(' ',''), 2)\n        y[idx] = count\n    peaks, _ = find_peaks(y, height=program.shots * 0.01)\n    assert len(peaks) >= 2, \"Output distribution does not exhibit strong periodicity in the counting register.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.fft import fft\n    y = np.zeros(256)\n    for bitstring, count in result.items():\n        idx = int(bitstring, 2)\n        y[idx] = count\n    spectrum = np.abs(fft(y))\n    spectrum[0] = 0\n    assert np.max(spectrum) > 0.20 * np.sum(spectrum), \"No strong periodicity detected in counting register output\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    bitstrings = np.array([int(bitstr, 2) for bitstr in result.keys()])\n    hist = np.zeros(2**program.n_count)\n    for bitstr, count in result.items():\n        idx = int(bitstr, 2)\n        hist[idx] = count\n    fft = np.abs(np.fft.fft(hist))\n    fft[0] = 0\n    prominent = np.argmax(fft)\n    assert fft[prominent] > 5 * np.mean(fft), \"Output distribution lacks strong periodicity signature\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from scipy.fft import fft\n    counts_arr = np.zeros(2**program.n_count)\n    for b, c in result.items():\n        idx = int(b, 2)\n        counts_arr[idx] = c\n    spectrum = np.abs(fft(counts_arr))\n    periodicity_threshold = 0.2 * np.max(spectrum)\n    significant_freqs = np.sum(spectrum[1:] > periodicity_threshold)\n    assert significant_freqs >= 1, \"Output distribution is not strongly periodic.\"\n    # <<< ASSERTION END"
  },
  {
    "task_id": "QAB30",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n    # >>> ASSERTION START\n    from collections import Counter\n    counts = Counter(result)\n    total = sum(counts.values())\n    bitstrings = [int(k, 2) for k in counts.keys()]\n    spacing = np.gcd.reduce(np.diff(sorted(bitstrings))) if len(bitstrings) > 1 else 0\n    assert spacing > 1, \"Output distribution does not exhibit strong periodicity in counting register.\"\n    # <<< ASSERTION END\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 1,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max([v for k, v in grover.counts.items() if k != grover.target])\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 2,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    sorted_counts = sorted(output.items(), key=lambda x: -x[1])\n    assert sorted_counts[0][0] == grover.target and sorted_counts[0][1] > 5 * (sorted_counts[1][1] if len(sorted_counts) > 1 else 0), \"Target bitstring not sufficiently amplified\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 3,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max([v for k, v in grover.counts.items() if k != grover.target])\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 4,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    sorted_counts = sorted(output.items(), key=lambda x: -x[1])\n    target_count = output.get(grover.target, 0)\n    next_best_count = sorted_counts[1][1] if len(sorted_counts) > 1 else 0\n    assert target_count > 3 * next_best_count, \"Target bitstring was not sufficiently amplified in the output distribution.\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 5,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 10 * max(v for k, v in grover.counts.items() if k != grover.target)\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 6,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max(v for k, v in grover.counts.items() if k != grover.target)\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 7,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    sorted_counts = sorted(output.items(), key=lambda x: -x[1])\n    target_count = output.get(grover.target, 0)\n    assert target_count > 0 and target_count > 5 * max([c for b, c in sorted_counts if b != grover.target][:5]), \"Target bitstring is not sufficiently amplified in the output distribution.\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 8,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > max([grover.counts.get(k, 0) for k in grover.counts if k != grover.target]) and grover.counts[grover.target] > sum(grover.counts.values()) * 0.1\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 9,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max(v for k, v in grover.counts.items() if k != grover.target)\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 10,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max([v for k, v in grover.counts.items() if k != grover.target])\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 11,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > max([count for bit, count in grover.counts.items() if bit != grover.target]) and grover.counts[grover.target] > 0.2 * sum(grover.counts.values()), \"Target bitstring not sufficiently amplified\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 12,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > max(v for k,v in grover.counts.items() if k != grover.target) and grover.counts[grover.target] > 0.1 * sum(grover.counts.values())\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 13,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 10 * max([v for k, v in grover.counts.items() if k != grover.target])\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 14,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    counts = grover.counts\n    target = grover.target\n    total = sum(counts.values())\n    target_count = counts.get(target, 0)\n    max_other_count = max([c for k, c in counts.items() if k != target], default=0)\n    assert target_count > 5 * max_other_count and target_count > 0.1 * total, \"Target bitstring not sufficiently amplified.\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 15,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    sorted_counts = sorted(output.items(), key=lambda x: -x[1])\n    assert sorted_counts[0][0] == grover.target and sorted_counts[0][1] > 5 * sorted_counts[1][1]\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 16,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > max([v for k, v in grover.counts.items() if k != grover.target]) and grover.counts[grover.target] > 0.1 * grover.shots\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 17,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max(count for bitstring, count in grover.counts.items() if bitstring != grover.target)\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 18,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > max(v for k,v in grover.counts.items() if k != grover.target) * 3, \"Target state not sufficiently amplified.\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 19,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > max([v for k, v in grover.counts.items() if k != grover.target]) * 5\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 20,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    target = grover.target\n    counts = grover.counts\n    total = sum(counts.values())\n    target_count = counts.get(target, 0)\n    max_other = max([v for k, v in counts.items() if k != target], default=0)\n    assert target_count > 5 * max_other and target_count > 0.2 * total, \"Target state was not sufficiently amplified\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 21,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    target_count = output.get(grover.target, 0)\n    max_non_target = max([cnt for bs, cnt in output.items() if bs != grover.target], default=0)\n    assert target_count > 4 * max_non_target, \"Target bitstring is not sufficiently amplified.\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 22,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > max(v for k, v in grover.counts.items() if k != grover.target) and grover.counts[grover.target] > 0.2 * grover.shots\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 23,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max([v for k, v in grover.counts.items() if k != grover.target]), \"Target bitstring is not sufficiently amplified.\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 24,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max([v for k, v in grover.counts.items() if k != grover.target]), \"Target bitstring not sufficiently amplified.\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 25,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max([v for k, v in grover.counts.items() if k != grover.target])\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 26,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > max([v for k, v in grover.counts.items() if k != grover.target]) and grover.counts[grover.target] > 0.1 * sum(grover.counts.values())\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 27,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > max([v for k, v in grover.counts.items() if k != grover.target]) and grover.counts[grover.target] > 0.05 * sum(grover.counts.values())\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 28,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > max([v for k, v in grover.counts.items() if k != grover.target]) * 2\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 29,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    counts = output\n    target = grover.target\n    total_shots = grover.shots\n    target_count = counts.get(target, 0)\n    sorted_counts = sorted(counts.items(), key=lambda x: -x[1])\n    if len(sorted_counts) > 1:\n        second_highest = sorted_counts[1][1]\n    else:\n        second_highest = 0\n    assert target_count > 4 * second_highest and target_count > 0.05 * total_shots, \"Target state not sufficiently amplified.\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 30,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > max([v for k, v in grover.counts.items() if k != grover.target]), \"Target bitstring was not sufficiently amplified.\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 31,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max([v for k,v in grover.counts.items() if k != grover.target])\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 32,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max(v for k, v in grover.counts.items() if k != grover.target)\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 33,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max([v for k, v in grover.counts.items() if k != grover.target])\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 34,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    target_count = output.get(grover.target, 0)\n    max_other_count = max([v for k, v in output.items() if k != grover.target], default=0)\n    assert target_count > 5 * max_other_count and target_count > grover.shots * 0.05, \"Target bitstring not sufficiently amplified.\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 35,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max(v for k, v in grover.counts.items() if k != grover.target)\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 36,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > max(v for k, v in grover.counts.items() if k != grover.target) and grover.counts[grover.target] > 0.1 * sum(grover.counts.values())\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 37,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    counts = grover.counts\n    target_count = counts.get(grover.target, 0)\n    sorted_counts = sorted(counts.items(), key=lambda x: -x[1])\n    next_highest = [c for b, c in sorted_counts if b != grover.target]\n    assert target_count > 3 * (next_highest[0] if next_highest else 0), \"Target state not sufficiently amplified.\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 38,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 10 * max([v for k, v in grover.counts.items() if k != grover.target])\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 39,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > max(c for b, c in grover.counts.items() if b != grover.target) * 2, \"Target bitstring is not sufficiently amplified\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 40,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max(v for k, v in grover.counts.items() if k != grover.target)\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 41,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > max([v for k,v in grover.counts.items() if k != grover.target]) and grover.counts[grover.target] > 0.1 * grover.shots\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 42,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    sorted_counts = sorted(output.items(), key=lambda x: -x[1])\n    target = grover.target\n    target_count = output.get(target, 0)\n    rest_counts = [count for bitstring, count in sorted_counts if bitstring != target]\n    assert target_count > 0 and (len(rest_counts) == 0 or target_count > 5 * max(rest_counts)), \"Target bitstring not sufficiently amplified\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 43,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    sorted_counts = sorted(output.items(), key=lambda x: -x[1])\n    target_count = output.get(grover.target, 0)\n    top_other_count = sorted_counts[1][1] if sorted_counts[0][0] == grover.target else sorted_counts[0][1]\n    assert target_count > 3 * top_other_count, \"Target bitstring not sufficiently amplified\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 44,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > max([c for k, c in grover.counts.items() if k != grover.target]) and grover.counts[grover.target] > 0.1 * grover.shots\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 45,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 10 * max([v for k, v in grover.counts.items() if k != grover.target]), \"Target bitstring not sufficiently amplified.\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 46,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    sorted_probs = sorted((v for k, v in output.items() if k != grover.target), reverse=True)\n    target_prob = output.get(grover.target, 0) / sum(output.values())\n    next_best_prob = sorted_probs[0] / sum(output.values()) if sorted_probs else 0\n    assert target_prob > 5 * next_best_prob and target_prob > 0.05, \"Target bitstring not sufficiently amplified\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 47,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    sorted_counts = sorted(output.items(), key=lambda x: -x[1])\n    target_count = output.get(grover.target, 0)\n    max_other = max([c for b, c in output.items() if b != grover.target], default=0)\n    assert target_count > 5 * max_other and target_count > 0.2 * grover.shots, \"Target not sufficiently amplified\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 48,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max(v for k, v in grover.counts.items() if k != grover.target)\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 49,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    assert grover.counts[grover.target] > 5 * max(v for k, v in grover.counts.items() if k != grover.target)\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  },
  {
    "task_id": "QAB31",
    "model": "gpt-4.1",
    "temperature": 0.8,
    "output_index": 50,
    "output_text": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    # >>> ASSERTION START\n    target = grover.target\n    counts = grover.counts\n    total = sum(counts.values())\n    target_count = counts.get(target, 0)\n    top_counts = sorted([v for k, v in counts.items() if k != target], reverse=True)\n    assert target_count > 5 * (top_counts[0] if top_counts else 0) and (target_count / total) > 0.2, \"Target state not sufficiently amplified\"\n    # <<< ASSERTION END\n    grover.summarize_results()\n"
  }
]