{
  "task_id": "QAB24",
  "description": "This quantum program implements Grover's algorithm on 3 qubits. A uniform superposition is prepared using Hadamard gates before applying the oracle and diffusion operator. The task is to generate an assertion that verifies the uniformity of this initial state preparation.\n",
  "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n",
  "complete_prompt": "This quantum program implements Grover's algorithm on 3 qubits.\nBefore the oracle and diffusion operator, the qubits should be prepared in a uniform superposition state.\nInsert an assertion into the program to verify that this initial state preparation\nindeed produces an approximately uniform distribution over all basis states.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformAssertion:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_uniform_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Measure immediately to check uniformity\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_uniform_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        expected_prob = 1 / (2 ** self.n)\n        tolerance = 0.1  # allow ±10%\n        for state in [format(i, \"03b\") for i in range(2 ** self.n)]:\n            prob = counts.get(state, 0) / self.shots\n            assert abs(prob - expected_prob) < tolerance, (\n                f\"State {state} deviates too much: {prob:.3f} vs expected {expected_prob:.3f}\"\n            )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformAssertion()\n    output = grover.run()\n    print(\"Uniform superposition assertion passed.\")\n    print(\"Measurement Counts:\", output)\n",
  "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        # ❌ Faulty: forgot to apply Hadamards, state remains |000>\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
}