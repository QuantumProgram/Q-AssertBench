{
  "task_id": "QAB08",
  "description": "This quantum program constructs a chained interference pattern using a sequence of controlled gates. Only specific output states are expected to appear if the control directions are correct. The task is to generate an assertion that verifies whether the measurement outcomes are confined to a small, known subset of possible states.\n",
  "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
  "complete_prompt": "This quantum program prepares a state using a series of controlled operations. The expected result is that only a small number of specific output patterns should appear in the final distribution.\n\nInsert an assertion into the program to verify that the measurement outcomes are limited to a small, known subset of possible states.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Ensure that only '000' and '111' appear in the measurement output\n        assert set(counts.keys()).issubset({'000', '111'}), f\"Unexpected states found: {set(counts.keys())}\"\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
  "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Faulty CNOT sequence\n        self.circuit.cx(0, 1)  # q0 controls q1 (correct)\n        self.circuit.cx(2, 1)  # ❌ Faulty: reversed direction (should be q1 -> q2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts (Faulty):\", output)\n"
}