{
  "task_id": "QAB01",
  "description": "This quantum circuit prepares five qubits in different states: some deterministic (classical), some in superposition. The goal is to generate an assertion that verifies the presence of both classical and quantum behaviors in the measurement outcomes.\n",
  "program": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n",
  "complete_prompt": "Given the following quantum program, generate a single assertion that verifies the circuit produces a quantum state in which at least one qubit is in a classical state (i.e., always measured as 0 or 1), and at least one qubit is in a superposed state (i.e., measured probabilistically as both 0 and 1).\n    \nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    #print(counts)\n\n    # === GOLD ASSERTION ===\n    # Assert that the circuit generates both classical and quantum behavior\n    # i.e., some qubits consistently yield the same measurement result (classical),\n    # while others exhibit probabilistic outcomes (superposition).\n    n_qubits = len(next(iter(counts)))\n    bit_occurrences = [set() for _ in range(n_qubits)]\n\n    for bitstring in counts:\n        for i, bit in enumerate(reversed(bitstring)):\n            bit_occurrences[i].add(bit)\n\n    # Assert: at least one qubit is always 0 or always 1 (classical)\n    assert any(len(bits) == 1 for bits in bit_occurrences)\n\n    # Assert: at least one qubit has both 0 and 1 across measurements (superposed)\n    assert any(len(bits) == 2 for bits in bit_occurrences)\n    # ======================\n",
  "faulty": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass FaultySuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Replace q1, q2 with H gates — no classical states\n        self.qc.h(0)\n        self.qc.h(1)\n        self.qc.h(2)\n\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n\n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = FaultySuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)"
}