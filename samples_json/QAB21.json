{
  "task_id": "QAB21",
  "description": "This quantum program implements the Quantum Fourier Transform (QFT) on 3 qubits. A periodic input state (|000⟩ + |100⟩)/√2 is prepared before applying QFT. The expected result is a non-uniform measurement distribution with strong peaks, reflecting the Fourier transform of the periodic input. The task is to generate an assertion that verifies the presence of these peaks in the observed distribution.\n",
  "program": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n",
  "complete_prompt": "This quantum program implements the Quantum Fourier Transform (QFT) on a multi-qubit input.\nThe program prepares a periodic input state and then applies QFT.\nInsert an assertion into the program to verify that the resulting measurement distribution is not uniform.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Prepare a periodic input: (|000⟩ + |100⟩)/√2\n    def prepare_periodic(circuit):\n        circuit.h(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # ----- GOLD ASSERTION START -----\n    # Expect distribution not uniform: a few states dominate (>20% each)\n    threshold = 0.20\n    dominant_states = [state for state, cnt in counts.items() if cnt / qft_runner.shots > threshold]\n\n    assert len(dominant_states) > 0, f\"Expected peaks in distribution, got nearly uniform {counts}\"\n    # ----- GOLD ASSERTION END -----\n\n    print(\"QFT Gold Assertion Passed.\")\n    print(\"Measurement Counts:\", counts)\n",
  "faulty": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):# ❌ missing: circuit.h(0)\n        #circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n"
}