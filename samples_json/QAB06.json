{
  "task_id": "QAB06",
  "description": "This quantum program prepares a quantum state where one basis outcome is expected to appear with significantly higher probability than the others. The goal is to generate an assertion that verifies the presence of a dominant state in the output distribution.\n",
  "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
  "complete_prompt": "This quantum program prepares a quantum state in which one basis outcome is expected to occur with much higher probability than the others.\n\nInsert an assertion to check whether the final output contains a dominant basis state in the result distribution.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Bias q[1] toward |1⟩ with a strong rotation\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measure all qubits\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Check if there exists a state with dominant probability\n        dominant_ratio = max(counts.values()) / self.shots\n        assert dominant_ratio > 0.8, f\"No dominant quantum state found. Max ratio: {dominant_ratio:.3f}\"\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
  "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Faulty: Use weaker rotation → probability of q[1] = 1 is lower\n        self.circuit.ry(np.pi / 2, 1)  # Previously was 5π/6\n\n        # Measure all qubits\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts (Faulty):\", output)\n"
}