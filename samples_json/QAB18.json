{
  "task_id": "QAB18",
  "description": "This quantum program implements Simon’s algorithm with hidden period a = \"11\". After measuring the output register, the input register should collapse into states that appear in pairs related by the hidden string. The task is to generate an assertion that verifies the presence of this pairwise structure in the input register measurement results.\n",
  "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n",
  "complete_prompt": "This quantum program implements Simon’s algorithm with a hidden period.\nAfter measuring the output register, the input register should collapse into a state\nthat appears in pairs related by the hidden string.\n\nInsert an assertion into the program to verify that the input register measurement results\nexhibit this pairwise structure.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmPairCheck:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self, circuit):\n        # Oracle for a = \"11\"\n        circuit.cx(0, 2)\n        circuit.cx(1, 2)\n        circuit.cx(0, 3)\n        circuit.cx(1, 3)\n\n    def build_circuit(self):\n        circuit = QuantumCircuit(2 * self.n, 2 * self.n)\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            circuit.h(i)\n        # Step 2: Oracle\n        self.apply_oracle(circuit)\n        # Step 3: Measure output\n        for i in range(self.n):\n            circuit.measure(i + self.n, i + self.n)\n        # Step 4: Measure input\n        for i in range(self.n):\n            circuit.measure(i, i)\n        return circuit\n\n    def run(self):\n        circuit = self.build_circuit()\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Check that input results occur in pairs x and x⊕a\n        def xor_strings(s1, s2):\n            return \"\".join(str(int(b1) ^ int(b2)) for b1, b2 in zip(s1, s2))\n\n        input_counts = {}\n        for bitstring, cnt in counts.items():\n            x = bitstring[-self.n:]  # input part\n            input_counts[x] = input_counts.get(x, 0) + cnt\n\n        for x in input_counts:\n            x_pair = xor_strings(x, self.a)\n            if x_pair in input_counts:\n                continue\n            else:\n                raise AssertionError(f\"Input {x} did not appear with its pair {x_pair}\")\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    checker = SimonsAlgorithmPairCheck()\n    output = checker.run()\n    print(\"Pairwise Structure Test, Measurement Counts:\", output)\n",
  "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Faulty Simon's Algorithm:\n        Oracle is missing some CX gates, leading to incorrect pairwise output structure.\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # same structure as program.py\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # ❌ Faulty oracle: missing a connection to qubit 3\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        #self.circuit.cx(0, 3)  # Missing\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input register\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Faulty Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard again on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input register only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Faulty Oracle Measurement Counts:\", output)\n"
}