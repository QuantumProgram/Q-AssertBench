{
  "task_id": "QAB17",
  "description": "This quantum program implements Simon’s algorithm with a hidden period a = \"11\". At the beginning of the algorithm, the input qubits are placed into a uniform superposition state. The task is to generate an assertion that verifies whether this uniform distribution has been correctly prepared.\n",
  "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n",
  "complete_prompt": "This quantum program constructs the initial uniform superposition state required by Simon’s algorithm.\nThe input qubits are placed into an equal superposition of all basis states before the oracle is applied.\n\nInsert a verification step into the program that checks whether this uniform superposition is properly prepared.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmUniformCheck:\n    def __init__(self, n=2, shots=1024):\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_uniform_superposition(self):\n        circuit = QuantumCircuit(self.n, self.n)\n        for i in range(self.n):\n            circuit.h(i)\n        for i in range(self.n):\n            circuit.measure(i, i)\n        return circuit\n\n    def run(self):\n        circuit = self.build_uniform_superposition()\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        expected_prob = 1 / (2**self.n)\n        tolerance = 0.15\n        for state in [format(i, f\"0{self.n}b\") for i in range(2**self.n)]:\n            prob = counts.get(state, 0) / self.shots\n            assert abs(prob - expected_prob) < tolerance, (\n                f\"State {state} has probability {prob:.3f}, expected ~{expected_prob:.3f}\"\n            )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    checker = SimonsAlgorithmUniformCheck()\n    output = checker.run()\n    print(\"Uniform Superposition Test, Measurement Counts:\", output)\n",
  "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Faulty version of Simon's Algorithm.\n        Only applies Hadamard to one input qubit instead of both.\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Faulty Hadamard (only on first input qubit)\n        self.circuit.h(0)  # ❌ should apply to both 0 and 1\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again (both correct)\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
}