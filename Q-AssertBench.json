[
  {
    "task_id": "QAB01",
    "description": "This quantum circuit prepares five qubits in different states: some deterministic (classical), some in superposition. The goal is to generate an assertion that verifies the presence of both classical and quantum behaviors in the measurement outcomes.\n",
    "program": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)\n\n",
    "complete_prompt": "Given the following quantum program, generate a single assertion that verifies the circuit produces a quantum state in which at least one qubit is in a classical state (i.e., always measured as 0 or 1), and at least one qubit is in a superposed state (i.e., measured probabilistically as both 0 and 1).\n    \nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass SuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Qubit 0: Superposition\n        self.qc.h(0)\n\n        # Qubits 1, 2: Classical 1 and 0\n        self.qc.x(1)\n        # Qubit 2 remains in |0⟩\n\n        # Qubit 3: U3 for ~1/3 probability of |1⟩\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n\n        # Qubit 4: U3 for ~2/3 probability of |1⟩\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n    \n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = SuperpositionCircuit()\n    counts = circuit.run()\n    #print(counts)\n\n    # === GOLD ASSERTION ===\n    # Assert that the circuit generates both classical and quantum behavior\n    # i.e., some qubits consistently yield the same measurement result (classical),\n    # while others exhibit probabilistic outcomes (superposition).\n    n_qubits = len(next(iter(counts)))\n    bit_occurrences = [set() for _ in range(n_qubits)]\n\n    for bitstring in counts:\n        for i, bit in enumerate(reversed(bitstring)):\n            bit_occurrences[i].add(bit)\n\n    # Assert: at least one qubit is always 0 or always 1 (classical)\n    assert any(len(bits) == 1 for bits in bit_occurrences)\n\n    # Assert: at least one qubit has both 0 and 1 across measurements (superposed)\n    assert any(len(bits) == 2 for bits in bit_occurrences)\n    # ======================\n",
    "faulty": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom math import pi\n\nclass FaultySuperpositionCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(5, 5)\n        self._build()\n        \n    def _build(self):\n        # Replace q1, q2 with H gates — no classical states\n        self.qc.h(0)\n        self.qc.h(1)\n        self.qc.h(2)\n\n        self.qc.u(2 * pi / 3, 0, 0, 3)\n        self.qc.u(2 * pi / 9, 0, 0, 4)\n\n        self.qc.measure(range(5), range(5))\n\n    def run(self):\n        backend = Aer.get_backend('qasm_simulator')\n        job = backend.run(self.qc, shots=1024)\n        return job.result().get_counts()\n\nif __name__ == \"__main__\":\n    circuit = FaultySuperpositionCircuit()\n    counts = circuit.run()\n    print(counts)"
  },
  {
    "task_id": "QAB02",
    "description": "The program prepares a 2-qubit Bell state using a Hadamard gate and a CNOT gate. The final quantum state should be an entangled state (|00⟩ + |11⟩)/√2, where both measurement outcomes appear with roughly equal probability. The goal is to assert whether the entanglement behavior is preserved through the measurements.\n",
    "program": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n\n",
    "complete_prompt": "Given the following quantum program, generate a single assertion that verifies whether the two qubits are entangled in a Bell state.\n    \nOutput the complete modified program with the assertion included. No explanations, no comments, no step-by-step thinking.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass BellStateCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.cx(0, 1)\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = BellStateCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    #print(counts)\n    \n    # === GOLD ASSERTION ===\n    shots = 1024\n    ratio_00 = counts.get('00', 0) / shots\n    ratio_11 = counts.get('11', 0) / shots\n    assert all(k in ['00', '11'] for k in counts), \"Unexpected outcomes detected\"\n    assert 0.4 <= ratio_00 <= 0.6 and 0.4 <= ratio_11 <= 0.6, \"Imbalanced distribution — likely not Bell state\"\n    # ======================\n\n",
    "faulty": "from qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\n\nclass NonEntangledCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(2, 2)\n\n    def build(self):\n        self.qc.h(0)\n        self.qc.h(1)  # Fault: both qubits in superposition, but not entangled\n        self.qc.measure([0, 1], [0, 1])\n        return self.qc\n\nif __name__ == \"__main__\":\n    circuit = NonEntangledCircuit().build()\n    backend = Aer.get_backend('qasm_simulator')\n    job = backend.run(circuit, shots=1024)\n    result = job.result()\n    counts = result.get_counts()\n    print(counts)\n"
  },
  {
    "task_id": "QAB03",
    "description": "This circuit initializes three qubits with fixed probabilities of measuring |1⟩, then applies two SWAP operations to move the quantum state of qubit 2 to qubit 0. The task is to generate an assertion that verifies whether the final measurement probability of qubit 0 matches that of the original qubit 2.\n",
    "program": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # The probability that q0, q1, q2 are measured to be \"1\"\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run()\n",
    "complete_prompt": "Generate an assertion for the following Qiskit program to verify that qubit q0 ends up in the same quantum state that was initially prepared in qubit q2. The assertion should be inserted in an appropriate location and be expressed in Python code.\n    \nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass SwapCircuitWithAssertion:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # Probabilities for q0, q1, q2\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # After swaps, q0 will hold initial state of q?\n\n    def _apply_swaps(self):\n        self.qc.swap(2, 1)\n        self.qc.swap(0, 1)\n\n    def run_and_assert(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n        # Measure probability of q0 = 1\n        counts_1 = sum(v for k, v in self.counts.items() if k[-1] == \"1\")\n        prob_q0 = counts_1 / shots\n\n        assert abs(prob_q0 - 0.7) < tolerance, (\n            f\"q0 measured probability {prob_q0:.3f} \"\n            f\"does not match expected {self.expected_prob_q0:.3f}\"\n        )\n\n\nif __name__ == \"__main__\":\n    circuit = SwapCircuitWithAssertion()\n    circuit.run_and_assert()\n",
    "faulty": "import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import U3Gate\n\n\nclass FaultySwapCircuit:\n    def __init__(self):\n        self.qc = QuantumCircuit(3, 3)\n        self.expected_prob_q0 = None\n        self._initialize_qubits()\n        self._apply_swaps()\n        self.qc.measure([0, 1, 2], [0, 1, 2])\n        self.counts = None\n\n    def _initialize_qubits(self):\n        # Probabilities for q0, q1, q2\n        probs = [0.2, 0.5, 0.7]\n\n        for i, p in enumerate(probs):\n            theta = 2 * np.arcsin(np.sqrt(p))\n            self.qc.append(U3Gate(theta, 0, 0), [i])\n\n        # Expectation: q0 should match q2 (The probability of being at ‘1’ is 0.7), but swap order is wrong\n        self.expected_prob_q0 = probs[2]\n\n    def _apply_swaps(self):\n        self.qc.swap(0, 1)\n        self.qc.swap(2, 1)\n\n    def run(self, shots=1024, tolerance=0.1):\n        backend = Aer.get_backend(\"qasm_simulator\")\n        job = backend.run(self.qc, shots=shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n\nif __name__ == \"__main__\":\n    circuit = FaultySwapCircuit()\n    circuit.run()\n"
  },
  {
    "task_id": "QAB04",
    "description": "This quantum program applies a single parameterized Pauli gate to a qubit, resulting in a non-uniform measurement probability distribution. The goal is to generate an assertion that verifies whether the observed measurement statistics align with the expected probabilistic behavior.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum program applies a single parameterized Pauli gate to a qubit before measurement. \nThe resulting measurement outcome is expected to follow a specific non-uniform probability distribution.\n\nYour task is to generate a code snippet that adds an assertion verifying whether the observed measurement statistics reflect the expected probabilistic behavior.\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        #self.circuit.rx(np.pi / 2, 0)\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        self.circuit.z(0)\n\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Compute the probability of measuring '1' and assert it's approximately 0.75\n        p1 = counts.get(\"1\", 0) / self.shots\n        assert abs(p1 - 0.75) < 0.05, f\"Assertion failed: P(1) = {p1:.3f}, expected ≈ 0.75\"\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Use RY(θ) with θ = 2π/3 to get 0.75/0.25 probability distribution\n        self.circuit.ry(1 * np.pi / 4, 0)\n\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)"
  },
  {
    "task_id": "QAB05",
    "description": "This quantum program applies a series of Pauli gates (X, Y, Z) to a single qubit, influencing the final probability distribution of measurement outcomes. The goal is to generate an assertion that verifies the expected probabilistic behavior induced by the composition of non-commutative Pauli operations.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum circuit applies a combination of parameterized Pauli gates to a single qubit. \nThe gates are applied in sequence and may interact in non-trivial ways to affect the measurement outcome probabilities.\n\nYour task is to generate a code snippet that adds an assertion verifying whether the measurement results are consistent with the expected probabilistic behavior of the circuit.\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        \n        self.circuit.rx(np.pi / 2, 0)\n        \n        self.circuit.ry(2 * np.pi / 3, 0)\n        \n        self.circuit.z(0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Compute the probability of measuring '1' and assert it's approximately 0.75\n        p1 = counts.get(\"1\", 0) / self.shots\n        assert abs(p1 - 0.5) < 0.05, f\"Assertion failed: P(1) = {p1:.3f}, expected ≈ 0.75\"\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB06",
    "description": "This quantum program prepares a quantum state where one basis outcome is expected to appear with significantly higher probability than the others. The goal is to generate an assertion that verifies the presence of a dominant state in the output distribution.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩ using X gates → binary: 1x1x1 (positions: 3 2 1 0)\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Rotate q[1] toward |1⟩ → controls probability of full 1101 state\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum program prepares a quantum state in which one basis outcome is expected to occur with much higher probability than the others.\n\nInsert an assertion to check whether the final output contains a dominant basis state in the result distribution.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Bias q[1] toward |1⟩ with a strong rotation\n        self.circuit.ry(1 * np.pi / 6, 1)\n\n        # Measure all qubits\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Check if there exists a state with dominant probability\n        dominant_ratio = max(counts.values()) / self.shots\n        assert dominant_ratio > 0.8, f\"No dominant quantum state found. Max ratio: {dominant_ratio:.3f}\"\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass QuantumStateDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Set q[0], q[2], q[3] to |1⟩\n        self.circuit.x(0)\n        self.circuit.x(2)\n        self.circuit.x(3)\n\n        # Faulty: Use weaker rotation → probability of q[1] = 1 is lower\n        self.circuit.ry(np.pi / 2, 1)  # Previously was 5π/6\n\n        # Measure all qubits\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = QuantumStateDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts (Faulty):\", output)\n"
  },
  {
    "task_id": "QAB07",
    "description": "This quantum program prepares a quantum state where all possible basis states are expected to appear with roughly equal probability. The goal is to generate an assertion that verifies the uniformity of the output distribution.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement (optional but makes LLM analysis more challenging)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum program prepares a quantum state where all possible outcomes are expected to occur with roughly equal probability.\n\nInsert a Python assertion into the program to verify that the output distribution is approximately uniform.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on all qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.h(2)\n\n        # Step 2: Add light entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Assert that the output distribution is approximately uniform\n        probs = [count / self.shots for count in counts.values()]\n        assert max(probs) - min(probs) < 0.1, f\"Distribution not uniform enough: max-min = {max(probs) - min(probs):.3f}\"\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass UniformDistributionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Faulty: Apply Hadamard only to qubit 0 and 2, omit q[1]\n        self.circuit.h(0)\n        # self.circuit.h(1)  # <-- Removed on purpose\n        self.circuit.h(2)\n\n        # Entanglement (still applied)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n\n        # Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = UniformDistributionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts (Faulty):\", output)\n"
  },
  {
    "task_id": "QAB08",
    "description": "This quantum program constructs a chained interference pattern using a sequence of controlled gates. Only specific output states are expected to appear if the control directions are correct. The task is to generate an assertion that verifies whether the measurement outcomes are confined to a small, known subset of possible states.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum program prepares a state using a series of controlled operations. The expected result is that only a small number of specific output patterns should appear in the final distribution.\n\nInsert an assertion into the program to verify that the measurement outcomes are limited to a small, known subset of possible states.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Controlled propagation\n        self.circuit.cx(0, 1)  # q0 controls q1\n        self.circuit.cx(1, 2)  # q1 controls q2\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Ensure that only '000' and '111' appear in the measurement output\n        assert set(counts.keys()).issubset({'000', '111'}), f\"Unexpected states found: {set(counts.keys())}\"\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass InterferenceControlCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 3)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Create superposition on q0\n        self.circuit.h(0)\n\n        # Step 2: Faulty CNOT sequence\n        self.circuit.cx(0, 1)  # q0 controls q1 (correct)\n        self.circuit.cx(2, 1)  # ❌ Faulty: reversed direction (should be q1 -> q2)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(3), range(3))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = InterferenceControlCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts (Faulty):\", output)\n"
  },
  {
    "task_id": "QAB09",
    "description": "This quantum program prepares a two-qubit quantum state where the measurement results of the qubits are expected to be strongly correlated. The goal is to generate an assertion that verifies this correlation, serving as evidence of entanglement in the system.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum program prepares a two-qubit quantum state with strong measurement correlation between the two qubits.\n\nInsert an assertion into the program that checks whether the measurement results of the two qubits are highly correlated.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 in superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 and q1\n        self.circuit.cx(0, 1)\n\n        # Step 3: Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Compute marginal and joint probabilities\n        p_q0_1 = sum(v for k, v in counts.items() if k[0] == \"1\") / self.shots\n        p_q1_1 = sum(v for k, v in counts.items() if k[1] == \"1\") / self.shots\n        p_q0q1_11 = counts.get(\"11\", 0) / self.shots\n\n        # Difference between observed joint and independent expectation\n        expected_independent = p_q0_1 * p_q1_1\n        diff = abs(p_q0q1_11 - expected_independent)\n\n        # Assert strong correlation (positive or negative)\n        assert diff > 0.1, (\n            f\"No strong correlation detected: \"\n            f\"joint={p_q0q1_11:.3f}, independent={expected_independent:.3f}, diff={diff:.3f}\"\n        )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass EntanglementDetectionCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Faulty: Put q0 in superposition, but remove entanglement\n        self.circuit.h(0)\n\n        # ❌ Missing CX(0, 1) — no entanglement created\n\n        # Measurement\n        self.circuit.measure([0, 1], [0, 1])\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = EntanglementDetectionCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts (Faulty):\", output)\n"
  },
  {
    "task_id": "QAB10",
    "description": "This quantum program prepares a four-qubit GHZ state, an example of a maximally entangled multi-qubit system. The expected measurement outcomes are only '0000' and '1111'. The task is to generate an assertion that verifies this entangled behavior by checking that no unexpected states appear in the output distribution.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Entangle q0 with q1, then cascade entanglement\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum program prepares a highly entangled four-qubit state in which only a small number of basis outcomes should appear.\n\nInsert an assertion into the program to verify that the measurement results are limited to this expected subset of states.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Cascade entanglement to other qubits (GHZ construction)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Ensure that only '0000' and '1111' dominate the measurement results\n        valid_ratio = sum(v for k, v in counts.items() if k in [\"0000\", \"1111\"]) / self.shots\n        assert valid_ratio > 0.9, f\"Unexpected states found: {counts}\"\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass GHZEntanglementCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(4, 4)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Put q0 into superposition\n        self.circuit.h(0)\n\n        # Step 2: Incorrect entanglement (last CX reversed)\n        self.circuit.cx(0, 1)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(3, 2)  # ❌ faulty: should be cx(2, 3)\n\n        # Step 3: Measurement\n        self.circuit.measure(range(4), range(4))\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = GHZEntanglementCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts (Faulty):\", output)\n"
  },
  {
    "task_id": "QAB11",
    "description": "This quantum program implements the Deutsch algorithm with a fixed oracle corresponding to f(x) = x, a balanced function. The task is to generate an assertion that verifies this expected outcome.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum program implements the Deutsch algorithm for a specific oracle.\nThe expected measurement outcome of the first qubit is deterministic and corresponds to the nature of the oracle.\nInsert an assertion into the program to check that the output matches the expected result for this oracle.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle for f(x) = x (balanced function)\n        self.circuit.cx(0, 1)\n\n        # Step 4: Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the first qubit (decision qubit)\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Deutsch Algorithm Decision Rule:\n        # - If f(x) is CONSTANT -> q0 always measured as 0\n        # - If f(x) is BALANCED -> q0 always measured as 1\n        #\n        # Our oracle implements f(x) = x, which is BALANCED.\n        # Therefore, we expect nearly all measurement results to be '1'.\n        assert \"1\" in counts and counts[\"1\"] > 0.9 * self.shots, (\n            f\"Expected balanced function outcome (q0=1), but got counts = {counts}\"\n        )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        # 2 qubits, but only 1 classical bit is needed (for q0)\n        self.circuit = QuantumCircuit(2, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Initialize ancilla qubit in |1⟩\n        self.circuit.x(1)\n\n        # Prepare superposition\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # ❌ Faulty: Use identity instead of CX oracle (constant function)\n        # self.circuit.cx(0, 1)\n\n        # Apply Hadamard gates again\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Measure only the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschAlgorithmCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n\n"
  },
  {
    "task_id": "QAB12",
    "description": "This quantum program implements the Deutsch algorithm with a configurable oracle. The oracle type is set by a parameter: oracle_type=0 corresponds to a constant function, while oracle_type=1 corresponds to a balanced function. The expected measurement outcome of the first qubit is deterministic and should match the oracle type. The task is to insert an assertion that verifies consistency between the oracle parameter and the observed result.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x)=x → CX(q0, q1)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard again to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example: try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum program implements the Deutsch algorithm with a configurable oracle.\nThe oracle type is determined by a parameter, and the expected outcome of the measurement depends on this setting.\n\nInsert an assertion into the program that verifies the consistency between the oracle parameter and the observed result.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function (f(x) = 0)\n        oracle_type = 1 → balanced function (f(x) = x)\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant function f(x) = 0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced function f(x) = x\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates to both qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard gate to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Deutsch Algorithm decision rule:\n        # - If oracle_type = 0 (constant), q0 should always be '0'\n        # - If oracle_type = 1 (balanced), q0 should always be '1'\n        if self.oracle_type == 0:\n            assert \"0\" in counts and counts[\"0\"] > 0.9 * self.shots, (\n                f\"Expected constant function outcome (q0=0), but got {counts}\"\n            )\n        elif self.oracle_type == 1:\n            assert \"1\" in counts and counts[\"1\"] > 0.9 * self.shots, (\n                f\"Expected balanced function outcome (q0=1), but got {counts}\"\n            )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    # Try both oracle types\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschAlgorithmCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Faulty version:\n        Even if oracle_type=0 (constant), the oracle is implemented incorrectly as balanced.\n        This inconsistency will cause the assertion to fail.\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(2, 1)  # 2 qubits, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # ❌ Faulty: instead of doing nothing, apply CX (balanced function)\n            self.circuit.cx(0, 1)\n        elif self.oracle_type == 1:\n            # Balanced function f(x) = x (this part is correct)\n            self.circuit.cx(0, 1)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit q1 in |1⟩\n        self.circuit.x(1)\n\n        # Step 2: Apply Hadamard gates\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to the first qubit\n        self.circuit.h(0)\n\n        # Step 5: Measure the first qubit\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschAlgorithmCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Faulty Oracle type {oracle_type}, Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB13",
    "description": "This quantum program implements the Deutsch Jozsa algorithm with two input qubits and one ancilla qubit. The oracle is fixed as a balanced function f(x0, x1) = x0 XOR x1. The expected measurement outcome is that the input qubits should never be observed as '00', which would indicate a constant function. The task is to insert an assertion that verifies this expected property.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed oracle (balanced).\n        Function chosen: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum program implements the Deutsch–Jozsa algorithm with a fixed oracle.\nThe expected measurement results of the input qubits should clearly indicate that the oracle is not constant.\n\nInsert an assertion into the program to verify that the observed results are consistent with this property.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Deutsch-Jozsa Algorithm with fixed balanced oracle.\n        Function: f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Balanced oracle: f(x0, x1) = x0 XOR x1\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # For a balanced function, the measurement result should not be all zeros.\n        zero_counts = counts.get(\"00\", 0)\n        assert zero_counts < 0.1 * self.shots, f\"Unexpected constant-like result: {counts}\"\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Faulty version: Oracle implemented as constant function f(x)=0\n        This breaks the expected balanced behavior.\n        \"\"\"\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # ❌ Faulty: constant oracle, do nothing\n        pass\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle (faulty: constant)\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure only the input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = DeutschJozsaCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts (Faulty):\", output)\n"
  },
  {
    "task_id": "QAB14",
    "description": "This quantum program implements the Deutsch–Jozsa algorithm with two input qubits and one ancilla qubit. The oracle type is determined by a parameter: oracle_type=0 corresponds to a constant function, while oracle_type=1 corresponds to a balanced function. The expected measurement outcomes differ accordingly: - For constant: the input qubits should be observed as '00'. - For balanced: the input qubits should not be observed as '00'. The task is to generate an assertion that verifies consistency between the oracle type and the observed measurement results.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Deutsch–Jozsa Algorithm with configurable oracle.\n\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)  # 2 input qubits + 1 ancilla, 2 classical bits\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            # Constant oracle f(x)=0 → do nothing\n            pass\n        elif self.oracle_type == 1:\n            # Balanced oracle f(x0, x1) = x0 XOR x1\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(2)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(3):\n            self.circuit.h(i)\n\n        # Step 3: Oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        self.circuit.h(0)\n        self.circuit.h(1)\n\n        # Step 5: Measure input qubits\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum program implements the Deutsch–Jozsa algorithm with a configurable oracle.\nThe oracle type is selected by a parameter, which determines whether the function is constant or balanced.\nInsert an assertion into the program that verifies consistency between the oracle parameter and the measurement results.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        oracle_type = 0 → constant function f(x)=0\n        oracle_type = 1 → balanced function f(x0, x1) = x0 XOR x1\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        if self.oracle_type == 0:\n            pass\n        elif self.oracle_type == 1:\n            self.circuit.cx(0, 2)\n            self.circuit.cx(1, 2)\n        else:\n            raise ValueError(\"oracle_type must be 0 or 1\")\n\n    def build_circuit(self):\n        self.circuit.x(2)\n        for i in range(3):\n            self.circuit.h(i)\n        self.apply_oracle()\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        if self.oracle_type == 0:\n            # Constant oracle → Expect nearly all results '00'\n            assert \"00\" in counts and counts[\"00\"] > 0.9 * self.shots, (\n                f\"Expected constant outcome '00', got {counts}\"\n            )\n        elif self.oracle_type == 1:\n            # Balanced oracle → Input qubits should not be all zero\n            zero_counts = counts.get(\"00\", 0)\n            assert zero_counts < 0.1 * self.shots, (\n                f\"Expected balanced outcome (non-zero states), got {counts}\"\n            )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Oracle type {oracle_type}, Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass DeutschJozsaCircuit:\n    def __init__(self, oracle_type=0, shots=1024):\n        \"\"\"\n        Faulty version: Oracle always implemented as balanced, even if oracle_type=0\n        \"\"\"\n        self.oracle_type = oracle_type\n        self.shots = shots\n        self.circuit = QuantumCircuit(3, 2)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # ❌ Faulty: always balanced\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n\n    def build_circuit(self):\n        self.circuit.x(2)\n        for i in range(3):\n            self.circuit.h(i)\n        self.apply_oracle()\n        self.circuit.h(0)\n        self.circuit.h(1)\n        self.circuit.measure(0, 0)\n        self.circuit.measure(1, 1)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    for oracle_type in [0, 1]:\n        circuit_runner = DeutschJozsaCircuit(oracle_type=oracle_type)\n        output = circuit_runner.run()\n        print(f\"Faulty Oracle type {oracle_type}, Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB15",
    "description": "This quantum program implements the Bernstein–Vazirani algorithm with three input qubits and one ancilla qubit. A critical step in the algorithm is the preparation of a uniform superposition across all input qubits. The task is to generate an assertion that verifies this uniform distribution, ensuring that the Hadamard layer has been correctly applied.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum program implements the Bernstein–Vazirani algorithm.\nAt the beginning of the algorithm, the input qubits should be placed into a uniform superposition.\nInsert an assertion into the program to verify that the prepared state indeed corresponds to a uniform distribution.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        Assertion: check that uniform superposition is correctly prepared.\n        \"\"\"\n        self.a = a\n        self.n = len(a)\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_uniform_superposition(self):\n        circuit = QuantumCircuit(self.n, self.n)  # only input qubits (ignore ancilla for this check)\n\n        # Prepare |0^n>\n        # Apply Hadamards to all input qubits\n        for i in range(self.n):\n            circuit.h(i)\n\n        # Add measurement\n        for i in range(self.n):\n            circuit.measure(i, i)\n\n        return circuit\n\n    def run(self):\n        circuit = self.build_uniform_superposition()\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Expect uniform distribution across all 2^n states\n        expected_prob = 1 / (2**self.n)\n        tolerance = 0.1  # allow ~10% deviation\n\n        for state in [format(i, f\"0{self.n}b\") for i in range(2**self.n)]:\n            prob = counts.get(state, 0) / self.shots\n            assert abs(prob - expected_prob) < tolerance, (\n                f\"State {state} has probability {prob:.3f}, expected ~{expected_prob:.3f}\"\n            )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Uniform Superposition Test, Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits (prepare uniform superposition)\n        for i in range(self.n + 1):\n            if i != 1:  # ❌ faulty: skip H on qubit 1\n                self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB16",
    "description": "This quantum program implements the Bernstein–Vazirani algorithm with three input qubits and one ancilla qubit. The oracle encodes a hidden binary string a, and the final measurement of the input qubits should reveal this string with high probability. The task is to generate an assertion that verifies whether the observed measurement matches the hidden string.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum program implements the Bernstein–Vazirani algorithm.\nThe final measurement should reveal the hidden binary string encoded in the oracle.\nInsert an assertion into the program to check that the observed result matches the hidden string.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        self.a = a\n        self.n = len(a)\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n        self.circuit = QuantumCircuit(self.n + 1, self.n)\n\n    def apply_oracle(self):\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)\n\n    def build_circuit(self):\n        self.circuit.x(self.n)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n        self.apply_oracle()\n        for i in range(self.n):\n            self.circuit.h(i)\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # The final measurement should reveal the hidden string a\n        assert self.a in counts and counts[self.a] > 0.9 * self.shots, (\n            f\"Expected outcome {self.a}, but got {counts}\"\n        )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        self.a = a\n        self.n = len(a)\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n        self.circuit = QuantumCircuit(self.n + 1, self.n)\n\n    def apply_oracle(self):\n        # ❌ Faulty: forget to encode last bit of a\n        for i, bit in enumerate(self.a[:-1]):  # skip last bit\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)\n\n    def build_circuit(self):\n        self.circuit.x(self.n)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n        self.apply_oracle()\n        for i in range(self.n):\n            self.circuit.h(i)\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Faulty Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB17",
    "description": "This quantum program implements Simon’s algorithm with a hidden period a = \"11\". At the beginning of the algorithm, the input qubits are placed into a uniform superposition state. The task is to generate an assertion that verifies whether this uniform distribution has been correctly prepared.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum program constructs the initial uniform superposition state required by Simon’s algorithm.\nThe input qubits are placed into an equal superposition of all basis states before the oracle is applied.\n\nInsert a verification step into the program that checks whether this uniform superposition is properly prepared.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmUniformCheck:\n    def __init__(self, n=2, shots=1024):\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_uniform_superposition(self):\n        circuit = QuantumCircuit(self.n, self.n)\n        for i in range(self.n):\n            circuit.h(i)\n        for i in range(self.n):\n            circuit.measure(i, i)\n        return circuit\n\n    def run(self):\n        circuit = self.build_uniform_superposition()\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        expected_prob = 1 / (2**self.n)\n        tolerance = 0.15\n        for state in [format(i, f\"0{self.n}b\") for i in range(2**self.n)]:\n            prob = counts.get(state, 0) / self.shots\n            assert abs(prob - expected_prob) < tolerance, (\n                f\"State {state} has probability {prob:.3f}, expected ~{expected_prob:.3f}\"\n            )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    checker = SimonsAlgorithmUniformCheck()\n    output = checker.run()\n    print(\"Uniform Superposition Test, Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Faulty version of Simon's Algorithm.\n        Only applies Hadamard to one input qubit instead of both.\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Faulty Hadamard (only on first input qubit)\n        self.circuit.h(0)  # ❌ should apply to both 0 and 1\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again (both correct)\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB18",
    "description": "This quantum program implements Simon’s algorithm with hidden period a = \"11\". After measuring the output register, the input register should collapse into states that appear in pairs related by the hidden string. The task is to generate an assertion that verifies the presence of this pairwise structure in the input register measurement results.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum program implements Simon’s algorithm with a hidden period.\nAfter measuring the output register, the input register should collapse into a state\nthat appears in pairs related by the hidden string.\n\nInsert an assertion into the program to verify that the input register measurement results\nexhibit this pairwise structure.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmPairCheck:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self, circuit):\n        # Oracle for a = \"11\"\n        circuit.cx(0, 2)\n        circuit.cx(1, 2)\n        circuit.cx(0, 3)\n        circuit.cx(1, 3)\n\n    def build_circuit(self):\n        circuit = QuantumCircuit(2 * self.n, 2 * self.n)\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            circuit.h(i)\n        # Step 2: Oracle\n        self.apply_oracle(circuit)\n        # Step 3: Measure output\n        for i in range(self.n):\n            circuit.measure(i + self.n, i + self.n)\n        # Step 4: Measure input\n        for i in range(self.n):\n            circuit.measure(i, i)\n        return circuit\n\n    def run(self):\n        circuit = self.build_circuit()\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Check that input results occur in pairs x and x⊕a\n        def xor_strings(s1, s2):\n            return \"\".join(str(int(b1) ^ int(b2)) for b1, b2 in zip(s1, s2))\n\n        input_counts = {}\n        for bitstring, cnt in counts.items():\n            x = bitstring[-self.n:]  # input part\n            input_counts[x] = input_counts.get(x, 0) + cnt\n\n        for x in input_counts:\n            x_pair = xor_strings(x, self.a)\n            if x_pair in input_counts:\n                continue\n            else:\n                raise AssertionError(f\"Input {x} did not appear with its pair {x_pair}\")\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    checker = SimonsAlgorithmPairCheck()\n    output = checker.run()\n    print(\"Pairwise Structure Test, Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Faulty Simon's Algorithm:\n        Oracle is missing some CX gates, leading to incorrect pairwise output structure.\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # same structure as program.py\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # ❌ Faulty oracle: missing a connection to qubit 3\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        #self.circuit.cx(0, 3)  # Missing\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input register\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Faulty Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard again on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input register only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Faulty Oracle Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB19",
    "description": "This quantum program implements Simon’s algorithm with hidden period a = \"11\". In the final step, the measurement results of the input qubits must satisfy the constraint z·a=0 (mod 2), where z is the observed bitstring and a is the hidden string. For a = \"11\", only '00' and '11' should appear, while '01' and '10' are invalid. The task is to generate an assertion that verifies this property in the observed results.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        \"\"\"\n        Simon's Algorithm with hidden period a = \"11\"\n        \"\"\"\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.circuit = QuantumCircuit(2 * self.n, self.n)  # measure only input register\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        # Step 1: Hadamard on input\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 2: Oracle\n        self.apply_oracle()\n\n        # Step 3: Hadamard on input again\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 4: Measure input qubits only\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n",
    "complete_prompt": "This quantum program implements Simon’s algorithm with a hidden period.\nThe final measurement results of the input qubits are expected to satisfy a linear constraint with respect to the hidden string.\nInsert an assertion into the program to check that the observed input results meet this constraint.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmConstraintCheck:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n        self.circuit = QuantumCircuit(2 * self.n, self.n)\n\n    def apply_oracle(self):\n        # Oracle for a = \"11\"\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        self.circuit.cx(1, 3)\n\n    def build_circuit(self):\n        for i in range(self.n):\n            self.circuit.h(i)\n        self.apply_oracle()\n        for i in range(self.n):\n            self.circuit.h(i)\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # For a = \"11\", valid z must satisfy z0+z1 ≡ 0 (mod 2)\n        for z, cnt in counts.items():\n            dot = (int(z[0]) * int(self.a[0]) + int(z[1]) * int(self.a[1])) % 2\n            assert dot == 0, f\"Invalid result {z} violates constraint z·a=0\"\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    checker = SimonsAlgorithmConstraintCheck()\n    output = checker.run()\n    print(\"Constraint Test, Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass SimonsAlgorithmCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.n = 2\n        self.a = \"11\"\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n        self.circuit = QuantumCircuit(2 * self.n, self.n)\n\n    def apply_oracle(self):\n        # ❌ Faulty oracle: missing one CX connection\n        self.circuit.cx(0, 2)\n        self.circuit.cx(1, 2)\n        self.circuit.cx(0, 3)\n        # skip cx(1,3)\n\n    def build_circuit(self):\n        for i in range(self.n):\n            self.circuit.h(i)\n        self.apply_oracle()\n        for i in range(self.n):\n            self.circuit.h(i)\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    simon_runner = SimonsAlgorithmCircuit()\n    output = simon_runner.run()\n    print(\"Measurement Counts:\", output)\n"
  },
  {
    "task_id": "QAB20",
    "description": "This quantum program demonstrates the construction of a periodic oracle with hidden period a = \"11\". The oracle maps input qubits to output qubits such that f(x) = f(x XOR a). The input qubits are first prepared in a uniform superposition so that all input states are sampled. The task is to generate an assertion that verifies the oracle mapping respects this periodicity.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n",
    "complete_prompt": "This quantum program demonstrates the construction of a periodic oracle with hidden period a.\nThe oracle maps input qubits to output qubits such that f(x) = f(x XOR a).\nInsert an assertion into the program to verify that for each input x, the output is the same\nas for its paired input x XOR a.\n\nOutput the complete modified program with the assertion included. No explanations.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    return result.get_counts()\n\nif __name__ == \"__main__\":\n    a = \"11\"  # hidden period\n    counts = run_oracle()\n\n    # Build mapping input->output\n    mapping = {}\n    for bitstring, cnt in counts.items():\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        mapping[inputs] = outputs\n\n    # ----- GOLD ASSERTION START -----\n    def xor_strings(s1, s2):\n        return \"\".join(str(int(b1) ^ int(b2)) for b1, b2 in zip(s1, s2))\n\n    for x, fx in mapping.items():\n        x_pair = xor_strings(x, a)\n        if x_pair in mapping:\n            assert mapping[x_pair] == fx, (\n                f\"Periodicity broken: f({x})={fx}, f({x_pair})={mapping[x_pair]}\"\n            )\n    # ----- GOLD ASSERTION END -----\n\n    print(\"Oracle mapping verified with period\", a)\n    for x, fx in mapping.items():\n        print(f\"Input {x} -> Output {fx}\")\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_faulty_oracle_circuit(shots=1024):\n    \"\"\"\n    Faulty periodic oracle: one CNOT gate is missing.\n    Expected function: f(x0, x1) = (x0 XOR x1, x0 XOR x1),\n    but this version omits one output mapping.\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs\n    qc.h(0)\n    qc.h(1)\n\n    # Faulty Oracle construction (missing cx(1, 3))\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    # ❌ missing: qc.cx(1, 3)\n\n    # Measure all qubits\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_faulty_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_faulty_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_faulty_oracle()\n    print(\"Faulty Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n"
  },
  {
    "task_id": "QAB21",
    "description": "This quantum program implements the Quantum Fourier Transform (QFT) on 3 qubits. A periodic input state (|000⟩ + |100⟩)/√2 is prepared before applying QFT. The expected result is a non-uniform measurement distribution with strong peaks, reflecting the Fourier transform of the periodic input. The task is to generate an assertion that verifies the presence of these peaks in the observed distribution.\n",
    "program": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):\n        circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n",
    "complete_prompt": "This quantum program implements the Quantum Fourier Transform (QFT) on a multi-qubit input.\nThe program prepares a periodic input state and then applies QFT.\nInsert an assertion into the program to verify that the resulting measurement distribution is not uniform.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Prepare a periodic input: (|000⟩ + |100⟩)/√2\n    def prepare_periodic(circuit):\n        circuit.h(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    # ----- GOLD ASSERTION START -----\n    # Expect distribution not uniform: a few states dominate (>20% each)\n    threshold = 0.20\n    dominant_states = [state for state, cnt in counts.items() if cnt / qft_runner.shots > threshold]\n\n    assert len(dominant_states) > 0, f\"Expected peaks in distribution, got nearly uniform {counts}\"\n    # ----- GOLD ASSERTION END -----\n\n    print(\"QFT Gold Assertion Passed.\")\n    print(\"Measurement Counts:\", counts)\n",
    "faulty": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransform:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        Quantum Fourier Transform (QFT) implementation.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT on the first n qubits.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)  # controlled-phase rotation\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        \"\"\"\n        Build a circuit, optionally apply a custom state preparation, \n        then apply QFT and run the simulation.\n        \"\"\"\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT\n        self.apply_qft(circuit)\n\n        # Measure all qubits\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransform(n=3, shots=1024)\n\n    # Example: prepare a periodic input state\n    # State = (|0> + |4>)/√2  in the computational basis\n    def prepare_periodic(circuit):# ❌ missing: circuit.h(0)\n        #circuit.h(0)      # put q0 in superposition\n        circuit.x(2)      # shift q2 to create |100> component\n\n    output = qft_runner.build_and_run(prepare_input=prepare_periodic)\n\n    print(\"QFT Result on periodic input state (3 qubits):\")\n    for bitstring, cnt in output.items():\n        print(f\"{bitstring}: {cnt}\")\n"
  },
  {
    "task_id": "QAB22",
    "description": "This quantum program demonstrates that applying the Quantum Fourier Transform (QFT) followed by its inverse (QFT†) recovers the original input state. In this example, the input state |101⟩ is prepared. After QFT and QFT†, the measurement results should be concentrated on |101⟩ (probability > 0.5). The task is to generate an assertion that verifies this identity property.\n",
    "program": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        \"\"\"\n        QFT followed by QFT† should return the original state.\n        n: number of qubits\n        shots: number of measurements\n        \"\"\"\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        \"\"\"Apply QFT.\"\"\"\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        \"\"\"Apply QFT† (inverse QFT).\"\"\"\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        # Prepare input state\n        if prepare_input:\n            prepare_input(circuit)\n\n        # Apply QFT then QFT†\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        # Measure\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    # Example: input state |101>\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    print(\"QFT followed by QFT† Result on input |101> (3 qubits):\")\n    for bitstring, cnt in counts.items():\n        print(f\"{bitstring}: {cnt}\")\n",
    "complete_prompt": "This quantum program applies the Quantum Fourier Transform (QFT) followed by its inverse (QFT†).\nFor any input state, the combined transformation should recover the original state.\nInsert an assertion into the program to verify that the output distribution matches the prepared input state.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport math\n\n\nclass QuantumFourierTransformWithInverse:\n    def __init__(self, n=3, shots=1024):\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        if prepare_input:\n            prepare_input(circuit)\n\n        self.apply_qft(circuit)\n        self.apply_qft_dagger(circuit)\n\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    qft_runner = QuantumFourierTransformWithInverse(n=3, shots=1024)\n\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)  # prepare |101>\n\n    counts = qft_runner.build_and_run(prepare_input=prepare_input)\n\n    # ----- GOLD ASSERTION START -----\n    expected_state = \"101\"\n    dominant = max(counts, key=counts.get)\n    dominant_prob = counts[dominant] / qft_runner.shots\n\n    assert dominant == expected_state and dominant_prob > 0.4, (\n        f\"Expected {expected_state} to dominate (>40%), got {counts}\"\n    )\n    # ----- GOLD ASSERTION END -----\n\n    print(\"QFT followed by QFT† assertion passed.\")\n    print(\"Measurement Counts:\", counts)\n",
    "faulty": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass QFTWithInverse:\n    def __init__(self, n=3, shots=1024):\n        self.n = n\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_qft(self, circuit):\n        for j in range(self.n):\n            circuit.h(j)\n            for k in range(j + 1, self.n):\n                angle = math.pi / float(2 ** (k - j))\n                circuit.cp(angle, k, j)\n        circuit.barrier()\n\n    def apply_qft_dagger(self, circuit):\n        for j in range(self.n):\n            k = (self.n - 1) - j\n            for m in range(k):\n                angle = -math.pi / float(2 ** (k - m))\n                circuit.cp(angle, k, m)\n            circuit.h(k)\n        circuit.barrier()\n\n    def build_and_run(self, prepare_input=None):\n        circuit = QuantumCircuit(self.n, self.n)\n\n        if prepare_input:\n            prepare_input(circuit)\n\n        self.apply_qft(circuit)\n        #self.apply_qft_dagger(circuit)\n\n        circuit.measure(range(self.n), range(self.n))\n\n        transpiled = transpile(circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    runner = QFTWithInverse(n=3, shots=1024)\n\n    def prepare_input(circuit):\n        circuit.x(0)\n        circuit.x(2)  # |101>\n\n    counts = runner.build_and_run(prepare_input=prepare_input)\n\n    print(\"Faulty QFT+QFT† Result on |101> (3 qubits):\", counts)\n"
  },
  {
    "task_id": "QAB23",
    "description": "This quantum program implements Grover's search algorithm on 3 qubits. The oracle marks two states, |101⟩ and |110⟩, and the diffusion operator amplifies their measurement probabilities. The expected result is that these marked states dominate the measurement outcomes. The task is to generate an assertion that verifies the dominance of the marked states.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n",
    "complete_prompt": "This quantum program implements Grover's search algorithm on 3 qubits.\nThe oracle marks specific target states, and the diffusion operator amplifies their probability.\nInsert an assertion into the program to verify that the measurement results\nare dominated by the marked target states.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        qc.h(range(self.n))\n        qc.barrier()\n\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Expect results dominated by |101> and |110>\n        target_states = [\"101\", \"110\"]\n        total_target = sum(counts.get(s, 0) for s in target_states)\n        ratio = total_target / self.shots\n        assert ratio > 0.8, f\"Expected target states to dominate, got {counts}\"\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearch()\n    output = grover.run()\n    print(\"Grover search with assertion passed.\")\n    print(\"Results:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass FaultyGroverSearch:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # ❌ Faulty oracle: only marks |101>, misses |110>\n        qc.cz(2, 0)\n        qc.barrier()\n\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = FaultyGroverSearch()\n    output = grover.run()\n    print(\"Faulty Grover results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB24",
    "description": "This quantum program implements Grover's algorithm on 3 qubits. A uniform superposition is prepared using Hadamard gates before applying the oracle and diffusion operator. The task is to generate an assertion that verifies the uniformity of this initial state preparation.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n",
    "complete_prompt": "This quantum program implements Grover's algorithm on 3 qubits.\nBefore the oracle and diffusion operator, the qubits should be prepared in a uniform superposition state.\nInsert an assertion into the program to verify that this initial state preparation\nindeed produces an approximately uniform distribution over all basis states.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformAssertion:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_uniform_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Measure immediately to check uniformity\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_uniform_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        expected_prob = 1 / (2 ** self.n)\n        tolerance = 0.1  # allow ±10%\n        for state in [format(i, \"03b\") for i in range(2 ** self.n)]:\n            prob = counts.get(state, 0) / self.shots\n            assert abs(prob - expected_prob) < tolerance, (\n                f\"State {state} deviates too much: {prob:.3f} vs expected {expected_prob:.3f}\"\n            )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformAssertion()\n    output = grover.run()\n    print(\"Uniform superposition assertion passed.\")\n    print(\"Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithUniformCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        # ❌ Faulty: forgot to apply Hadamards, state remains |000>\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithUniformCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n"
  },
  {
    "task_id": "QAB25",
    "description": "This quantum program implements Grover's algorithm on 3 qubits. The oracle marks states |101⟩ and |110⟩, and the diffusion operator amplifies their probabilities. The task is to generate an assertion that verifies the amplification works correctly, by checking that the marked states dominate the final measurement results.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionCheck:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator (inversion about mean)\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionCheck()\n    output = grover.run()\n    print(\"Grover search results (3 qubits):\", output)\n",
    "complete_prompt": "This quantum program implements Grover's search algorithm on 3 qubits.\nThe diffusion operator (inversion about the mean) is a crucial step to amplify the marked states.\nInsert an assertion into the program to verify that after the diffusion operator,\nthe marked states dominate the measurement outcomes with significantly higher probability than uniform.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverSearchWithDiffusionAssertion:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Step 1: Superposition\n        qc.h(range(self.n))\n        qc.barrier()\n\n        # Step 2: Oracle (mark |101> and |110>)\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        # Step 3: Diffusion operator\n        qc.h(range(self.n))\n        qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        qc.x(range(self.n))\n        qc.h(range(self.n))\n\n        # Step 4: Measurement\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        target_states = [\"101\", \"110\"]\n        total_target = sum(counts.get(s, 0) for s in target_states)\n        max_non_target = max(\n            [cnt for state, cnt in counts.items() if state not in target_states],\n            default=0,\n        )\n\n        assert total_target > max_non_target, (\n            f\"Expected targets {target_states} to dominate, \"\n            f\"but got counts={counts}\"\n        )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\n\nif __name__ == \"__main__\":\n    grover = GroverSearchWithDiffusionAssertion()\n    output = grover.run()\n    print(\"Diffusion operator assertion passed.\")\n    print(\"Measurement Counts:\", output)\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass GroverDiffusion:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        qc.h(range(self.n))\n        qc.barrier()\n\n        qc.cz(2, 0)\n        qc.cz(2, 1)\n        qc.barrier()\n\n        qc.h(range(self.n))\n        # ❌ Missing qc.x(range(self.n))\n        qc.barrier()\n        qc.h(2)\n        qc.ccx(0, 1, 2)\n        qc.h(2)\n        qc.barrier()\n        # qc.x(range(self.n)) missing\n        qc.h(range(self.n))\n\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    grover = GroverDiffusion()\n    output = grover.run()\n    print(\"Faulty Grover with broken diffusion:\", output)\n"
  },
  {
    "task_id": "QAB26",
    "description": "This quantum program demonstrates the period-finding subroutine of Shor's algorithm. For N=15 and a=2, the periodic function x ↦ 2^x mod 15 has period r=4. The expected measurement outcomes are consistent with multiples of 2 in the computational basis (000, 010, 100, 110). The task is to generate an assertion that verifies this periodicity.\n",
    "program": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qr_n = self.n\n        qc = QuantumCircuit(qr_n, qr_n)\n\n        # Initialize q[0] to |1>\n        qc.x(0)\n\n        # Controlled operations approximating a^x mod 15 with a=2\n        # Apply a**4 mod 15\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        # Apply a**2 mod 15\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        # Apply a mod 15\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Shor's period finding result:\", output)\n",
    "complete_prompt": "This quantum program implements the period-finding subroutine of Shor's algorithm.\nFor the example N=15, a=2, the expected measurement outcomes reveal a periodicity of r=4.\nInsert an assertion into the program to verify that the observed results are consistent\nwith this period, i.e., that the measurement outcomes include the states corresponding\nto multiples of 2 within the 3-bit register.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport math\n\n\nclass ShorPeriodFindingAssertion:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n        qc.x(0)\n\n        # Controlled multiplications mod 15 (simplified)\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        qc.h(4)\n        qc.cswap(4, 3, 2)\n        qc.cswap(4, 2, 1)\n        qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Expect outcomes consistent with period r=4: x = 0, 2, 4, 6\n        valid_outcomes = {\"000\", \"010\", \"100\", \"110\"}  # low 3 classical bits\n        observed = set(k[-3:] for k in counts.keys())\n        assert observed & valid_outcomes, (\n            f\"Expected periodic outcomes {valid_outcomes}, got {observed}\"\n        )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingAssertion()\n    output = shor.run()\n    print(\"Shor period-finding assertion passed.\")\n    print(\"Measurement Counts:\", output)\n",
    "faulty": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFinding:\n    def __init__(self, shots=1024):\n        self.n = 5\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_faulty_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n        qc.x(0)\n\n        qc.h(4)\n        qc.h(4)\n        qc.measure(4, 0)\n        qc.reset(4)\n\n        qc.h(4)\n        qc.cx(4, 2)\n        qc.cx(4, 0)\n        qc.h(4)\n        qc.measure(4, 1)\n        qc.reset(4)\n\n        qc.h(4)\n        # ❌ Faulty: skip some cswap operations\n        qc.cswap(4, 3, 2)\n        # missing qc.cswap(4, 2, 1)\n        # missing qc.cswap(4, 1, 0)\n        qc.h(4)\n        qc.measure(4, 2)\n\n        return qc\n\n    def run(self):\n        qc = self.build_faulty_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFinding()\n    output = shor.run()\n    print(\"Faulty Shor period finding result:\", output)\n"
  },
  {
    "task_id": "QAB27",
    "description": "This quantum program demonstrates a simplified period-finding step of Shor's algorithm for N=15, a=2. The quantum measurement provides an approximation to k/r, which must be classically post-processed using continued fraction expansion. The expected result is a period r=4. The task is to generate an assertion that verifies the continued fraction step correctly recovers r=4 from the quantum output.\n",
    "program": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3  # use 3 qubits for counting register\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # Prepare a periodic function mod 15 (simplified)\n        # Just simulate the effect that gives peaks at multiples of 2\n        qc.h(range(self.n))  # uniform superposition\n        qc.barrier()\n\n        # Apply \"black-box oracle\" that encodes periodicity\n        # For simplicity, mimic the interference pattern\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        # Measure the counting register\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        return result.get_counts()\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Shor simplified period finding measurement:\", output)\n",
    "complete_prompt": "This quantum program implements a simplified period-finding circuit for Shor's algorithm.\nThe measurement output must be classically post-processed using continued fraction expansion\nto recover the period r of the modular function. Insert an assertion into the program\nthat verifies the continued fraction calculation correctly recovers the period r.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nfrom fractions import Fraction\n\n\nclass ShorPeriodFindingWithAssertion:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n        qc.h(range(self.n))\n        qc.barrier()\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        dominant = max(counts, key=counts.get)\n        x = int(dominant, 2)\n        frac = Fraction(x, 2 ** self.n).limit_denominator(15)  # keep denominator small\n        r = frac.denominator\n\n        # Allow r = 4 or multiples (e.g., 8) since continued fraction can overshoot\n        assert r % 4 == 0, f\"Expected period multiple of 4, got r={r} from x={x}\"\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingWithAssertion()\n    output = shor.run()\n    print(\"Shor period-finding assertion passed.\")\n    print(\"Measurement Counts:\", output)\n",
    "faulty": "import math\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nfrom fractions import Fraction\n\nclass ShorPeriodFindingSimple:\n    def __init__(self, shots=1024):\n        self.n = 3\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_faulty_circuit(self):\n        qc = QuantumCircuit(self.n, self.n)\n\n        # ❌ Faulty: Prepare uniform superposition\n        qc.h(range(self.n-1))\n        qc.barrier()\n\n        qc.cz(0, 1)\n        qc.cz(1, 2)\n\n        qc.measure(range(self.n), range(self.n))\n        return qc\n\n    def run(self):\n        qc = self.build_faulty_circuit()\n        transpiled = transpile(qc, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\n\nif __name__ == \"__main__\":\n    shor = ShorPeriodFindingSimple()\n    output = shor.run()\n    print(\"Faulty Shor period finding (expected to fail):\", output)\n"
  },
  {
    "task_id": "QAB28",
    "description": "This quantum program implements a simplified version of the Harrow-Hassidim-Lloyd (HHL) algorithm to solve a 2x2 linear system of equations using a 3-qubit circuit. The circuit approximates the inverse of a small Hermitian matrix A and encodes the solution to A·x=b in the amplitude of a solution qubit. The expected output is a dominant measurement in the |0⟩ state on the solution qubit. The task is to generate an assertion that checks whether the measurement distribution confirms this expected dominance.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n",
    "complete_prompt": "This quantum program implements a simplified version of the Harrow-Hassidim-Lloyd (HHL) algorithm to solve a small linear system.\nThe circuit encodes a specific matrix A and input vector b, and is expected to produce measurement outcomes corresponding to a known solution.\n\nAdd a verification mechanism to the program that validates whether the output is dominated by the correct solution state.\nThis check should ensure that the result distribution aligns with the expected behavior of a quantum linear solver.\n\nInclude the assertion inline in the code, triggered after circuit execution.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program with inline golden assertion.\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        Includes GOLD ASSERTION.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Expectation: HHL outputs mostly the correct amplitude encoding state.\n        # For this simplified circuit, '000' is the dominant solution state.\n        dominant_state = '000'\n        dominant_count = self.counts.get(dominant_state, 0)\n        total_counts = sum(self.counts.values())\n        dominant_ratio = dominant_count / total_counts\n        print(f\"[GOLD ASSERTION] '{dominant_state}' frequency ratio: {dominant_ratio:.3f}\")\n        assert dominant_ratio > 0.5, (\n            f\"Expected dominant output state '{dominant_state}' to appear >75%, \"\n            f\"but got {dominant_ratio:.3f}\"\n        )\n        # ----- GOLD ASSERTION END -----\n\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    Faulty version of QAB-28 HHL program.\n    Introduces incorrect phase rotation to simulate bug in QPE step.\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit with incorrect QPE phase.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt} with WRONG phase\n        qc.h(1)\n        qc.cx(1, 0)\n\n        # ❌ WRONG ROTATION: should be 2π/3, using π/3 instead\n        qc.rz(np.pi, 0)\n\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE (also with wrong inverse)\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-np.pi / 3, 0)  # wrong inverse\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the faulty HHL circuit on AerSimulator and display results.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results (Faulty):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB29",
    "description": "This benchmark applies a 10-qubit Quantum Fourier Transform (QFT) circuit to a carefully prepared periodic input state. The expected outcome of the QFT is a distribution with sharp peaks at basis states corresponding to the input's frequency components. The task is to verify that the quantum circuit correctly concentrates output probability on these target frequencies.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        for i in range(n // 2):\n            qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n",
    "complete_prompt": "This program constructs a periodic quantum state and applies the Quantum Fourier Transform (QFT).\nThe goal is to identify whether the output distribution contains peaks at the expected frequency components.\nInsert a verification step that inspects the measurement output and determines if the quantum circuit produces\na valid QFT response to the periodic input.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from program import QFTProgram\n\n\nclass QFTAssertion:\n    \"\"\"\n    Golden Assertion for QAB-29 with 10-qubit QFT on periodic input.\n    Check if measurement is concentrated on expected frequency states ±1.\n    \"\"\"\n\n    def __init__(self, threshold=0.5):\n        self.threshold = threshold\n        self.program = QFTProgram(plot=False)\n        self.n = self.program.num_qubits\n        self.expected_freq_step = 2 ** self.n // self.program.period\n\n    def assert_frequency_peaks(self):\n        self.program.run()\n        counts = self.program.counts\n        total = sum(counts.values())\n\n        # Build list of expected states (±1 offset included)\n        expected_states = []\n        for k in range(self.program.period):\n            center = k * self.expected_freq_step\n            for delta in [-1, 0, 1]:  # allow near misses\n                idx = center + delta\n                if 0 <= idx < 2 ** self.n:\n                    expected_states.append(format(idx, f'0{self.n}b'))\n\n        hit = sum(counts.get(state, 0) for state in expected_states)\n        ratio = hit / total\n\n        print(f\"[GOLD ASSERTION] Expected peak states (±1): {expected_states}\")\n        print(f\"[GOLD ASSERTION] Hit ratio: {ratio:.3f}\")\n\n        assert ratio > self.threshold, f\"Expected QFT peak structure missing: ratio={ratio:.3f}\"\n\n    def run_all(self):\n        self.assert_frequency_peaks()\n        print(\"[✅] QAB-29 assertion passed.\")\n\n\nif __name__ == \"__main__\":\n    test = QFTAssertion()\n    test.run_all()\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass QFTProgram:\n    \"\"\"\n    QAB-29 Benchmark Program (10-qubit QFT on periodic input)\n    \"\"\"\n\n    def __init__(self, num_qubits=10, shots=2048, plot=True, period=4):\n        self.num_qubits = num_qubits\n        self.shots = shots\n        self.plot = plot\n        self.period = period\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def prepare_periodic_input(self, qc):\n        \"\"\"\n        Prepare superposition of basis states with a given period.\n        E.g., for period=4 and n=10 → |0⟩ + |4⟩ + |8⟩ + ... + |1020⟩\n        \"\"\"\n        n = self.num_qubits\n        state_indexes = list(range(0, 2**n, self.period))\n        amp = 1 / np.sqrt(len(state_indexes))\n\n        # Build statevector\n        statevector = np.zeros(2**n, dtype=complex)\n        for i in state_indexes:\n            statevector[i] = amp\n\n        # Initialize from statevector\n        from qiskit.quantum_info import Statevector\n        qc.initialize(Statevector(statevector).data)\n\n    def apply_qft(self, qc, n):\n        for j in range(n):\n            qc.h(j)\n            for k in range(j + 1, n):\n                angle = np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n        #for i in range(n // 2):\n            #qc.swap(i, n - i - 1)\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.num_qubits)\n        self.prepare_periodic_input(qc)\n        self.apply_qft(qc, self.num_qubits)\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        print(\"Measurement Results (QFT Periodic Input):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = QFTProgram()\n    program.run()\n"
  },
  {
    "task_id": "QAB30",
    "description": "This benchmark circuit simulates the structural behavior of Shor's algorithm with 15 qubits. Though simplified, it models critical stages including counting superposition, entanglement, and inverse QFT. The objective is to test whether the output reflects a strong periodic structure in the counting register.\n",
    "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    \"\"\"\n    QAB-30: Shor's Algorithm Benchmark with 15 Qubits.\n    This version emphasizes circuit width and depth.\n    Modular exponentiation is abstracted for benchmarking.\n    \"\"\"\n\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8           # Counting qubits\n        self.work_qubits = 7       # Work/ancilla register\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # Step 2: Fake modular exponentiation\n        # Entangle counting qubits with work qubits\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Step 3: Inverse QFT on counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting qubits\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for bitstring, count in result.items():\n        print(f\"{bitstring}: {count}\")\n",
    "complete_prompt": "This quantum program is a large-scale instance inspired by Shor’s algorithm. It uses 15 qubits to simulate the key structural phases of order-finding: uniform superposition, controlled modular operations, and quantum Fourier transform.\n\nInsert an inline diagnostic check that validates whether the measurement results exhibit strong periodicity in the output distribution of the counting register.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuit:\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8\n        self.work_qubits = 7\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        for q in range(self.n_count):\n            qc.h(q)\n\n        for j in range(self.n_count):\n            for k in range(self.work_qubits):\n                qc.cx(j, self.n_count + k)\n\n        # Inverse QFT\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n        topk = 3\n        topk_total = sum(v for _, v in sorted_counts[:topk])\n        total = sum(self.counts.values())\n        ratio = topk_total / total\n        print(f\"[GOLD ASSERTION] Top-{topk} states carry {ratio:.3f} of probability mass\")\n        assert ratio > 0.1, (\n            f\"Expected top-{topk} peaks to dominate (>10%), but got {ratio:.3f}\"\n        )\n        # ----- GOLD ASSERTION END -----\n\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuit()\n    result = program.run()\n    print(\"Measurement Results:\")\n    for b, c in result.items():\n        print(f\"{b}: {c}\")\n",
    "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n\nclass ShorLargeCircuitFaulty:\n    def __init__(self, N=15, a=7, shots=1024):\n        self.N = N\n        self.a = a\n        self.n_count = 8\n        self.work_qubits = 7\n        self.total_qubits = self.n_count + self.work_qubits\n        self.backend = AerSimulator()\n        self.shots = shots\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        qc = QuantumCircuit(self.total_qubits, self.n_count)\n\n        # Step 1: Hadamard on counting register\n        for q in range(self.n_count):\n            qc.h(q)\n\n        # ❌ Step 2: Remove all entanglement (missing QPE-like CX structure)\n        # (This simulates a circuit with structural fault in phase estimation)\n\n        # Step 3: Apply inverse QFT to counting register\n        for j in range(self.n_count // 2):\n            qc.swap(j, self.n_count - j - 1)\n\n        for j in range(self.n_count):\n            qc.h(j)\n            for k in range(j + 1, self.n_count):\n                angle = -np.pi / (2 ** (k - j))\n                qc.cp(angle, k, j)\n\n        # Step 4: Measure counting register\n        for i in range(self.n_count):\n            qc.measure(i, i)\n\n        self.circuit = qc\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n\nif __name__ == \"__main__\":\n    program = ShorLargeCircuitFaulty()\n    result = program.run()\n    print(\"Faulty Measurement Results:\")\n    for b, c in result.items():\n        print(f\"{b}: {c}\")\n"
  },
  {
    "task_id": "QAB31",
    "description": "This benchmark evaluates a 15-qubit implementation of Grover's algorithm. The task is to insert a diagnostic assertion that verifies whether the target bitstring is successfully amplified compared to other measurement outcomes. The circuit uses a controlled oracle and diffuser for amplitude amplification. A faulty variant disables the diffuser to simulate poor amplification, while the assertion checks if the target state is significantly more likely than any other.\n",
    "program": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 Benchmark: Grover's Algorithm on 15 qubits.\n    Searches for a predefined target bitstring using repeated oracle + diffusion steps.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"  # Fixed 15-bit target string\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")  # required for mcx\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        \"\"\"Apply Grover oracle to mark the target state by phase flip.\"\"\"\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        \"\"\"Apply the Grover diffuser to amplify target state's amplitude.\"\"\"\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        \"\"\"Construct Grover circuit with multiple iterations.\"\"\"\n        self.circuit.h(self.qr)  # Initialize superposition\n\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        \"\"\"Execute the circuit on AerSimulator.\"\"\"\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        \"\"\"Prints top measured states and target detection rate.\"\"\"\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    grover.summarize_results()\n",
    "complete_prompt": "This quantum program implements Grover's algorithm over a 15-qubit search space.\nA target bitstring is embedded in the oracle, and the circuit applies several rounds\nof amplification to increase its measurement probability.\n\nAdd a diagnostic assertion that checks whether the target bitstring is sufficiently amplified\nin the final output distribution. The assertion should confirm that this target state\nstands out from the rest and appears significantly more frequently than other states.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
    "gold_assertion": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmarkWithAssertion:\n    \"\"\"\n    QAB-31: Grover's Algorithm on 15 qubits with GOLD ASSERTION.\n    Verifies that the target bitstring is most probable in measurement outcomes.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        self.circuit.h(self.qr)\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            self.apply_diffuser()\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n\n        second_best = sorted_counts[1][1] / total if len(sorted_counts) > 1 else 0\n\n        print(f\"[GOLD ASSERTION] Target state probability: {target_prob:.3%}\")\n        print(f\"[GOLD ASSERTION] Second-highest state probability: {second_best:.3%}\")\n\n        assert target_prob > second_best * 2, (\n            f\"Target state not sufficiently amplified. \"\n            f\"Target: {target_prob:.3%}, Second-best: {second_best:.3%}\"\n        )\n        # ----- GOLD ASSERTION END -----\n\n        return self.counts\n\n    def summarize_results(self):\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmarkWithAssertion()\n    output = grover.run()\n    grover.summarize_results()\n",
    "faulty": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit_aer import AerSimulator\nfrom math import pi, floor, sqrt\n\n\nclass GroverBenchmark:\n    \"\"\"\n    QAB-31 FAULTY: Grover's Algorithm with missing diffuser.\n    The oracle correctly marks the target, but amplitude amplification is disabled.\n    \"\"\"\n\n    def __init__(self, shots=4096):\n        self.n = 15\n        self.target = \"101010101010101\"\n        self.shots = shots\n\n        self.backend = AerSimulator()\n        self.qr = QuantumRegister(self.n, \"q\")\n        self.anc = QuantumRegister(self.n - 2, \"anc\")\n        self.cr = ClassicalRegister(self.n, \"c\")\n        self.circuit = QuantumCircuit(self.qr, self.anc, self.cr)\n\n        self.counts = None\n\n    def apply_oracle(self):\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for i, bit in enumerate(self.target):\n            if bit == '0':\n                self.circuit.x(self.qr[i])\n\n    def apply_diffuser(self):\n        for q in self.qr:\n            self.circuit.h(q)\n            self.circuit.x(q)\n        self.circuit.h(self.qr[self.n - 1])\n        self.circuit.mcx(\n            control_qubits=self.qr[: self.n - 1],\n            target_qubit=self.qr[self.n - 1],\n            ancilla_qubits=self.anc,\n            mode='v-chain'\n        )\n        self.circuit.h(self.qr[self.n - 1])\n        for q in self.qr:\n            self.circuit.x(q)\n            self.circuit.h(q)\n\n    def build_circuit(self):\n        self.circuit.h(self.qr)\n        num_iterations = min(10, floor(pi / 4 * sqrt(2 ** self.n)))\n        for _ in range(num_iterations):\n            self.apply_oracle()\n            # diffuser intentionally skipped\n        self.circuit.measure(self.qr, self.cr)\n\n    def run(self):\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        return self.counts\n\n    def summarize_results(self):\n        total = sum(self.counts.values())\n        sorted_counts = sorted(self.counts.items(), key=lambda x: -x[1])\n        print(\"\\nTop 10 Measured States:\")\n        for bitstring, count in sorted_counts[:10]:\n            prob = count / total\n            print(f\"{bitstring}: {count} ({prob:.3%})\")\n\n        target_count = self.counts.get(self.target, 0)\n        target_prob = target_count / total\n        print(f\"\\n[INFO] Target bitstring: {self.target}\")\n        print(f\"[INFO] Target count: {target_count} ({target_prob:.3%})\")\n        return target_prob\n\n\nif __name__ == \"__main__\":\n    grover = GroverBenchmark()\n    output = grover.run()\n    grover.summarize_results()\n"
  }
]