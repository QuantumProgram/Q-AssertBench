{
  "task_id": "QAB20",
  "description": "This quantum program demonstrates the construction of a periodic oracle with hidden period a = \"11\". The oracle maps input qubits to output qubits such that f(x) = f(x XOR a). The input qubits are first prepared in a uniform superposition so that all input states are sampled. The task is to generate an assertion that verifies the oracle mapping respects this periodicity.\n",
  "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs (q0, q1)\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits (so we can observe input and output)\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_oracle()\n    print(\"Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n",
  "complete_prompt": "This quantum program demonstrates the construction of a periodic oracle with hidden period a.\nThe oracle maps input qubits to output qubits such that f(x) = f(x XOR a).\nInsert an assertion into the program to verify that for each input x, the output is the same\nas for its paired input x XOR a.\n\nOutput the complete modified program with the assertion included. No explanations.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_oracle_circuit(shots=1024):\n    \"\"\"\n    Periodic oracle example with hidden period a = \"11\".\n    Function: f(x0, x1) = (x0 XOR x1, x0 XOR x1).\n    Inputs: qubits 0,1\n    Outputs: qubits 2,3\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs\n    qc.h(0)\n    qc.h(1)\n\n    # Oracle construction\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n\n    # Measure all qubits\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    return result.get_counts()\n\nif __name__ == \"__main__\":\n    a = \"11\"  # hidden period\n    counts = run_oracle()\n\n    # Build mapping input->output\n    mapping = {}\n    for bitstring, cnt in counts.items():\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        mapping[inputs] = outputs\n\n    # ----- GOLD ASSERTION START -----\n    def xor_strings(s1, s2):\n        return \"\".join(str(int(b1) ^ int(b2)) for b1, b2 in zip(s1, s2))\n\n    for x, fx in mapping.items():\n        x_pair = xor_strings(x, a)\n        if x_pair in mapping:\n            assert mapping[x_pair] == fx, (\n                f\"Periodicity broken: f({x})={fx}, f({x_pair})={mapping[x_pair]}\"\n            )\n    # ----- GOLD ASSERTION END -----\n\n    print(\"Oracle mapping verified with period\", a)\n    for x, fx in mapping.items():\n        print(f\"Input {x} -> Output {fx}\")\n",
  "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\ndef build_faulty_oracle_circuit(shots=1024):\n    \"\"\"\n    Faulty periodic oracle: one CNOT gate is missing.\n    Expected function: f(x0, x1) = (x0 XOR x1, x0 XOR x1),\n    but this version omits one output mapping.\n    \"\"\"\n    qc = QuantumCircuit(4, 4)\n\n    # Prepare uniform superposition over inputs\n    qc.h(0)\n    qc.h(1)\n\n    # Faulty Oracle construction (missing cx(1, 3))\n    qc.cx(0, 2)\n    qc.cx(1, 2)\n    qc.cx(0, 3)\n    # ❌ missing: qc.cx(1, 3)\n\n    # Measure all qubits\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc\n\ndef run_faulty_oracle(shots=1024):\n    backend = Aer.get_backend(\"qasm_simulator\")\n    qc = build_faulty_oracle_circuit(shots)\n    transpiled = transpile(qc, backend)\n    job = backend.run(transpiled, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n\nif __name__ == \"__main__\":\n    counts = run_faulty_oracle()\n    print(\"Faulty Oracle Mapping Counts:\")\n    for bitstring, cnt in counts.items():\n        # bitstring format: c3 c2 c1 c0\n        outputs = bitstring[:2]   # q3q2\n        inputs  = bitstring[-2:]  # q1q0\n        print(f\"Input {inputs} -> Output {outputs}, Count={cnt}\")\n"
}