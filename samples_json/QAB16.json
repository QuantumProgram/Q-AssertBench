{
  "task_id": "QAB16",
  "description": "This quantum program implements the Bernstein–Vazirani algorithm with three input qubits and one ancilla qubit. The oracle encodes a hidden binary string a, and the final measurement of the input qubits should reveal this string with high probability. The task is to generate an assertion that verifies whether the observed measurement matches the hidden string.\n",
  "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        \"\"\"\n        Bernstein-Vazirani Algorithm\n        a: hidden string (binary as str, e.g. \"111\" or \"101\")\n        \"\"\"\n        self.a = a\n        self.n = len(a)  # number of input qubits\n        self.shots = shots\n        self.circuit = QuantumCircuit(self.n + 1, self.n)  # n input + 1 ancilla, measure only n\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def apply_oracle(self):\n        # Oracle for f(x) = a · x mod 2\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)  # control: input qubit, target: ancilla\n\n    def build_circuit(self):\n        # Step 1: Initialize ancilla qubit in |1⟩\n        self.circuit.x(self.n)\n\n        # Step 2: Apply Hadamard to all qubits\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n\n        # Step 3: Apply oracle\n        self.apply_oracle()\n\n        # Step 4: Apply Hadamard to input qubits\n        for i in range(self.n):\n            self.circuit.h(i)\n\n        # Step 5: Measure only the input qubits\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    # Example with a = \"111\"\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
  "complete_prompt": "This quantum program implements the Bernstein–Vazirani algorithm.\nThe final measurement should reveal the hidden binary string encoded in the oracle.\nInsert an assertion into the program to check that the observed result matches the hidden string.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        self.a = a\n        self.n = len(a)\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n        self.circuit = QuantumCircuit(self.n + 1, self.n)\n\n    def apply_oracle(self):\n        for i, bit in enumerate(self.a):\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)\n\n    def build_circuit(self):\n        self.circuit.x(self.n)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n        self.apply_oracle()\n        for i in range(self.n):\n            self.circuit.h(i)\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # The final measurement should reveal the hidden string a\n        assert self.a in counts and counts[self.a] > 0.9 * self.shots, (\n            f\"Expected outcome {self.a}, but got {counts}\"\n        )\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
  "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nclass BernsteinVaziraniCircuit:\n    def __init__(self, a=\"111\", shots=1024):\n        self.a = a\n        self.n = len(a)\n        self.shots = shots\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n        self.circuit = QuantumCircuit(self.n + 1, self.n)\n\n    def apply_oracle(self):\n        # ❌ Faulty: forget to encode last bit of a\n        for i, bit in enumerate(self.a[:-1]):  # skip last bit\n            if bit == \"1\":\n                self.circuit.cx(i, self.n)\n\n    def build_circuit(self):\n        self.circuit.x(self.n)\n        for i in range(self.n + 1):\n            self.circuit.h(i)\n        self.apply_oracle()\n        for i in range(self.n):\n            self.circuit.h(i)\n        for i in range(self.n):\n            self.circuit.measure(i, i)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = BernsteinVaziraniCircuit(a=\"111\")\n    output = circuit_runner.run()\n    print(\"Faulty Measurement Counts:\", output)\n"
}