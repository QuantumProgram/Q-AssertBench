{
  "task_id": "QAB04",
  "description": "This quantum program applies a single parameterized Pauli gate to a qubit, resulting in a non-uniform measurement probability distribution. The goal is to generate an assertion that verifies whether the observed measurement statistics align with the expected probabilistic behavior.\n",
  "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)  # 1 qubit, 1 classical bit\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        # Measurement\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
  "complete_prompt": "This quantum program applies a single parameterized Pauli gate to a qubit before measurement. \nThe resulting measurement outcome is expected to follow a specific non-uniform probability distribution.\n\nYour task is to generate a code snippet that adds an assertion verifying whether the observed measurement statistics reflect the expected probabilistic behavior.\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n\n        #self.circuit.rx(np.pi / 2, 0)\n\n        self.circuit.ry(2 * np.pi / 3, 0)\n\n        self.circuit.z(0)\n\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Compute the probability of measuring '1' and assert it's approximately 0.75\n        p1 = counts.get(\"1\", 0) / self.shots\n        assert abs(p1 - 0.75) < 0.05, f\"Assertion failed: P(1) = {p1:.3f}, expected ≈ 0.75\"\n        # ----- GOLD ASSERTION END -----\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)\n",
  "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nimport numpy as np\n\nclass PauliGatesCircuit:\n    def __init__(self, shots=1024):\n        self.shots = shots\n        self.circuit = QuantumCircuit(1, 1)\n        self.backend = Aer.get_backend(\"qasm_simulator\")\n\n    def build_circuit(self):\n        # Use RY(θ) with θ = 2π/3 to get 0.75/0.25 probability distribution\n        self.circuit.ry(1 * np.pi / 4, 0)\n\n        self.circuit.measure(0, 0)\n\n    def run(self):\n        self.build_circuit()\n        transpiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(transpiled, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        return counts\n\nif __name__ == \"__main__\":\n    circuit_runner = PauliGatesCircuit()\n    output = circuit_runner.run()\n    print(\"Measurement Counts:\", output)"
}