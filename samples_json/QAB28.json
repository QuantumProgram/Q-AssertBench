{
  "task_id": "QAB28",
  "description": "This quantum program implements a simplified version of the Harrow-Hassidim-Lloyd (HHL) algorithm to solve a 2x2 linear system of equations using a 3-qubit circuit. The circuit approximates the inverse of a small Hermitian matrix A and encodes the solution to A·x=b in the amplitude of a solution qubit. The expected output is a dominant measurement in the |0⟩ state on the solution qubit. The task is to generate an assertion that checks whether the measurement distribution confirms this expected dominance.\n",
  "program": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n",
  "complete_prompt": "This quantum program implements a simplified version of the Harrow-Hassidim-Lloyd (HHL) algorithm to solve a small linear system.\nThe circuit encodes a specific matrix A and input vector b, and is expected to produce measurement outcomes corresponding to a known solution.\n\nAdd a verification mechanism to the program that validates whether the output is dominated by the correct solution state.\nThis check should ensure that the result distribution aligns with the expected behavior of a quantum linear solver.\n\nInclude the assertion inline in the code, triggered after circuit execution.\n\nOutput the complete modified program with the assertion included. No explanations, no comments.\n\nModify the given Python program by inserting a single assertion.\n\nOutput only the full modified Python file — nothing else.\n\nAssertion Format:\n- Insert only the assertion (do not modify any other part of the code).\n- Surround your assertion with the following markers:\n\n    # >>> ASSERTION START\n    <your assertion code>\n    # <<< ASSERTION END\n\n- These markers are mandatory and must wrap only the inserted assertion.\n- Do NOT include explanations, markdown, comments, or additional output.\n- Output must be a valid Python script (ready to save as a .py file).",
  "gold_assertion": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    QAB-28 Benchmark Program with inline golden assertion.\n    Implements a simplified HHL algorithm circuit for a 2x2 system:\n        A = [[1, 0.5], [0.5, 1]]\n        b = [1, 0]\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt}\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-2 * np.pi / 3, 0)\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the HHL circuit on AerSimulator and show result.\n        Includes GOLD ASSERTION.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n        # ----- GOLD ASSERTION START -----\n        # Expectation: HHL outputs mostly the correct amplitude encoding state.\n        # For this simplified circuit, '000' is the dominant solution state.\n        dominant_state = '000'\n        dominant_count = self.counts.get(dominant_state, 0)\n        total_counts = sum(self.counts.values())\n        dominant_ratio = dominant_count / total_counts\n        print(f\"[GOLD ASSERTION] '{dominant_state}' frequency ratio: {dominant_ratio:.3f}\")\n        assert dominant_ratio > 0.5, (\n            f\"Expected dominant output state '{dominant_state}' to appear >75%, \"\n            f\"but got {dominant_ratio:.3f}\"\n        )\n        # ----- GOLD ASSERTION END -----\n\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results:\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n",
  "faulty": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass HHLProgram:\n    \"\"\"\n    Faulty version of QAB-28 HHL program.\n    Introduces incorrect phase rotation to simulate bug in QPE step.\n    \"\"\"\n\n    def __init__(self, shots=1024, plot=True):\n        self.shots = shots\n        self.plot = plot\n        self.backend = AerSimulator()\n        self.circuit = None\n        self.counts = None\n\n    def build_circuit(self):\n        \"\"\"\n        Build the HHL quantum circuit with incorrect QPE phase.\n        \"\"\"\n        qc = QuantumCircuit(3)\n\n        # Step 1: QPE - simulate e^{iAt} with WRONG phase\n        qc.h(1)\n        qc.cx(1, 0)\n\n        # ❌ WRONG ROTATION: should be 2π/3, using π/3 instead\n        qc.rz(np.pi, 0)\n\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 2: Controlled rotation to ancilla (simulate 1/λ)\n        theta = 2 * np.arcsin(1 / 1.5)\n        qc.cry(theta, 1, 2)\n\n        # Step 3: Uncompute QPE (also with wrong inverse)\n        qc.h(1)\n        qc.cx(1, 0)\n        qc.rz(-np.pi / 3, 0)  # wrong inverse\n        qc.cx(1, 0)\n        qc.h(1)\n\n        # Step 4: Measure\n        qc.measure_all()\n        self.circuit = qc\n\n    def run(self):\n        \"\"\"\n        Run the faulty HHL circuit on AerSimulator and display results.\n        \"\"\"\n        self.build_circuit()\n        compiled = transpile(self.circuit, self.backend)\n        job = self.backend.run(compiled, shots=self.shots)\n        result = job.result()\n        self.counts = result.get_counts()\n\n        self.display_results()\n\n    def display_results(self):\n        \"\"\"\n        Output results and plot histogram if enabled.\n        \"\"\"\n        print(\"Measurement Results (Faulty):\")\n        print(self.counts)\n\n\nif __name__ == \"__main__\":\n    program = HHLProgram()\n    program.run()\n"
}