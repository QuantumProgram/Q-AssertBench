- id: QAB01
  title: Superposition and Classical State Preparation
  description: 'This quantum circuit prepares five qubits in different states: some
    deterministic (classical), some in superposition. The goal is to generate an assertion
    that verifies the presence of both classical and quantum behaviors in the measurement
    outcomes.'
  program: ./Q-AssertBench/QAB01/program.py
  prompt: ./Q-AssertBench/QAB01/prompt.py
  gold_assertion: ./Q-AssertBench/QAB01/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB01/faulty.py
  metadata:
    qubits: 5
    shots: 1024
- id: QAB02
  title: Bell State Preparation
  description: 'The program prepares a 2-qubit Bell state using a Hadamard gate and
    a CNOT gate. The final quantum state should be an entangled state (|00⟩ + |11⟩)/√2,
    where both measurement outcomes appear with roughly equal probability. The goal
    is to assert whether the entanglement behavior is preserved through the measurements.'
  program: ./Q-AssertBench/QAB02/program.py
  prompt: ./Q-AssertBench/QAB02/prompt.py
  gold_assertion: ./Q-AssertBench/QAB02/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB02/faulty.py
  metadata:
    qubits: 2
    shots: 1024
- id: QAB03
  title: Quantum Swap Gate
  description: 'This circuit initializes three qubits with fixed probabilities of
    measuring |1⟩, then applies two SWAP operations to move the quantum state of qubit
    2 to qubit 0. The task is to generate an assertion that verifies whether the final
    measurement probability of qubit 0 matches that of the original qubit 2.'
  program: ./Q-AssertBench/QAB03/program.py
  prompt: ./Q-AssertBench/QAB03/prompt.py
  gold_assertion: ./Q-AssertBench/QAB03/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB03/faulty.py
  metadata:
    qubits: 3
    shots: 1024
- id: QAB04
  title: Pauli Gate and Probabilistic Distribution
  description: 'This quantum program applies a single parameterized Pauli gate to
    a qubit, resulting in a non-uniform measurement probability distribution. The
    goal is to generate an assertion that verifies whether the observed measurement
    statistics align with the expected probabilistic behavior.'
  program: ./Q-AssertBench/QAB04/program.py
  prompt: ./Q-AssertBench/QAB04/prompt.py
  gold_assertion: ./Q-AssertBench/QAB04/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB04/faulty.py
  metadata:
    qubits: 1
    shots: 1024
- id: QAB04
  title: Continuous Pauli Gates
  description: 'This quantum program applies a series of Pauli gates (X, Y, Z) to
    a single qubit, influencing the final probability distribution of measurement
    outcomes. The goal is to generate an assertion that verifies the expected probabilistic
    behavior induced by the composition of non-commutative Pauli operations.'
  program: ./Q-AssertBench/QAB04/program.py
  prompt: ./Q-AssertBench/QAB04/prompt.py
  gold_assertion: ./Q-AssertBench/QAB04/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB04/faulty.py
  metadata:
    qubits: 1
    shots: 1024
- id: QAB06
  title: Quantum State Distribution
  description: 'This quantum program prepares a quantum state where one basis outcome
    is expected to appear with significantly higher probability than the others. The
    goal is to generate an assertion that verifies the presence of a dominant state
    in the output distribution.'
  program: ./Q-AssertBench/QAB06/program.py
  prompt: ./Q-AssertBench/QAB06/prompt.py
  gold_assertion: ./Q-AssertBench/QAB06/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB06/faulty.py
  metadata:
    qubits: 4
    shots: 1024
- id: QAB07
  title: Uniform Distribution of Quantum States
  description: 'This quantum program prepares a quantum state where all possible basis
    states are expected to appear with roughly equal probability. The goal is to generate
    an assertion that verifies the uniformity of the output distribution.'
  program: ./Q-AssertBench/QAB07/program.py
  prompt: ./Q-AssertBench/QAB07/prompt.py
  gold_assertion: ./Q-AssertBench/QAB07/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB07/faulty.py
  metadata:
    qubits: 3
    shots: 1024
- id: QAB08
  title: Interference Control and Gate Direction
  description: 'This quantum program constructs a chained interference pattern using
    a sequence of controlled gates. Only specific output states are expected to appear
    if the control directions are correct. The task is to generate an assertion that
    verifies whether the measurement outcomes are confined to a small, known subset
    of possible states.'
  program: ./Q-AssertBench/QAB08/program.py
  prompt: ./Q-AssertBench/QAB08/prompt.py
  gold_assertion: ./Q-AssertBench/QAB08/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB08/faulty.py
  metadata:
    qubits: 3
    shots: 1024
- id: QAB09
  title: Entanglement Correlation Detection
  description: 'This quantum program prepares a two-qubit quantum state where the
    measurement results of the qubits are expected to be strongly correlated. The
    goal is to generate an assertion that verifies this correlation, serving as evidence
    of entanglement in the system.'
  program: ./Q-AssertBench/QAB09/program.py
  prompt: ./Q-AssertBench/QAB09/prompt.py
  gold_assertion: ./Q-AssertBench/QAB09/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB09/faulty.py
  metadata:
    qubits: 2
    shots: 1024
- id: QAB10
  title: GHZ Multi-Qubit Entanglement
  description: 'This quantum program prepares a four-qubit GHZ state, an example of
    a maximally entangled multi-qubit system. The expected measurement outcomes are
    only ''0000'' and ''1111''. The task is to generate an assertion that verifies
    this entangled behavior by checking that no unexpected states appear in the output
    distribution.'
  program: ./Q-AssertBench/QAB10/program.py
  prompt: ./Q-AssertBench/QAB10/prompt.py
  gold_assertion: ./Q-AssertBench/QAB10/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB10/faulty.py
  metadata:
    qubits: 4
    shots: 1024
- id: QAB11
  title: Deutsch Algorithm with Fixed Oracle
  description: 'This quantum program implements the Deutsch algorithm with a fixed
    oracle corresponding to f(x) = x, a balanced function. The task is to generate
    an assertion that verifies this expected outcome.'
  program: ./Q-AssertBench/QAB11/program.py
  prompt: ./Q-AssertBench/QAB11/prompt.py
  gold_assertion: ./Q-AssertBench/QAB11/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB11/faulty.py
  metadata:
    qubits: 2
    shots: 1024
- id: QAB12
  title: Deutsch Algorithm with Configurable Oracle
  description: 'This quantum program implements the Deutsch algorithm with a configurable
    oracle. The oracle type is set by a parameter: oracle_type=0 corresponds to a
    constant function, while oracle_type=1 corresponds to a balanced function. The
    expected measurement outcome of the first qubit is deterministic and should match
    the oracle type. The task is to insert an assertion that verifies consistency
    between the oracle parameter and the observed result.'
  program: ./Q-AssertBench/QAB12/program.py
  prompt: ./Q-AssertBench/QAB12/prompt.py
  gold_assertion: ./Q-AssertBench/QAB12/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB12/faulty.py
  metadata:
    qubits: 2
    shots: 1024
- id: QAB13
  title: Deutsch Jozsa Algorithm with Fixed Balanced Oracle
  description: 'This quantum program implements the Deutsch Jozsa algorithm with two
    input qubits and one ancilla qubit. The oracle is fixed as a balanced function
    f(x0, x1) = x0 XOR x1. The expected measurement outcome is that the input qubits
    should never be observed as ''00'', which would indicate a constant function.
    The task is to insert an assertion that verifies this expected property.'
  program: ./Q-AssertBench/QAB13/program.py
  prompt: ./Q-AssertBench/QAB13/prompt.py
  gold_assertion: ./Q-AssertBench/QAB13/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB13/faulty.py
  metadata:
    qubits: 3
    shots: 1024
- id: QAB14
  title: Deutsch–Jozsa Algorithm with Configurable Oracle
  description: 'This quantum program implements the Deutsch–Jozsa algorithm with two
    input qubits and one ancilla qubit. The oracle type is determined by a parameter:
    oracle_type=0 corresponds to a constant function, while oracle_type=1 corresponds
    to a balanced function. The expected measurement outcomes differ accordingly:
    - For constant: the input qubits should be observed as ''00''. - For balanced:
    the input qubits should not be observed as ''00''. The task is to generate an
    assertion that verifies consistency between the oracle type and the observed measurement
    results.'
  program: ./Q-AssertBench/QAB14/program.py
  prompt: ./Q-AssertBench/QAB14/prompt.py
  gold_assertion: ./Q-AssertBench/QAB14/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB14/faulty.py
  metadata:
    qubits: 3
    shots: 1024
- id: QAB15
  title: Bernstein–Vazirani Algorithm and Uniform Superposition
  description: 'This quantum program implements the Bernstein–Vazirani algorithm with
    three input qubits and one ancilla qubit. A critical step in the algorithm is
    the preparation of a uniform superposition across all input qubits. The task is
    to generate an assertion that verifies this uniform distribution, ensuring that
    the Hadamard layer has been correctly applied.'
  program: ./Q-AssertBench/QAB15/program.py
  prompt: ./Q-AssertBench/QAB15/prompt.py
  gold_assertion: ./Q-AssertBench/QAB15/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB15/faulty.py
  metadata:
    qubits: 4
    shots: 1024
- id: QAB16
  title: Bernstein–Vazirani Algorithm and Final Output
  description: 'This quantum program implements the Bernstein–Vazirani algorithm with
    three input qubits and one ancilla qubit. The oracle encodes a hidden binary string
    a, and the final measurement of the input qubits should reveal this string with
    high probability. The task is to generate an assertion that verifies whether the
    observed measurement matches the hidden string.'
  program: ./Q-AssertBench/QAB16/program.py
  prompt: ./Q-AssertBench/QAB16/prompt.py
  gold_assertion: ./Q-AssertBench/QAB16/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB16/faulty.py
  metadata:
    qubits: 4
    shots: 1024
- id: QAB17
  title: Simon’s Algorithm – Uniform Superposition Preparation
  description: 'This quantum program implements Simon’s algorithm with a hidden period
    a = "11". At the beginning of the algorithm, the input qubits are placed into
    a uniform superposition state. The task is to generate an assertion that verifies
    whether this uniform distribution has been correctly prepared.'
  program: ./Q-AssertBench/QAB17/program.py
  prompt: ./Q-AssertBench/QAB17/prompt.py
  gold_assertion: ./Q-AssertBench/QAB17/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB17/faulty.py
  metadata:
    qubits: 4
    shots: 1024
- id: QAB18
  title: Simon’s Algorithm – Pairwise Input Collapse
  description: 'This quantum program implements Simon’s algorithm with hidden period
    a = "11". After measuring the output register, the input register should collapse
    into states that appear in pairs related by the hidden string. The task is to
    generate an assertion that verifies the presence of this pairwise structure in
    the input register measurement results.'
  program: ./Q-AssertBench/QAB18/program.py
  prompt: ./Q-AssertBench/QAB18/prompt.py
  gold_assertion: ./Q-AssertBench/QAB18/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB18/faulty.py
  metadata:
    qubits: 4
    shots: 1024
- id: QAB19
  title: Simon’s Algorithm – Final Constraint Check
  description: 'This quantum program implements Simon’s algorithm with hidden period
    a = "11". In the final step, the measurement results of the input qubits must
    satisfy the constraint z·a=0 (mod 2), where z is the observed bitstring and a
    is the hidden string. For a = "11", only ''00'' and ''11'' should appear, while
    ''01'' and ''10'' are invalid. The task is to generate an assertion that verifies
    this property in the observed results.'
  program: ./Q-AssertBench/QAB19/program.py
  prompt: ./Q-AssertBench/QAB19/prompt.py
  gold_assertion: ./Q-AssertBench/QAB19/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB19/faulty.py
  metadata:
    qubits: 4
    shots: 1024
- id: QAB20
  title: Periodic Oracle Construction
  description: 'This quantum program demonstrates the construction of a periodic oracle
    with hidden period a = "11". The oracle maps input qubits to output qubits such
    that f(x) = f(x XOR a). The input qubits are first prepared in a uniform superposition
    so that all input states are sampled. The task is to generate an assertion that
    verifies the oracle mapping respects this periodicity.'
  program: ./Q-AssertBench/QAB20/program.py
  prompt: ./Q-AssertBench/QAB20/prompt.py
  gold_assertion: ./Q-AssertBench/QAB20/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB20/faulty.py
  metadata:
    qubits: 4
    shots: 1024
- id: QAB21
  title: Quantum Fourier Transform (QFT) – Periodic Input Peaks
  description: 'This quantum program implements the Quantum Fourier Transform (QFT)
    on 3 qubits. A periodic input state (|000⟩ + |100⟩)/√2 is prepared before applying
    QFT. The expected result is a non-uniform measurement distribution with strong
    peaks, reflecting the Fourier transform of the periodic input. The task is to
    generate an assertion that verifies the presence of these peaks in the observed
    distribution.'
  program: ./Q-AssertBench/QAB21/program.py
  prompt: ./Q-AssertBench/QAB21/prompt.py
  gold_assertion: ./Q-AssertBench/QAB21/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB21/faulty.py
  metadata:
    qubits: 3
    shots: 1024
- id: QAB22
  title: Quantum Fourier Transform with Inverse (QFT + QFT†)
  description: 'This quantum program demonstrates that applying the Quantum Fourier
    Transform (QFT) followed by its inverse (QFT†) recovers the original input state.
    In this example, the input state |101⟩ is prepared. After QFT and QFT†, the measurement
    results should be concentrated on |101⟩ (probability > 0.5). The task is to generate
    an assertion that verifies this identity property.'
  program: ./Q-AssertBench/QAB22/program.py
  prompt: ./Q-AssertBench/QAB22/prompt.py
  gold_assertion: ./Q-AssertBench/QAB22/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB22/faulty.py
  metadata:
    qubits: 3
    shots: 1024
- id: QAB23
  title: Grover's Algorithm – Marked State Detection
  description: 'This quantum program implements Grover''s search algorithm on 3 qubits.
    The oracle marks two states, |101⟩ and |110⟩, and the diffusion operator amplifies
    their measurement probabilities. The expected result is that these marked states
    dominate the measurement outcomes. The task is to generate an assertion that verifies
    the dominance of the marked states.'
  program: ./Q-AssertBench/QAB23/program.py
  prompt: ./Q-AssertBench/QAB23/prompt.py
  gold_assertion: ./Q-AssertBench/QAB23/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB23/faulty.py
  metadata:
    qubits: 3
    shots: 1024
- id: QAB24
  title: Grover's Algorithm – Uniform Superposition Check
  description: 'This quantum program implements Grover''s algorithm on 3 qubits. A
    uniform superposition is prepared using Hadamard gates before applying the oracle
    and diffusion operator. The task is to generate an assertion that verifies the
    uniformity of this initial state preparation.'
  program: ./Q-AssertBench/QAB24/program.py
  prompt: ./Q-AssertBench/QAB24/prompt.py
  gold_assertion: ./Q-AssertBench/QAB24/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB24/faulty.py
  metadata:
    qubits: 3
    shots: 1024
- id: QAB25
  title: Grover's Algorithm – Diffusion Operator Check
  description: 'This quantum program implements Grover''s algorithm on 3 qubits. The
    oracle marks states |101⟩ and |110⟩, and the diffusion operator amplifies their
    probabilities. The task is to generate an assertion that verifies the amplification
    works correctly, by checking that the marked states dominate the final measurement
    results.'
  program: ./Q-AssertBench/QAB25/program.py
  prompt: ./Q-AssertBench/QAB25/prompt.py
  gold_assertion: ./Q-AssertBench/QAB25/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB25/faulty.py
  metadata:
    qubits: 3
    shots: 1024
- id: QAB26
  title: Shor's Algorithm – Period Finding
  description: 'This quantum program demonstrates the period-finding subroutine of
    Shor''s algorithm. For N=15 and a=2, the periodic function x ↦ 2^x mod 15 has
    period r=4. The expected measurement outcomes are consistent with multiples of
    2 in the computational basis (000, 010, 100, 110). The task is to generate an
    assertion that verifies this periodicity.'
  program: ./Q-AssertBench/QAB26/program.py
  prompt: ./Q-AssertBench/QAB26/prompt.py
  gold_assertion: ./Q-AssertBench/QAB26/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB26/faulty.py
  metadata:
    qubits: 5
    shots: 1024
- id: QAB27
  title: Shor's Algorithm – Continued Fraction Verification
  description: 'This quantum program demonstrates a simplified period-finding step
    of Shor''s algorithm for N=15, a=2. The quantum measurement provides an approximation
    to k/r, which must be classically post-processed using continued fraction expansion.
    The expected result is a period r=4. The task is to generate an assertion that
    verifies the continued fraction step correctly recovers r=4 from the quantum output.'
  program: ./Q-AssertBench/QAB27/program.py
  prompt: ./Q-AssertBench/QAB27/prompt.py
  gold_assertion: ./Q-AssertBench/QAB27/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB27/faulty.py
  metadata:
    qubits: 3
    shots: 1024
- id: QAB28
  title: HHL Algorithm – Solution Qubit Dominance Check
  description: 'This quantum program implements a simplified version of the Harrow-Hassidim-Lloyd
    (HHL) algorithm to solve a 2x2 linear system of equations using a 3-qubit circuit.
    The circuit approximates the inverse of a small Hermitian matrix A and encodes
    the solution to A·x=b in the amplitude of a solution qubit. The expected output
    is a dominant measurement in the |0⟩ state on the solution qubit. The task is
    to generate an assertion that checks whether the measurement distribution confirms
    this expected dominance.'
  program: ./Q-AssertBench/QAB28/program.py
  prompt: ./Q-AssertBench/QAB28/prompt.py
  gold_assertion: ./Q-AssertBench/QAB28/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB28/faulty.py
  metadata:
    qubits: 3
    shots: 1024
- id: QAB29
  title: Quantum Fourier Transform – Frequency Peak Validation (10-qubit)
  description: 'This benchmark applies a 10-qubit Quantum Fourier Transform (QFT)
    circuit to a carefully prepared periodic input state. The expected outcome of
    the QFT is a distribution with sharp peaks at basis states corresponding to the
    input''s frequency components. The task is to verify that the quantum circuit
    correctly concentrates output probability on these target frequencies.'
  program: ./Q-AssertBench/QAB29/program.py
  prompt: ./Q-AssertBench/QAB29/prompt.py
  gold_assertion: ./Q-AssertBench/QAB29/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB29/faulty.py
  metadata:
    qubits: 10
    shots: 2048
    period: 4
- id: QAB30
  title: Shor's Algorithm – Large-Scale Periodicity Detection
  description: 'This benchmark circuit simulates the structural behavior of Shor''s
    algorithm with 15 qubits. Though simplified, it models critical stages including
    counting superposition, entanglement, and inverse QFT. The objective is to test
    whether the output reflects a strong periodic structure in the counting register.'
  program: ./Q-AssertBench/QAB30/program.py
  prompt: ./Q-AssertBench/QAB30/prompt.py
  gold_assertion: ./Q-AssertBench/QAB30/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB30/faulty.py
  metadata:
    qubits: 15
    shots: 1024
- id: QAB31
  title: Grover's Algorithm – High-QuBit Target Amplification
  description: 'This benchmark evaluates a 15-qubit implementation of Grover''s algorithm.
    The task is to insert a diagnostic assertion that verifies whether the target
    bitstring is successfully amplified compared to other measurement outcomes. The
    circuit uses a controlled oracle and diffuser for amplitude amplification. A faulty
    variant disables the diffuser to simulate poor amplification, while the assertion
    checks if the target state is significantly more likely than any other.'
  program: ./Q-AssertBench/QAB31/program.py
  prompt: ./Q-AssertBench/QAB31/prompt.py
  gold_assertion: ./Q-AssertBench/QAB31/gold_assertion.py
  faulty_variant: ./Q-AssertBench/QAB31/faulty.py
  metadata:
    qubits: 15
    shots: 4096
